{
    "name": "opensearch",
    "displayName": "Opensearch",
    "description": "A Pulumi package for creating and managing Opensearch resources",
    "keywords": [
        "pulumi",
        "opensearch",
        "category/database"
    ],
    "homepage": "https://github.com/piclemx/pulumi-opensearch",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`opensearch` Terraform Provider](https://github.com/opensearch-project/terraform-provider-opensearch).",
    "repository": "https://github.com/piclemx/pulumi-opensearch",
    "logoUrl": "https://raw.githubusercontent.com/piclemx/pulumi-opensearch/main/docs/opensearch.png",
    "pluginDownloadURL": "github://api.github.com/piclemx/pulumi-opensearch",
    "publisher": "piclemx",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "compatibility": "tfbridge20",
            "rootNamespace": "Piclemx"
        },
        "go": {
            "importBasePath": "github.com/piclemx/pulumi-opensearch/sdk/go/opensearch",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true
        },
        "java": {
            "basePackage": "com.piclemx",
            "buildFiles": "",
            "gradleNexusPublishPluginVersion": "",
            "gradleTest": ""
        },
        "nodejs": {
            "packageName": "@piclemx/pulumi-opensearch",
            "packageDescription": "A Pulumi package for creating and managing Opensearch resources. Based on terraform-provider-opensearch: version v2.2.1",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/opensearch-project/terraform-provider-opensearch)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-opensearch` repo](https://github.com/piclemx/pulumi-opensearch/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-opensearch` repo](https://github.com/opensearch-project/terraform-provider-opensearch/issues).",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true
        },
        "python": {
            "packageName": "piclemx_pulumi_opensearch",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            },
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/opensearch-project/terraform-provider-opensearch)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-opensearch` repo](https://github.com/piclemx/pulumi-opensearch/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-opensearch` repo](https://github.com/opensearch-project/terraform-provider-opensearch/issues).",
            "compatibility": "tfbridge20",
            "pyproject": {}
        }
    },
    "config": {
        "variables": {
            "awsAccessKey": {
                "type": "string",
                "description": "The access key for use with AWS OpenSearch Service domains\n"
            },
            "awsAssumeRoleArn": {
                "type": "string",
                "description": "Amazon Resource Name of an IAM Role to assume prior to making AWS API calls.\n"
            },
            "awsAssumeRoleExternalId": {
                "type": "string",
                "description": "External ID configured in the IAM policy of the IAM Role to assume prior to making AWS API calls.\n"
            },
            "awsProfile": {
                "type": "string",
                "description": "The AWS profile for use with AWS OpenSearch Service domains\n"
            },
            "awsRegion": {
                "type": "string",
                "description": "The AWS region for use in signing of AWS OpenSearch requests. Must be specified in order to use AWS URL signing with AWS\nOpenSearch endpoint exposed on a custom DNS domain.\n"
            },
            "awsSecretKey": {
                "type": "string",
                "description": "The secret key for use with AWS OpenSearch Service domains\n"
            },
            "awsSignatureService": {
                "type": "string",
                "description": "AWS service name used in the credential scope of signed requests to OpenSearch.\n"
            },
            "awsToken": {
                "type": "string",
                "description": "The session token for use with AWS OpenSearch Service domains\n"
            },
            "cacertFile": {
                "type": "string",
                "description": "A Custom CA certificate\n"
            },
            "clientCertPath": {
                "type": "string",
                "description": "A X509 certificate to connect to OpenSearch\n"
            },
            "clientKeyPath": {
                "type": "string",
                "description": "A X509 key to connect to OpenSearch\n"
            },
            "healthcheck": {
                "type": "boolean",
                "description": "Set the client healthcheck option for the OpenSearch client. Healthchecking is designed for direct access to the\ncluster.\n"
            },
            "hostOverride": {
                "type": "string",
                "description": "If provided, sets the 'Host' header of requests and the 'ServerName' for certificate validation to this value. See the\ndocumentation on connecting to OpenSearch via an SSH tunnel.\n"
            },
            "insecure": {
                "type": "boolean",
                "description": "Disable SSL verification of API calls\n"
            },
            "opensearchVersion": {
                "type": "string",
                "description": "OpenSearch Version\n"
            },
            "password": {
                "type": "string",
                "description": "Password to use to connect to OpenSearch using basic auth\n"
            },
            "proxy": {
                "type": "string",
                "description": "Proxy URL to use for requests to OpenSearch.\n"
            },
            "signAwsRequests": {
                "type": "boolean",
                "description": "Enable signing of AWS OpenSearch requests. The `url` must refer to AWS ES domain (`*.\u003cregion\u003e.es.amazonaws.com`), or\n`aws_region` must be specified explicitly.\n"
            },
            "sniff": {
                "type": "boolean",
                "description": "Set the node sniffing option for the OpenSearch client. Client won't work with sniffing if nodes are not routable.\n"
            },
            "token": {
                "type": "string",
                "description": "A bearer token or ApiKey for an Authorization header, e.g. Active Directory API key.\n"
            },
            "tokenName": {
                "type": "string",
                "description": "The type of token, usually ApiKey or Bearer\n"
            },
            "url": {
                "type": "string",
                "description": "OpenSearch URL\n"
            },
            "username": {
                "type": "string",
                "description": "Username to use to connect to OpenSearch using basic auth\n"
            },
            "versionPingTimeout": {
                "type": "integer",
                "description": "Version ping timeout in seconds\n"
            }
        },
        "defaults": [
            "url"
        ]
    },
    "types": {
        "opensearch:index/AuditConfigAudit:AuditConfigAudit": {
            "properties": {
                "disabledRestCategories": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "disabledTransportCategories": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "enableRest": {
                    "type": "boolean"
                },
                "enableTransport": {
                    "type": "boolean"
                },
                "excludeSensitiveHeaders": {
                    "type": "boolean"
                },
                "ignoreRequests": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ignoreUsers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "logRequestBody": {
                    "type": "boolean"
                },
                "resolveBulkRequests": {
                    "type": "boolean"
                },
                "resolveIndices": {
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "opensearch:index/AuditConfigCompliance:AuditConfigCompliance": {
            "properties": {
                "enabled": {
                    "type": "boolean"
                },
                "externalConfig": {
                    "type": "boolean"
                },
                "internalConfig": {
                    "type": "boolean"
                },
                "readIgnoreUsers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "readMetadataOnly": {
                    "type": "boolean"
                },
                "readWatchedFields": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/opensearch:index/AuditConfigComplianceReadWatchedField:AuditConfigComplianceReadWatchedField"
                    }
                },
                "writeIgnoreUsers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "writeLogDiffs": {
                    "type": "boolean"
                },
                "writeMetadataOnly": {
                    "type": "boolean"
                },
                "writeWatchedIndices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "opensearch:index/AuditConfigComplianceReadWatchedField:AuditConfigComplianceReadWatchedField": {
            "properties": {
                "fields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "index": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "fields",
                "index"
            ]
        },
        "opensearch:index/RoleIndexPermission:RoleIndexPermission": {
            "properties": {
                "allowedActions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of allowed actions.\n"
                },
                "documentLevelSecurity": {
                    "type": "string",
                    "description": "A selector for document-level security (json formatted using jsonencode).\n"
                },
                "fieldLevelSecurities": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of selectors for field-level security.\n"
                },
                "indexPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of glob patterns for the index names.\n"
                },
                "maskedFields": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of masked fields\n"
                }
            },
            "type": "object"
        },
        "opensearch:index/RoleTenantPermission:RoleTenantPermission": {
            "properties": {
                "allowedActions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of allowed actions.\n"
                },
                "tenantPatterns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of glob patterns for the tenant names\n"
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the opensearch package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "awsAccessKey": {
                "type": "string",
                "description": "The access key for use with AWS OpenSearch Service domains\n"
            },
            "awsAssumeRoleArn": {
                "type": "string",
                "description": "Amazon Resource Name of an IAM Role to assume prior to making AWS API calls.\n"
            },
            "awsAssumeRoleExternalId": {
                "type": "string",
                "description": "External ID configured in the IAM policy of the IAM Role to assume prior to making AWS API calls.\n"
            },
            "awsProfile": {
                "type": "string",
                "description": "The AWS profile for use with AWS OpenSearch Service domains\n"
            },
            "awsRegion": {
                "type": "string",
                "description": "The AWS region for use in signing of AWS OpenSearch requests. Must be specified in order to use AWS URL signing with AWS\nOpenSearch endpoint exposed on a custom DNS domain.\n"
            },
            "awsSecretKey": {
                "type": "string",
                "description": "The secret key for use with AWS OpenSearch Service domains\n"
            },
            "awsSignatureService": {
                "type": "string",
                "description": "AWS service name used in the credential scope of signed requests to OpenSearch.\n"
            },
            "awsToken": {
                "type": "string",
                "description": "The session token for use with AWS OpenSearch Service domains\n"
            },
            "cacertFile": {
                "type": "string",
                "description": "A Custom CA certificate\n"
            },
            "clientCertPath": {
                "type": "string",
                "description": "A X509 certificate to connect to OpenSearch\n"
            },
            "clientKeyPath": {
                "type": "string",
                "description": "A X509 key to connect to OpenSearch\n"
            },
            "healthcheck": {
                "type": "boolean",
                "description": "Set the client healthcheck option for the OpenSearch client. Healthchecking is designed for direct access to the\ncluster.\n"
            },
            "hostOverride": {
                "type": "string",
                "description": "If provided, sets the 'Host' header of requests and the 'ServerName' for certificate validation to this value. See the\ndocumentation on connecting to OpenSearch via an SSH tunnel.\n"
            },
            "insecure": {
                "type": "boolean",
                "description": "Disable SSL verification of API calls\n"
            },
            "opensearchVersion": {
                "type": "string",
                "description": "OpenSearch Version\n"
            },
            "password": {
                "type": "string",
                "description": "Password to use to connect to OpenSearch using basic auth\n"
            },
            "proxy": {
                "type": "string",
                "description": "Proxy URL to use for requests to OpenSearch.\n"
            },
            "signAwsRequests": {
                "type": "boolean",
                "description": "Enable signing of AWS OpenSearch requests. The `url` must refer to AWS ES domain (`*.\u003cregion\u003e.es.amazonaws.com`), or\n`aws_region` must be specified explicitly.\n"
            },
            "sniff": {
                "type": "boolean",
                "description": "Set the node sniffing option for the OpenSearch client. Client won't work with sniffing if nodes are not routable.\n"
            },
            "token": {
                "type": "string",
                "description": "A bearer token or ApiKey for an Authorization header, e.g. Active Directory API key.\n"
            },
            "tokenName": {
                "type": "string",
                "description": "The type of token, usually ApiKey or Bearer\n"
            },
            "url": {
                "type": "string",
                "description": "OpenSearch URL\n"
            },
            "username": {
                "type": "string",
                "description": "Username to use to connect to OpenSearch using basic auth\n"
            },
            "versionPingTimeout": {
                "type": "integer",
                "description": "Version ping timeout in seconds\n"
            }
        },
        "required": [
            "url"
        ],
        "inputProperties": {
            "awsAccessKey": {
                "type": "string",
                "description": "The access key for use with AWS OpenSearch Service domains\n"
            },
            "awsAssumeRoleArn": {
                "type": "string",
                "description": "Amazon Resource Name of an IAM Role to assume prior to making AWS API calls.\n"
            },
            "awsAssumeRoleExternalId": {
                "type": "string",
                "description": "External ID configured in the IAM policy of the IAM Role to assume prior to making AWS API calls.\n"
            },
            "awsProfile": {
                "type": "string",
                "description": "The AWS profile for use with AWS OpenSearch Service domains\n"
            },
            "awsRegion": {
                "type": "string",
                "description": "The AWS region for use in signing of AWS OpenSearch requests. Must be specified in order to use AWS URL signing with AWS\nOpenSearch endpoint exposed on a custom DNS domain.\n"
            },
            "awsSecretKey": {
                "type": "string",
                "description": "The secret key for use with AWS OpenSearch Service domains\n"
            },
            "awsSignatureService": {
                "type": "string",
                "description": "AWS service name used in the credential scope of signed requests to OpenSearch.\n"
            },
            "awsToken": {
                "type": "string",
                "description": "The session token for use with AWS OpenSearch Service domains\n"
            },
            "cacertFile": {
                "type": "string",
                "description": "A Custom CA certificate\n"
            },
            "clientCertPath": {
                "type": "string",
                "description": "A X509 certificate to connect to OpenSearch\n"
            },
            "clientKeyPath": {
                "type": "string",
                "description": "A X509 key to connect to OpenSearch\n"
            },
            "healthcheck": {
                "type": "boolean",
                "description": "Set the client healthcheck option for the OpenSearch client. Healthchecking is designed for direct access to the\ncluster.\n"
            },
            "hostOverride": {
                "type": "string",
                "description": "If provided, sets the 'Host' header of requests and the 'ServerName' for certificate validation to this value. See the\ndocumentation on connecting to OpenSearch via an SSH tunnel.\n"
            },
            "insecure": {
                "type": "boolean",
                "description": "Disable SSL verification of API calls\n"
            },
            "opensearchVersion": {
                "type": "string",
                "description": "OpenSearch Version\n"
            },
            "password": {
                "type": "string",
                "description": "Password to use to connect to OpenSearch using basic auth\n"
            },
            "proxy": {
                "type": "string",
                "description": "Proxy URL to use for requests to OpenSearch.\n"
            },
            "signAwsRequests": {
                "type": "boolean",
                "description": "Enable signing of AWS OpenSearch requests. The `url` must refer to AWS ES domain (`*.\u003cregion\u003e.es.amazonaws.com`), or\n`aws_region` must be specified explicitly.\n"
            },
            "sniff": {
                "type": "boolean",
                "description": "Set the node sniffing option for the OpenSearch client. Client won't work with sniffing if nodes are not routable.\n"
            },
            "token": {
                "type": "string",
                "description": "A bearer token or ApiKey for an Authorization header, e.g. Active Directory API key.\n"
            },
            "tokenName": {
                "type": "string",
                "description": "The type of token, usually ApiKey or Bearer\n"
            },
            "url": {
                "type": "string",
                "description": "OpenSearch URL\n"
            },
            "username": {
                "type": "string",
                "description": "Username to use to connect to OpenSearch using basic auth\n"
            },
            "versionPingTimeout": {
                "type": "integer",
                "description": "Version ping timeout in seconds\n"
            }
        },
        "requiredInputs": [
            "url"
        ]
    },
    "resources": {
        "opensearch:index/anomalyDetection:AnomalyDetection": {
            "description": "Provides an OpenSearch anonaly detection. Please refer to the OpenSearch anomaly detection documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\nconst foo = new opensearch.AnomalyDetection(\"foo\", {body: `{\n  \"name\": \"foo\",\n  \"description\": \"Test detector\",\n  \"time_field\": \"@timestamp\",\n  \"indices\": [\n    \"security-auditlog*\"\n  ],\n  \"feature_attributes\": [\n    {\n      \"feature_name\": \"test\",\n      \"feature_enabled\": true,\n      \"aggregation_query\": {\n        \"test\": {\n          \"value_count\": {\n            \"field\": \"audit_category.keyword\"\n          }\n        }\n      }\n    }\n  ],\n  \"filter_query\": {\n    \"bool\": {\n      \"filter\": [\n        {\n          \"range\": {\n            \"value\": {\n              \"gt\": 1\n            }\n          }\n        }\n      ],\n      \"adjust_pure_negative\": true,\n      \"boost\": 1\n    }\n  },\n  \"detection_interval\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"Minutes\"\n    }\n  },\n  \"window_delay\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"Minutes\"\n    }\n  },\n  \"result_index\" : \"opensearch-ad-plugin-result-test\"\n}\n\n`});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\nfoo = opensearch.AnomalyDetection(\"foo\", body=\"\"\"{\n  \"name\": \"foo\",\n  \"description\": \"Test detector\",\n  \"time_field\": \"@timestamp\",\n  \"indices\": [\n    \"security-auditlog*\"\n  ],\n  \"feature_attributes\": [\n    {\n      \"feature_name\": \"test\",\n      \"feature_enabled\": true,\n      \"aggregation_query\": {\n        \"test\": {\n          \"value_count\": {\n            \"field\": \"audit_category.keyword\"\n          }\n        }\n      }\n    }\n  ],\n  \"filter_query\": {\n    \"bool\": {\n      \"filter\": [\n        {\n          \"range\": {\n            \"value\": {\n              \"gt\": 1\n            }\n          }\n        }\n      ],\n      \"adjust_pure_negative\": true,\n      \"boost\": 1\n    }\n  },\n  \"detection_interval\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"Minutes\"\n    }\n  },\n  \"window_delay\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"Minutes\"\n    }\n  },\n  \"result_index\" : \"opensearch-ad-plugin-result-test\"\n}\n\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foo = new Opensearch.AnomalyDetection(\"foo\", new()\n    {\n        Body = @\"{\n  \"\"name\"\": \"\"foo\"\",\n  \"\"description\"\": \"\"Test detector\"\",\n  \"\"time_field\"\": \"\"@timestamp\"\",\n  \"\"indices\"\": [\n    \"\"security-auditlog*\"\"\n  ],\n  \"\"feature_attributes\"\": [\n    {\n      \"\"feature_name\"\": \"\"test\"\",\n      \"\"feature_enabled\"\": true,\n      \"\"aggregation_query\"\": {\n        \"\"test\"\": {\n          \"\"value_count\"\": {\n            \"\"field\"\": \"\"audit_category.keyword\"\"\n          }\n        }\n      }\n    }\n  ],\n  \"\"filter_query\"\": {\n    \"\"bool\"\": {\n      \"\"filter\"\": [\n        {\n          \"\"range\"\": {\n            \"\"value\"\": {\n              \"\"gt\"\": 1\n            }\n          }\n        }\n      ],\n      \"\"adjust_pure_negative\"\": true,\n      \"\"boost\"\": 1\n    }\n  },\n  \"\"detection_interval\"\": {\n    \"\"period\"\": {\n      \"\"interval\"\": 1,\n      \"\"unit\"\": \"\"Minutes\"\"\n    }\n  },\n  \"\"window_delay\"\": {\n    \"\"period\"\": {\n      \"\"interval\"\": 1,\n      \"\"unit\"\": \"\"Minutes\"\"\n    }\n  },\n  \"\"result_index\"\" : \"\"opensearch-ad-plugin-result-test\"\"\n}\n\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewAnomalyDetection(ctx, \"foo\", \u0026opensearch.AnomalyDetectionArgs{\n\t\t\tBody: pulumi.String(`{\n  \"name\": \"foo\",\n  \"description\": \"Test detector\",\n  \"time_field\": \"@timestamp\",\n  \"indices\": [\n    \"security-auditlog*\"\n  ],\n  \"feature_attributes\": [\n    {\n      \"feature_name\": \"test\",\n      \"feature_enabled\": true,\n      \"aggregation_query\": {\n        \"test\": {\n          \"value_count\": {\n            \"field\": \"audit_category.keyword\"\n          }\n        }\n      }\n    }\n  ],\n  \"filter_query\": {\n    \"bool\": {\n      \"filter\": [\n        {\n          \"range\": {\n            \"value\": {\n              \"gt\": 1\n            }\n          }\n        }\n      ],\n      \"adjust_pure_negative\": true,\n      \"boost\": 1\n    }\n  },\n  \"detection_interval\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"Minutes\"\n    }\n  },\n  \"window_delay\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"Minutes\"\n    }\n  },\n  \"result_index\" : \"opensearch-ad-plugin-result-test\"\n}\n\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.AnomalyDetection;\nimport com.pulumi.opensearch.AnomalyDetectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foo = new AnomalyDetection(\"foo\", AnomalyDetectionArgs.builder()        \n            .body(\"\"\"\n{\n  \"name\": \"foo\",\n  \"description\": \"Test detector\",\n  \"time_field\": \"@timestamp\",\n  \"indices\": [\n    \"security-auditlog*\"\n  ],\n  \"feature_attributes\": [\n    {\n      \"feature_name\": \"test\",\n      \"feature_enabled\": true,\n      \"aggregation_query\": {\n        \"test\": {\n          \"value_count\": {\n            \"field\": \"audit_category.keyword\"\n          }\n        }\n      }\n    }\n  ],\n  \"filter_query\": {\n    \"bool\": {\n      \"filter\": [\n        {\n          \"range\": {\n            \"value\": {\n              \"gt\": 1\n            }\n          }\n        }\n      ],\n      \"adjust_pure_negative\": true,\n      \"boost\": 1\n    }\n  },\n  \"detection_interval\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"Minutes\"\n    }\n  },\n  \"window_delay\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"Minutes\"\n    }\n  },\n  \"result_index\" : \"opensearch-ad-plugin-result-test\"\n}\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foo:\n    type: opensearch:AnomalyDetection\n    properties:\n      body: |+\n        {\n          \"name\": \"foo\",\n          \"description\": \"Test detector\",\n          \"time_field\": \"@timestamp\",\n          \"indices\": [\n            \"security-auditlog*\"\n          ],\n          \"feature_attributes\": [\n            {\n              \"feature_name\": \"test\",\n              \"feature_enabled\": true,\n              \"aggregation_query\": {\n                \"test\": {\n                  \"value_count\": {\n                    \"field\": \"audit_category.keyword\"\n                  }\n                }\n              }\n            }\n          ],\n          \"filter_query\": {\n            \"bool\": {\n              \"filter\": [\n                {\n                  \"range\": {\n                    \"value\": {\n                      \"gt\": 1\n                    }\n                  }\n                }\n              ],\n              \"adjust_pure_negative\": true,\n              \"boost\": 1\n            }\n          },\n          \"detection_interval\": {\n            \"period\": {\n              \"interval\": 1,\n              \"unit\": \"Minutes\"\n            }\n          },\n          \"window_delay\": {\n            \"period\": {\n              \"interval\": 1,\n              \"unit\": \"Minutes\"\n            }\n          },\n          \"result_index\" : \"opensearch-ad-plugin-result-test\"\n        }\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The anomaly detection document\n"
                }
            },
            "required": [
                "body"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The anomaly detection document\n"
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AnomalyDetection resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The anomaly detection document\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/auditConfig:AuditConfig": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\nconst test = new opensearch.AuditConfig(\"test\", {\n    audit: {\n        disabledRestCategories: [\n            \"GRANTED_PRIVILEGES\",\n            \"AUTHENTICATED\",\n        ],\n        disabledTransportCategories: [\n            \"GRANTED_PRIVILEGES\",\n            \"AUTHENTICATED\",\n        ],\n        enableRest: true,\n        enableTransport: true,\n        excludeSensitiveHeaders: true,\n        ignoreRequests: [\n            \"SearchRequest\",\n            \"indices:data/read/*\",\n            \"/_cluster/health\",\n        ],\n        ignoreUsers: [\"dashboardserver\"],\n        logRequestBody: true,\n        resolveBulkRequests: true,\n        resolveIndices: true,\n    },\n    compliance: {\n        enabled: true,\n        externalConfig: false,\n        internalConfig: true,\n        readIgnoreUsers: [\"read-ignore-1\"],\n        readMetadataOnly: true,\n        readWatchedFields: [\n            {\n                fields: [\n                    \"field-1\",\n                    \"field-2\",\n                ],\n                index: \"read-index-1\",\n            },\n            {\n                fields: [\"field-3\"],\n                index: \"read-index-2\",\n            },\n        ],\n        writeIgnoreUsers: [\"write-ignore-1\"],\n        writeLogDiffs: false,\n        writeMetadataOnly: true,\n        writeWatchedIndices: [\n            \"write-index-1\",\n            \"write-index-2\",\n            \"log-*\",\n            \"*\",\n        ],\n    },\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\ntest = opensearch.AuditConfig(\"test\",\n    audit=opensearch.AuditConfigAuditArgs(\n        disabled_rest_categories=[\n            \"GRANTED_PRIVILEGES\",\n            \"AUTHENTICATED\",\n        ],\n        disabled_transport_categories=[\n            \"GRANTED_PRIVILEGES\",\n            \"AUTHENTICATED\",\n        ],\n        enable_rest=True,\n        enable_transport=True,\n        exclude_sensitive_headers=True,\n        ignore_requests=[\n            \"SearchRequest\",\n            \"indices:data/read/*\",\n            \"/_cluster/health\",\n        ],\n        ignore_users=[\"dashboardserver\"],\n        log_request_body=True,\n        resolve_bulk_requests=True,\n        resolve_indices=True,\n    ),\n    compliance=opensearch.AuditConfigComplianceArgs(\n        enabled=True,\n        external_config=False,\n        internal_config=True,\n        read_ignore_users=[\"read-ignore-1\"],\n        read_metadata_only=True,\n        read_watched_fields=[\n            opensearch.AuditConfigComplianceReadWatchedFieldArgs(\n                fields=[\n                    \"field-1\",\n                    \"field-2\",\n                ],\n                index=\"read-index-1\",\n            ),\n            opensearch.AuditConfigComplianceReadWatchedFieldArgs(\n                fields=[\"field-3\"],\n                index=\"read-index-2\",\n            ),\n        ],\n        write_ignore_users=[\"write-ignore-1\"],\n        write_log_diffs=False,\n        write_metadata_only=True,\n        write_watched_indices=[\n            \"write-index-1\",\n            \"write-index-2\",\n            \"log-*\",\n            \"*\",\n        ],\n    ),\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Opensearch.AuditConfig(\"test\", new()\n    {\n        Audit = new Opensearch.Inputs.AuditConfigAuditArgs\n        {\n            DisabledRestCategories = new[]\n            {\n                \"GRANTED_PRIVILEGES\",\n                \"AUTHENTICATED\",\n            },\n            DisabledTransportCategories = new[]\n            {\n                \"GRANTED_PRIVILEGES\",\n                \"AUTHENTICATED\",\n            },\n            EnableRest = true,\n            EnableTransport = true,\n            ExcludeSensitiveHeaders = true,\n            IgnoreRequests = new[]\n            {\n                \"SearchRequest\",\n                \"indices:data/read/*\",\n                \"/_cluster/health\",\n            },\n            IgnoreUsers = new[]\n            {\n                \"dashboardserver\",\n            },\n            LogRequestBody = true,\n            ResolveBulkRequests = true,\n            ResolveIndices = true,\n        },\n        Compliance = new Opensearch.Inputs.AuditConfigComplianceArgs\n        {\n            Enabled = true,\n            ExternalConfig = false,\n            InternalConfig = true,\n            ReadIgnoreUsers = new[]\n            {\n                \"read-ignore-1\",\n            },\n            ReadMetadataOnly = true,\n            ReadWatchedFields = new[]\n            {\n                new Opensearch.Inputs.AuditConfigComplianceReadWatchedFieldArgs\n                {\n                    Fields = new[]\n                    {\n                        \"field-1\",\n                        \"field-2\",\n                    },\n                    Index = \"read-index-1\",\n                },\n                new Opensearch.Inputs.AuditConfigComplianceReadWatchedFieldArgs\n                {\n                    Fields = new[]\n                    {\n                        \"field-3\",\n                    },\n                    Index = \"read-index-2\",\n                },\n            },\n            WriteIgnoreUsers = new[]\n            {\n                \"write-ignore-1\",\n            },\n            WriteLogDiffs = false,\n            WriteMetadataOnly = true,\n            WriteWatchedIndices = new[]\n            {\n                \"write-index-1\",\n                \"write-index-2\",\n                \"log-*\",\n                \"*\",\n            },\n        },\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewAuditConfig(ctx, \"test\", \u0026opensearch.AuditConfigArgs{\n\t\t\tAudit: \u0026opensearch.AuditConfigAuditArgs{\n\t\t\t\tDisabledRestCategories: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"GRANTED_PRIVILEGES\"),\n\t\t\t\t\tpulumi.String(\"AUTHENTICATED\"),\n\t\t\t\t},\n\t\t\t\tDisabledTransportCategories: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"GRANTED_PRIVILEGES\"),\n\t\t\t\t\tpulumi.String(\"AUTHENTICATED\"),\n\t\t\t\t},\n\t\t\t\tEnableRest:              pulumi.Bool(true),\n\t\t\t\tEnableTransport:         pulumi.Bool(true),\n\t\t\t\tExcludeSensitiveHeaders: pulumi.Bool(true),\n\t\t\t\tIgnoreRequests: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"SearchRequest\"),\n\t\t\t\t\tpulumi.String(\"indices:data/read/*\"),\n\t\t\t\t\tpulumi.String(\"/_cluster/health\"),\n\t\t\t\t},\n\t\t\t\tIgnoreUsers: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"dashboardserver\"),\n\t\t\t\t},\n\t\t\t\tLogRequestBody:      pulumi.Bool(true),\n\t\t\t\tResolveBulkRequests: pulumi.Bool(true),\n\t\t\t\tResolveIndices:      pulumi.Bool(true),\n\t\t\t},\n\t\t\tCompliance: \u0026opensearch.AuditConfigComplianceArgs{\n\t\t\t\tEnabled:        pulumi.Bool(true),\n\t\t\t\tExternalConfig: pulumi.Bool(false),\n\t\t\t\tInternalConfig: pulumi.Bool(true),\n\t\t\t\tReadIgnoreUsers: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"read-ignore-1\"),\n\t\t\t\t},\n\t\t\t\tReadMetadataOnly: pulumi.Bool(true),\n\t\t\t\tReadWatchedFields: opensearch.AuditConfigComplianceReadWatchedFieldArray{\n\t\t\t\t\t\u0026opensearch.AuditConfigComplianceReadWatchedFieldArgs{\n\t\t\t\t\t\tFields: pulumi.StringArray{\n\t\t\t\t\t\t\tpulumi.String(\"field-1\"),\n\t\t\t\t\t\t\tpulumi.String(\"field-2\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tIndex: pulumi.String(\"read-index-1\"),\n\t\t\t\t\t},\n\t\t\t\t\t\u0026opensearch.AuditConfigComplianceReadWatchedFieldArgs{\n\t\t\t\t\t\tFields: pulumi.StringArray{\n\t\t\t\t\t\t\tpulumi.String(\"field-3\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tIndex: pulumi.String(\"read-index-2\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tWriteIgnoreUsers: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"write-ignore-1\"),\n\t\t\t\t},\n\t\t\t\tWriteLogDiffs:     pulumi.Bool(false),\n\t\t\t\tWriteMetadataOnly: pulumi.Bool(true),\n\t\t\t\tWriteWatchedIndices: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"write-index-1\"),\n\t\t\t\t\tpulumi.String(\"write-index-2\"),\n\t\t\t\t\tpulumi.String(\"log-*\"),\n\t\t\t\t\tpulumi.String(\"*\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.AuditConfig;\nimport com.pulumi.opensearch.AuditConfigArgs;\nimport com.pulumi.opensearch.inputs.AuditConfigAuditArgs;\nimport com.pulumi.opensearch.inputs.AuditConfigComplianceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AuditConfig(\"test\", AuditConfigArgs.builder()        \n            .audit(AuditConfigAuditArgs.builder()\n                .disabledRestCategories(                \n                    \"GRANTED_PRIVILEGES\",\n                    \"AUTHENTICATED\")\n                .disabledTransportCategories(                \n                    \"GRANTED_PRIVILEGES\",\n                    \"AUTHENTICATED\")\n                .enableRest(true)\n                .enableTransport(true)\n                .excludeSensitiveHeaders(true)\n                .ignoreRequests(                \n                    \"SearchRequest\",\n                    \"indices:data/read/*\",\n                    \"/_cluster/health\")\n                .ignoreUsers(\"dashboardserver\")\n                .logRequestBody(true)\n                .resolveBulkRequests(true)\n                .resolveIndices(true)\n                .build())\n            .compliance(AuditConfigComplianceArgs.builder()\n                .enabled(true)\n                .externalConfig(false)\n                .internalConfig(true)\n                .readIgnoreUsers(\"read-ignore-1\")\n                .readMetadataOnly(true)\n                .readWatchedFields(                \n                    AuditConfigComplianceReadWatchedFieldArgs.builder()\n                        .fields(                        \n                            \"field-1\",\n                            \"field-2\")\n                        .index(\"read-index-1\")\n                        .build(),\n                    AuditConfigComplianceReadWatchedFieldArgs.builder()\n                        .fields(\"field-3\")\n                        .index(\"read-index-2\")\n                        .build())\n                .writeIgnoreUsers(\"write-ignore-1\")\n                .writeLogDiffs(false)\n                .writeMetadataOnly(true)\n                .writeWatchedIndices(                \n                    \"write-index-1\",\n                    \"write-index-2\",\n                    \"log-*\",\n                    \"*\")\n                .build())\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: opensearch:AuditConfig\n    properties:\n      audit:\n        disabledRestCategories:\n          - GRANTED_PRIVILEGES\n          - AUTHENTICATED\n        disabledTransportCategories:\n          - GRANTED_PRIVILEGES\n          - AUTHENTICATED\n        enableRest: true\n        enableTransport: true\n        excludeSensitiveHeaders: true\n        ignoreRequests:\n          - SearchRequest\n          - indices:data/read/*\n          - /_cluster/health\n        ignoreUsers:\n          - dashboardserver\n        logRequestBody: true\n        resolveBulkRequests: true\n        resolveIndices: true\n      compliance:\n        enabled: true\n        externalConfig: false\n        internalConfig: true\n        readIgnoreUsers:\n          - read-ignore-1\n        readMetadataOnly: true\n        readWatchedFields:\n          - fields:\n              - field-1\n              - field-2\n            index: read-index-1\n          - fields:\n              - field-3\n            index: read-index-2\n        writeIgnoreUsers:\n          - write-ignore-1\n        writeLogDiffs: false\n        writeMetadataOnly: true\n        writeWatchedIndices:\n          - write-index-1\n          - write-index-2\n          - log-*\n          - '*'\n      enabled: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport by name\n\n```sh\n $ pulumi import opensearch:index/auditConfig:AuditConfig test_config my-config\n```\n\n ",
            "properties": {
                "audit": {
                    "$ref": "#/types/opensearch:index/AuditConfigAudit:AuditConfigAudit"
                },
                "compliance": {
                    "$ref": "#/types/opensearch:index/AuditConfigCompliance:AuditConfigCompliance"
                },
                "enabled": {
                    "type": "boolean"
                }
            },
            "required": [
                "enabled"
            ],
            "inputProperties": {
                "audit": {
                    "$ref": "#/types/opensearch:index/AuditConfigAudit:AuditConfigAudit"
                },
                "compliance": {
                    "$ref": "#/types/opensearch:index/AuditConfigCompliance:AuditConfigCompliance"
                },
                "enabled": {
                    "type": "boolean"
                }
            },
            "requiredInputs": [
                "enabled"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AuditConfig resources.\n",
                "properties": {
                    "audit": {
                        "$ref": "#/types/opensearch:index/AuditConfigAudit:AuditConfigAudit"
                    },
                    "compliance": {
                        "$ref": "#/types/opensearch:index/AuditConfigCompliance:AuditConfigCompliance"
                    },
                    "enabled": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/channelConfiguration:ChannelConfiguration": {
            "description": "Provides an OpenSearch channel configuration. Please refer to the OpenSearch channel configuration documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\n// Create a channel configuration\nconst configuration1 = new opensearch.ChannelConfiguration(\"configuration1\", {body: `{\n  \"config_id\": \"configuration_1\",\n  \"config\": {\n    \"name\": \"name\",\n    \"description\" : \"description\",\n    \"config_type\" : \"slack\",\n    \"is_enabled\" : true,\n    \"slack\": {\n      \"url\": \"https://sample-slack-webhook\"\n    }\n  }\n}\n\n`});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\n# Create a channel configuration\nconfiguration1 = opensearch.ChannelConfiguration(\"configuration1\", body=\"\"\"{\n  \"config_id\": \"configuration_1\",\n  \"config\": {\n    \"name\": \"name\",\n    \"description\" : \"description\",\n    \"config_type\" : \"slack\",\n    \"is_enabled\" : true,\n    \"slack\": {\n      \"url\": \"https://sample-slack-webhook\"\n    }\n  }\n}\n\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a channel configuration\n    var configuration1 = new Opensearch.ChannelConfiguration(\"configuration1\", new()\n    {\n        Body = @\"{\n  \"\"config_id\"\": \"\"configuration_1\"\",\n  \"\"config\"\": {\n    \"\"name\"\": \"\"name\"\",\n    \"\"description\"\" : \"\"description\"\",\n    \"\"config_type\"\" : \"\"slack\"\",\n    \"\"is_enabled\"\" : true,\n    \"\"slack\"\": {\n      \"\"url\"\": \"\"https://sample-slack-webhook\"\"\n    }\n  }\n}\n\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewChannelConfiguration(ctx, \"configuration1\", \u0026opensearch.ChannelConfigurationArgs{\n\t\t\tBody: pulumi.String(`{\n  \"config_id\": \"configuration_1\",\n  \"config\": {\n    \"name\": \"name\",\n    \"description\" : \"description\",\n    \"config_type\" : \"slack\",\n    \"is_enabled\" : true,\n    \"slack\": {\n      \"url\": \"https://sample-slack-webhook\"\n    }\n  }\n}\n\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.ChannelConfiguration;\nimport com.pulumi.opensearch.ChannelConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var configuration1 = new ChannelConfiguration(\"configuration1\", ChannelConfigurationArgs.builder()        \n            .body(\"\"\"\n{\n  \"config_id\": \"configuration_1\",\n  \"config\": {\n    \"name\": \"name\",\n    \"description\" : \"description\",\n    \"config_type\" : \"slack\",\n    \"is_enabled\" : true,\n    \"slack\": {\n      \"url\": \"https://sample-slack-webhook\"\n    }\n  }\n}\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a channel configuration\n  configuration1:\n    type: opensearch:ChannelConfiguration\n    properties:\n      body: |+\n        {\n          \"config_id\": \"configuration_1\",\n          \"config\": {\n            \"name\": \"name\",\n            \"description\" : \"description\",\n            \"config_type\" : \"slack\",\n            \"is_enabled\" : true,\n            \"slack\": {\n              \"url\": \"https://sample-slack-webhook\"\n            }\n          }\n        }\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/channelConfiguration:ChannelConfiguration configuration_1 configuration_1\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The channel configuration document\n"
                }
            },
            "required": [
                "body"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The channel configuration document\n"
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ChannelConfiguration resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The channel configuration document\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/clusterSettings:ClusterSettings": {
            "description": "Manages a cluster's (persistent) settings.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\nconst global = new opensearch.ClusterSettings(\"global\", {\n    actionAutoCreateIndex: \"my-index-000001,index10,-index1*,+ind*\",\n    clusterMaxShardsPerNode: 10,\n});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\nglobal_ = opensearch.ClusterSettings(\"global\",\n    action_auto_create_index=\"my-index-000001,index10,-index1*,+ind*\",\n    cluster_max_shards_per_node=10)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @global = new Opensearch.ClusterSettings(\"global\", new()\n    {\n        ActionAutoCreateIndex = \"my-index-000001,index10,-index1*,+ind*\",\n        ClusterMaxShardsPerNode = 10,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewClusterSettings(ctx, \"global\", \u0026opensearch.ClusterSettingsArgs{\n\t\t\tActionAutoCreateIndex:   pulumi.String(\"my-index-000001,index10,-index1*,+ind*\"),\n\t\t\tClusterMaxShardsPerNode: pulumi.Int(10),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.ClusterSettings;\nimport com.pulumi.opensearch.ClusterSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var global = new ClusterSettings(\"global\", ClusterSettingsArgs.builder()        \n            .actionAutoCreateIndex(\"my-index-000001,index10,-index1*,+ind*\")\n            .clusterMaxShardsPerNode(10)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  global:\n    type: opensearch:ClusterSettings\n    properties:\n      actionAutoCreateIndex: my-index-000001,index10,-index1*,+ind*\n      clusterMaxShardsPerNode: 10\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "actionAutoCreateIndex": {
                    "type": "string",
                    "description": "Whether to automatically create an index if it doesnt already exist and apply any configured index template\n"
                },
                "actionDestructiveRequiresName": {
                    "type": "boolean",
                    "description": "When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards\n"
                },
                "clusterBlocksReadOnly": {
                    "type": "boolean",
                    "description": "Make the whole cluster read only and metadata is not allowed to be modified\n"
                },
                "clusterBlocksReadOnlyAllowDelete": {
                    "type": "boolean",
                    "description": "Make the whole cluster read only, but allows to delete indices to free up resources\n"
                },
                "clusterIndicesCloseEnable": {
                    "type": "boolean",
                    "description": "If false, you cannot close open indices\n"
                },
                "clusterInfoUpdateInterval": {
                    "type": "string",
                    "description": "A time string controlling how often OpenSearch should check on disk usage for each node in the cluster\n"
                },
                "clusterMaxShardsPerNode": {
                    "type": "integer",
                    "description": "The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit\n"
                },
                "clusterMaxShardsPerNodeFrozen": {
                    "type": "integer",
                    "description": "The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.\n"
                },
                "clusterNoMasterBlock": {
                    "type": "string",
                    "description": "Specifies which operations are rejected when there is no active master in a cluster (all, write)\n"
                },
                "clusterPersistentTasksAllocationEnable": {
                    "type": "string",
                    "description": "Whether allocation for persistent tasks is active (all, none)\n"
                },
                "clusterPersistentTasksAllocationRecheckInterval": {
                    "type": "string",
                    "description": "A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes\n"
                },
                "clusterRoutingAllocationAllowRebalance": {
                    "type": "string",
                    "description": "Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)\n"
                },
                "clusterRoutingAllocationAwarenessAttributes": {
                    "type": "string",
                    "description": "Use custom node attributes to take hardware configuration into account when allocating shards\n"
                },
                "clusterRoutingAllocationBalanceIndex": {
                    "type": "number",
                    "description": "Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes\n"
                },
                "clusterRoutingAllocationBalanceShard": {
                    "type": "number",
                    "description": "Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes\n"
                },
                "clusterRoutingAllocationBalanceThreshold": {
                    "type": "number",
                    "description": "Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance\n"
                },
                "clusterRoutingAllocationClusterConcurrentRebalance": {
                    "type": "integer",
                    "description": "How many concurrent shard rebalances are allowed cluster wide\n"
                },
                "clusterRoutingAllocationDiskIncludeRelocations": {
                    "type": "boolean",
                    "description": "Whether the allocator will take into account shards that are currently being relocated to the target node when computing a nodes disk usage\n"
                },
                "clusterRoutingAllocationDiskThresholdEnabled": {
                    "type": "boolean",
                    "description": "Whether the disk allocation decider is active\n"
                },
                "clusterRoutingAllocationDiskWatermarkHigh": {
                    "type": "string",
                    "description": "Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used\n"
                },
                "clusterRoutingAllocationDiskWatermarkLow": {
                    "type": "string",
                    "description": "Allocator will not allocate shards to nodes that have more than this percentage disk used\n"
                },
                "clusterRoutingAllocationEnable": {
                    "type": "string",
                    "description": "Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)\n"
                },
                "clusterRoutingAllocationNodeConcurrentIncomingRecoveries": {
                    "type": "integer",
                    "description": "How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node\n"
                },
                "clusterRoutingAllocationNodeConcurrentOutgoingRecoveries": {
                    "type": "integer",
                    "description": "How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node\n"
                },
                "clusterRoutingAllocationNodeConcurrentRecoveries": {
                    "type": "integer",
                    "description": "A shortcut to set both incoming and outgoing recoveries\n"
                },
                "clusterRoutingAllocationNodeInitialPrimariesRecoveries": {
                    "type": "integer",
                    "description": "Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)\n"
                },
                "clusterRoutingAllocationSameShardHost": {
                    "type": "boolean",
                    "description": "Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host\n"
                },
                "clusterRoutingAllocationTotalShardsPerNode": {
                    "type": "integer",
                    "description": "Maximum number of primary and replica shards allocated to each node\n"
                },
                "clusterRoutingRebalanceEnable": {
                    "type": "string",
                    "description": "Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)\n"
                },
                "indicesBreakerFielddataLimit": {
                    "type": "string",
                    "description": "The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned\n"
                },
                "indicesBreakerFielddataOverhead": {
                    "type": "number",
                    "description": "A constant that all field data estimations are multiplied by\n"
                },
                "indicesBreakerRequestLimit": {
                    "type": "string",
                    "description": "The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding\n"
                },
                "indicesBreakerRequestOverhead": {
                    "type": "number",
                    "description": "A constant that all request estimations are multiplied by\n"
                },
                "indicesBreakerTotalLimit": {
                    "type": "string",
                    "description": "The percentage of total amount of memory that can be used across all breakers\n"
                },
                "indicesRecoveryMaxBytesPerSec": {
                    "type": "string",
                    "description": "Maximum total inbound and outbound recovery traffic for each node, in mb\n"
                },
                "networkBreakerInflightRequestsLimit": {
                    "type": "string",
                    "description": "The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level\n"
                },
                "networkBreakerInflightRequestsOverhead": {
                    "type": "number",
                    "description": "A constant that all in flight requests estimations are multiplied by\n"
                },
                "scriptMaxCompilationsRate": {
                    "type": "string",
                    "description": "Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string\n"
                },
                "searchDefaultSearchTimeout": {
                    "type": "string",
                    "description": "A time string setting a cluster-wide default timeout for all search requests\n"
                }
            },
            "inputProperties": {
                "actionAutoCreateIndex": {
                    "type": "string",
                    "description": "Whether to automatically create an index if it doesnt already exist and apply any configured index template\n"
                },
                "actionDestructiveRequiresName": {
                    "type": "boolean",
                    "description": "When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards\n"
                },
                "clusterBlocksReadOnly": {
                    "type": "boolean",
                    "description": "Make the whole cluster read only and metadata is not allowed to be modified\n"
                },
                "clusterBlocksReadOnlyAllowDelete": {
                    "type": "boolean",
                    "description": "Make the whole cluster read only, but allows to delete indices to free up resources\n"
                },
                "clusterIndicesCloseEnable": {
                    "type": "boolean",
                    "description": "If false, you cannot close open indices\n"
                },
                "clusterInfoUpdateInterval": {
                    "type": "string",
                    "description": "A time string controlling how often OpenSearch should check on disk usage for each node in the cluster\n"
                },
                "clusterMaxShardsPerNode": {
                    "type": "integer",
                    "description": "The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit\n"
                },
                "clusterMaxShardsPerNodeFrozen": {
                    "type": "integer",
                    "description": "The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.\n"
                },
                "clusterNoMasterBlock": {
                    "type": "string",
                    "description": "Specifies which operations are rejected when there is no active master in a cluster (all, write)\n"
                },
                "clusterPersistentTasksAllocationEnable": {
                    "type": "string",
                    "description": "Whether allocation for persistent tasks is active (all, none)\n"
                },
                "clusterPersistentTasksAllocationRecheckInterval": {
                    "type": "string",
                    "description": "A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes\n"
                },
                "clusterRoutingAllocationAllowRebalance": {
                    "type": "string",
                    "description": "Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)\n"
                },
                "clusterRoutingAllocationAwarenessAttributes": {
                    "type": "string",
                    "description": "Use custom node attributes to take hardware configuration into account when allocating shards\n"
                },
                "clusterRoutingAllocationBalanceIndex": {
                    "type": "number",
                    "description": "Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes\n"
                },
                "clusterRoutingAllocationBalanceShard": {
                    "type": "number",
                    "description": "Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes\n"
                },
                "clusterRoutingAllocationBalanceThreshold": {
                    "type": "number",
                    "description": "Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance\n"
                },
                "clusterRoutingAllocationClusterConcurrentRebalance": {
                    "type": "integer",
                    "description": "How many concurrent shard rebalances are allowed cluster wide\n"
                },
                "clusterRoutingAllocationDiskIncludeRelocations": {
                    "type": "boolean",
                    "description": "Whether the allocator will take into account shards that are currently being relocated to the target node when computing a nodes disk usage\n"
                },
                "clusterRoutingAllocationDiskThresholdEnabled": {
                    "type": "boolean",
                    "description": "Whether the disk allocation decider is active\n"
                },
                "clusterRoutingAllocationDiskWatermarkHigh": {
                    "type": "string",
                    "description": "Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used\n"
                },
                "clusterRoutingAllocationDiskWatermarkLow": {
                    "type": "string",
                    "description": "Allocator will not allocate shards to nodes that have more than this percentage disk used\n"
                },
                "clusterRoutingAllocationEnable": {
                    "type": "string",
                    "description": "Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)\n"
                },
                "clusterRoutingAllocationNodeConcurrentIncomingRecoveries": {
                    "type": "integer",
                    "description": "How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node\n"
                },
                "clusterRoutingAllocationNodeConcurrentOutgoingRecoveries": {
                    "type": "integer",
                    "description": "How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node\n"
                },
                "clusterRoutingAllocationNodeConcurrentRecoveries": {
                    "type": "integer",
                    "description": "A shortcut to set both incoming and outgoing recoveries\n"
                },
                "clusterRoutingAllocationNodeInitialPrimariesRecoveries": {
                    "type": "integer",
                    "description": "Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)\n"
                },
                "clusterRoutingAllocationSameShardHost": {
                    "type": "boolean",
                    "description": "Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host\n"
                },
                "clusterRoutingAllocationTotalShardsPerNode": {
                    "type": "integer",
                    "description": "Maximum number of primary and replica shards allocated to each node\n"
                },
                "clusterRoutingRebalanceEnable": {
                    "type": "string",
                    "description": "Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)\n"
                },
                "indicesBreakerFielddataLimit": {
                    "type": "string",
                    "description": "The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned\n"
                },
                "indicesBreakerFielddataOverhead": {
                    "type": "number",
                    "description": "A constant that all field data estimations are multiplied by\n"
                },
                "indicesBreakerRequestLimit": {
                    "type": "string",
                    "description": "The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding\n"
                },
                "indicesBreakerRequestOverhead": {
                    "type": "number",
                    "description": "A constant that all request estimations are multiplied by\n"
                },
                "indicesBreakerTotalLimit": {
                    "type": "string",
                    "description": "The percentage of total amount of memory that can be used across all breakers\n"
                },
                "indicesRecoveryMaxBytesPerSec": {
                    "type": "string",
                    "description": "Maximum total inbound and outbound recovery traffic for each node, in mb\n"
                },
                "networkBreakerInflightRequestsLimit": {
                    "type": "string",
                    "description": "The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level\n"
                },
                "networkBreakerInflightRequestsOverhead": {
                    "type": "number",
                    "description": "A constant that all in flight requests estimations are multiplied by\n"
                },
                "scriptMaxCompilationsRate": {
                    "type": "string",
                    "description": "Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string\n"
                },
                "searchDefaultSearchTimeout": {
                    "type": "string",
                    "description": "A time string setting a cluster-wide default timeout for all search requests\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClusterSettings resources.\n",
                "properties": {
                    "actionAutoCreateIndex": {
                        "type": "string",
                        "description": "Whether to automatically create an index if it doesnt already exist and apply any configured index template\n"
                    },
                    "actionDestructiveRequiresName": {
                        "type": "boolean",
                        "description": "When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards\n"
                    },
                    "clusterBlocksReadOnly": {
                        "type": "boolean",
                        "description": "Make the whole cluster read only and metadata is not allowed to be modified\n"
                    },
                    "clusterBlocksReadOnlyAllowDelete": {
                        "type": "boolean",
                        "description": "Make the whole cluster read only, but allows to delete indices to free up resources\n"
                    },
                    "clusterIndicesCloseEnable": {
                        "type": "boolean",
                        "description": "If false, you cannot close open indices\n"
                    },
                    "clusterInfoUpdateInterval": {
                        "type": "string",
                        "description": "A time string controlling how often OpenSearch should check on disk usage for each node in the cluster\n"
                    },
                    "clusterMaxShardsPerNode": {
                        "type": "integer",
                        "description": "The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit\n"
                    },
                    "clusterMaxShardsPerNodeFrozen": {
                        "type": "integer",
                        "description": "The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.\n"
                    },
                    "clusterNoMasterBlock": {
                        "type": "string",
                        "description": "Specifies which operations are rejected when there is no active master in a cluster (all, write)\n"
                    },
                    "clusterPersistentTasksAllocationEnable": {
                        "type": "string",
                        "description": "Whether allocation for persistent tasks is active (all, none)\n"
                    },
                    "clusterPersistentTasksAllocationRecheckInterval": {
                        "type": "string",
                        "description": "A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes\n"
                    },
                    "clusterRoutingAllocationAllowRebalance": {
                        "type": "string",
                        "description": "Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)\n"
                    },
                    "clusterRoutingAllocationAwarenessAttributes": {
                        "type": "string",
                        "description": "Use custom node attributes to take hardware configuration into account when allocating shards\n"
                    },
                    "clusterRoutingAllocationBalanceIndex": {
                        "type": "number",
                        "description": "Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes\n"
                    },
                    "clusterRoutingAllocationBalanceShard": {
                        "type": "number",
                        "description": "Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes\n"
                    },
                    "clusterRoutingAllocationBalanceThreshold": {
                        "type": "number",
                        "description": "Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance\n"
                    },
                    "clusterRoutingAllocationClusterConcurrentRebalance": {
                        "type": "integer",
                        "description": "How many concurrent shard rebalances are allowed cluster wide\n"
                    },
                    "clusterRoutingAllocationDiskIncludeRelocations": {
                        "type": "boolean",
                        "description": "Whether the allocator will take into account shards that are currently being relocated to the target node when computing a nodes disk usage\n"
                    },
                    "clusterRoutingAllocationDiskThresholdEnabled": {
                        "type": "boolean",
                        "description": "Whether the disk allocation decider is active\n"
                    },
                    "clusterRoutingAllocationDiskWatermarkHigh": {
                        "type": "string",
                        "description": "Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used\n"
                    },
                    "clusterRoutingAllocationDiskWatermarkLow": {
                        "type": "string",
                        "description": "Allocator will not allocate shards to nodes that have more than this percentage disk used\n"
                    },
                    "clusterRoutingAllocationEnable": {
                        "type": "string",
                        "description": "Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)\n"
                    },
                    "clusterRoutingAllocationNodeConcurrentIncomingRecoveries": {
                        "type": "integer",
                        "description": "How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node\n"
                    },
                    "clusterRoutingAllocationNodeConcurrentOutgoingRecoveries": {
                        "type": "integer",
                        "description": "How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node\n"
                    },
                    "clusterRoutingAllocationNodeConcurrentRecoveries": {
                        "type": "integer",
                        "description": "A shortcut to set both incoming and outgoing recoveries\n"
                    },
                    "clusterRoutingAllocationNodeInitialPrimariesRecoveries": {
                        "type": "integer",
                        "description": "Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)\n"
                    },
                    "clusterRoutingAllocationSameShardHost": {
                        "type": "boolean",
                        "description": "Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host\n"
                    },
                    "clusterRoutingAllocationTotalShardsPerNode": {
                        "type": "integer",
                        "description": "Maximum number of primary and replica shards allocated to each node\n"
                    },
                    "clusterRoutingRebalanceEnable": {
                        "type": "string",
                        "description": "Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)\n"
                    },
                    "indicesBreakerFielddataLimit": {
                        "type": "string",
                        "description": "The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned\n"
                    },
                    "indicesBreakerFielddataOverhead": {
                        "type": "number",
                        "description": "A constant that all field data estimations are multiplied by\n"
                    },
                    "indicesBreakerRequestLimit": {
                        "type": "string",
                        "description": "The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding\n"
                    },
                    "indicesBreakerRequestOverhead": {
                        "type": "number",
                        "description": "A constant that all request estimations are multiplied by\n"
                    },
                    "indicesBreakerTotalLimit": {
                        "type": "string",
                        "description": "The percentage of total amount of memory that can be used across all breakers\n"
                    },
                    "indicesRecoveryMaxBytesPerSec": {
                        "type": "string",
                        "description": "Maximum total inbound and outbound recovery traffic for each node, in mb\n"
                    },
                    "networkBreakerInflightRequestsLimit": {
                        "type": "string",
                        "description": "The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level\n"
                    },
                    "networkBreakerInflightRequestsOverhead": {
                        "type": "number",
                        "description": "A constant that all in flight requests estimations are multiplied by\n"
                    },
                    "scriptMaxCompilationsRate": {
                        "type": "string",
                        "description": "Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string\n"
                    },
                    "searchDefaultSearchTimeout": {
                        "type": "string",
                        "description": "A time string setting a cluster-wide default timeout for all search requests\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/componentTemplate:ComponentTemplate": {
            "description": "Component templates are building blocks for constructing index templates that specify index mappings, settings, and aliases. You cannot directly apply a component template to a data stream or index. To be applied, a component template must be included in an index templates `composed_of` list.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\nconst test = new opensearch.ComponentTemplate(\"test\", {body: `{\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": \"1\"\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  }\n}\n\n`});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\ntest = opensearch.ComponentTemplate(\"test\", body=\"\"\"{\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": \"1\"\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  }\n}\n\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Opensearch.ComponentTemplate(\"test\", new()\n    {\n        Body = @\"{\n  \"\"template\"\": {\n    \"\"settings\"\": {\n      \"\"index\"\": {\n        \"\"number_of_shards\"\": \"\"1\"\"\n      }\n    },\n    \"\"mappings\"\": {\n      \"\"properties\"\": {\n        \"\"host_name\"\": {\n          \"\"type\"\": \"\"keyword\"\"\n        },\n        \"\"created_at\"\": {\n          \"\"type\"\": \"\"date\"\",\n          \"\"format\"\": \"\"EEE MMM dd HH:mm:ss Z yyyy\"\"\n        }\n      }\n    },\n    \"\"aliases\"\": {\n      \"\"mydata\"\": { }\n    }\n  }\n}\n\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewComponentTemplate(ctx, \"test\", \u0026opensearch.ComponentTemplateArgs{\n\t\t\tBody: pulumi.String(`{\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": \"1\"\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  }\n}\n\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.ComponentTemplate;\nimport com.pulumi.opensearch.ComponentTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ComponentTemplate(\"test\", ComponentTemplateArgs.builder()        \n            .body(\"\"\"\n{\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": \"1\"\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  }\n}\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: opensearch:ComponentTemplate\n    properties:\n      body: |+\n        {\n          \"template\": {\n            \"settings\": {\n              \"index\": {\n                \"number_of_shards\": \"1\"\n              }\n            },\n            \"mappings\": {\n              \"properties\": {\n                \"host_name\": {\n                  \"type\": \"keyword\"\n                },\n                \"created_at\": {\n                  \"type\": \"date\",\n                  \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n                }\n              }\n            },\n            \"aliases\": {\n              \"mydata\": { }\n            }\n          }\n        }\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport by name\n\n```sh\n $ pulumi import opensearch:index/componentTemplate:ComponentTemplate test terraform-test\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the component template to create.\n"
                }
            },
            "required": [
                "body",
                "name"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the component template to create.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComponentTemplate resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The JSON body of the template.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the component template to create.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/composableIndexTemplate:ComposableIndexTemplate": {
            "description": "Provides an Composable index template resource. This resource uses the `/_index_template` endpoint of the API that is available since version 2.0.0. Use `opensearch.IndexTemplate` if you are using older versions or if you want to keep using legacy Index Templates.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\nconst template1 = new opensearch.ComposableIndexTemplate(\"template1\", {body: `{\n  \"index_patterns\": [\"te*\", \"bar*\"],\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": \"1\"\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  },\n  \"priority\": 200,\n  \"version\": 3\n}\n\n`});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\ntemplate1 = opensearch.ComposableIndexTemplate(\"template1\", body=\"\"\"{\n  \"index_patterns\": [\"te*\", \"bar*\"],\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": \"1\"\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  },\n  \"priority\": 200,\n  \"version\": 3\n}\n\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var template1 = new Opensearch.ComposableIndexTemplate(\"template1\", new()\n    {\n        Body = @\"{\n  \"\"index_patterns\"\": [\"\"te*\"\", \"\"bar*\"\"],\n  \"\"template\"\": {\n    \"\"settings\"\": {\n      \"\"index\"\": {\n        \"\"number_of_shards\"\": \"\"1\"\"\n      }\n    },\n    \"\"mappings\"\": {\n      \"\"properties\"\": {\n        \"\"host_name\"\": {\n          \"\"type\"\": \"\"keyword\"\"\n        },\n        \"\"created_at\"\": {\n          \"\"type\"\": \"\"date\"\",\n          \"\"format\"\": \"\"EEE MMM dd HH:mm:ss Z yyyy\"\"\n        }\n      }\n    },\n    \"\"aliases\"\": {\n      \"\"mydata\"\": { }\n    }\n  },\n  \"\"priority\"\": 200,\n  \"\"version\"\": 3\n}\n\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewComposableIndexTemplate(ctx, \"template1\", \u0026opensearch.ComposableIndexTemplateArgs{\n\t\t\tBody: pulumi.String(`{\n  \"index_patterns\": [\"te*\", \"bar*\"],\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": \"1\"\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  },\n  \"priority\": 200,\n  \"version\": 3\n}\n\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.ComposableIndexTemplate;\nimport com.pulumi.opensearch.ComposableIndexTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var template1 = new ComposableIndexTemplate(\"template1\", ComposableIndexTemplateArgs.builder()        \n            .body(\"\"\"\n{\n  \"index_patterns\": [\"te*\", \"bar*\"],\n  \"template\": {\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": \"1\"\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"host_name\": {\n          \"type\": \"keyword\"\n        },\n        \"created_at\": {\n          \"type\": \"date\",\n          \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n        }\n      }\n    },\n    \"aliases\": {\n      \"mydata\": { }\n    }\n  },\n  \"priority\": 200,\n  \"version\": 3\n}\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  template1:\n    type: opensearch:ComposableIndexTemplate\n    properties:\n      body: |+\n        {\n          \"index_patterns\": [\"te*\", \"bar*\"],\n          \"template\": {\n            \"settings\": {\n              \"index\": {\n                \"number_of_shards\": \"1\"\n              }\n            },\n            \"mappings\": {\n              \"properties\": {\n                \"host_name\": {\n                  \"type\": \"keyword\"\n                },\n                \"created_at\": {\n                  \"type\": \"date\",\n                  \"format\": \"EEE MMM dd HH:mm:ss Z yyyy\"\n                }\n              }\n            },\n            \"aliases\": {\n              \"mydata\": { }\n            }\n          },\n          \"priority\": 200,\n          \"version\": 3\n        }\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/composableIndexTemplate:ComposableIndexTemplate template_1 template_1\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the index template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the index template.\n"
                }
            },
            "required": [
                "body",
                "name"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the index template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the index template.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComposableIndexTemplate resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The JSON body of the index template.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the index template.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/dashboardObject:DashboardObject": {
            "description": "Provides an OpenSearch Dashboards object resource. This resource interacts directly with the underlying OpenSearch index backing Dashboards, so the format must match what Dashboards the version of Dashboards is expecting. Dashboards with older versions - directly pulling the JSON from a Dashboards index of the same version of OpenSearch targeted by the provider is a workaround.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\nconst testVisualizationV6 = new opensearch.DashboardObject(\"testVisualizationV6\", {body: `[\n  {\n    \"_id\": \"visualization:response-time-percentile\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\\\"title\\\\\":\\\\\"Total response time percentiles\\\\\",\\\\\"type\\\\\":\\\\\"line\\\\\",\\\\\"params\\\\\":{\\\\\"addTooltip\\\\\":true,\\\\\"addLegend\\\\\":true,\\\\\"legendPosition\\\\\":\\\\\"right\\\\\",\\\\\"showCircles\\\\\":true,\\\\\"interpolate\\\\\":\\\\\"linear\\\\\",\\\\\"scale\\\\\":\\\\\"linear\\\\\",\\\\\"drawLinesBetweenPoints\\\\\":true,\\\\\"radiusRatio\\\\\":9,\\\\\"times\\\\\":[],\\\\\"addTimeMarker\\\\\":false,\\\\\"defaultYExtents\\\\\":false,\\\\\"setYExtents\\\\\":false},\\\\\"aggs\\\\\":[{\\\\\"id\\\\\":\\\\\"1\\\\\",\\\\\"enabled\\\\\":true,\\\\\"type\\\\\":\\\\\"percentiles\\\\\",\\\\\"schema\\\\\":\\\\\"metric\\\\\",\\\\\"params\\\\\":{\\\\\"field\\\\\":\\\\\"app.total_time\\\\\",\\\\\"percents\\\\\":[50,90,95]}},{\\\\\"id\\\\\":\\\\\"2\\\\\",\\\\\"enabled\\\\\":true,\\\\\"type\\\\\":\\\\\"date_histogram\\\\\",\\\\\"schema\\\\\":\\\\\"segment\\\\\",\\\\\"params\\\\\":{\\\\\"field\\\\\":\\\\\"@timestamp\\\\\",\\\\\"interval\\\\\":\\\\\"auto\\\\\",\\\\\"customInterval\\\\\":\\\\\"2h\\\\\",\\\\\"min_doc_count\\\\\":1,\\\\\"extended_bounds\\\\\":{}}},{\\\\\"id\\\\\":\\\\\"3\\\\\",\\\\\"enabled\\\\\":true,\\\\\"type\\\\\":\\\\\"terms\\\\\",\\\\\"schema\\\\\":\\\\\"group\\\\\",\\\\\"params\\\\\":{\\\\\"field\\\\\":\\\\\"system.syslog.program\\\\\",\\\\\"size\\\\\":5,\\\\\"order\\\\\":\\\\\"desc\\\\\",\\\\\"orderBy\\\\\":\\\\\"_term\\\\\"}}],\\\\\"listeners\\\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n\n`});\nconst testVisualizationV7 = new opensearch.DashboardObject(\"testVisualizationV7\", {body: `[\n  {\n    \"_id\": \"response-time-percentile\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\\\"title\\\\\":\\\\\"Total response time percentiles\\\\\",\\\\\"type\\\\\":\\\\\"line\\\\\",\\\\\"params\\\\\":{\\\\\"addTooltip\\\\\":true,\\\\\"addLegend\\\\\":true,\\\\\"legendPosition\\\\\":\\\\\"right\\\\\",\\\\\"showCircles\\\\\":true,\\\\\"interpolate\\\\\":\\\\\"linear\\\\\",\\\\\"scale\\\\\":\\\\\"linear\\\\\",\\\\\"drawLinesBetweenPoints\\\\\":true,\\\\\"radiusRatio\\\\\":9,\\\\\"times\\\\\":[],\\\\\"addTimeMarker\\\\\":false,\\\\\"defaultYExtents\\\\\":false,\\\\\"setYExtents\\\\\":false},\\\\\"aggs\\\\\":[{\\\\\"id\\\\\":\\\\\"1\\\\\",\\\\\"enabled\\\\\":true,\\\\\"type\\\\\":\\\\\"percentiles\\\\\",\\\\\"schema\\\\\":\\\\\"metric\\\\\",\\\\\"params\\\\\":{\\\\\"field\\\\\":\\\\\"app.total_time\\\\\",\\\\\"percents\\\\\":[50,90,95]}},{\\\\\"id\\\\\":\\\\\"2\\\\\",\\\\\"enabled\\\\\":true,\\\\\"type\\\\\":\\\\\"date_histogram\\\\\",\\\\\"schema\\\\\":\\\\\"segment\\\\\",\\\\\"params\\\\\":{\\\\\"field\\\\\":\\\\\"@timestamp\\\\\",\\\\\"interval\\\\\":\\\\\"auto\\\\\",\\\\\"customInterval\\\\\":\\\\\"2h\\\\\",\\\\\"min_doc_count\\\\\":1,\\\\\"extended_bounds\\\\\":{}}},{\\\\\"id\\\\\":\\\\\"3\\\\\",\\\\\"enabled\\\\\":true,\\\\\"type\\\\\":\\\\\"terms\\\\\",\\\\\"schema\\\\\":\\\\\"group\\\\\",\\\\\"params\\\\\":{\\\\\"field\\\\\":\\\\\"system.syslog.program\\\\\",\\\\\"size\\\\\":5,\\\\\"order\\\\\":\\\\\"desc\\\\\",\\\\\"orderBy\\\\\":\\\\\"_term\\\\\"}}],\\\\\"listeners\\\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n\n`});\nconst testIndexPatternV6 = new opensearch.DashboardObject(\"testIndexPatternV6\", {body: `[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n\n`});\nconst testIndexPatternV7 = new opensearch.DashboardObject(\"testIndexPatternV7\", {body: `[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n\n`});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\ntest_visualization_v6 = opensearch.DashboardObject(\"testVisualizationV6\", body=\"\"\"[\n  {\n    \"_id\": \"visualization:response-time-percentile\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n\n\"\"\")\ntest_visualization_v7 = opensearch.DashboardObject(\"testVisualizationV7\", body=\"\"\"[\n  {\n    \"_id\": \"response-time-percentile\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n\n\"\"\")\ntest_index_pattern_v6 = opensearch.DashboardObject(\"testIndexPatternV6\", body=\"\"\"[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n\n\"\"\")\ntest_index_pattern_v7 = opensearch.DashboardObject(\"testIndexPatternV7\", body=\"\"\"[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testVisualizationV6 = new Opensearch.DashboardObject(\"testVisualizationV6\", new()\n    {\n        Body = @\"[\n  {\n    \"\"_id\"\": \"\"visualization:response-time-percentile\"\",\n    \"\"_type\"\": \"\"doc\"\",\n    \"\"_source\"\": {\n      \"\"type\"\": \"\"visualization\"\",\n      \"\"visualization\"\": {\n        \"\"title\"\": \"\"Total response time percentiles\"\",\n        \"\"visState\"\": \"\"{\\\"\"title\\\"\":\\\"\"Total response time percentiles\\\"\",\\\"\"type\\\"\":\\\"\"line\\\"\",\\\"\"params\\\"\":{\\\"\"addTooltip\\\"\":true,\\\"\"addLegend\\\"\":true,\\\"\"legendPosition\\\"\":\\\"\"right\\\"\",\\\"\"showCircles\\\"\":true,\\\"\"interpolate\\\"\":\\\"\"linear\\\"\",\\\"\"scale\\\"\":\\\"\"linear\\\"\",\\\"\"drawLinesBetweenPoints\\\"\":true,\\\"\"radiusRatio\\\"\":9,\\\"\"times\\\"\":[],\\\"\"addTimeMarker\\\"\":false,\\\"\"defaultYExtents\\\"\":false,\\\"\"setYExtents\\\"\":false},\\\"\"aggs\\\"\":[{\\\"\"id\\\"\":\\\"\"1\\\"\",\\\"\"enabled\\\"\":true,\\\"\"type\\\"\":\\\"\"percentiles\\\"\",\\\"\"schema\\\"\":\\\"\"metric\\\"\",\\\"\"params\\\"\":{\\\"\"field\\\"\":\\\"\"app.total_time\\\"\",\\\"\"percents\\\"\":[50,90,95]}},{\\\"\"id\\\"\":\\\"\"2\\\"\",\\\"\"enabled\\\"\":true,\\\"\"type\\\"\":\\\"\"date_histogram\\\"\",\\\"\"schema\\\"\":\\\"\"segment\\\"\",\\\"\"params\\\"\":{\\\"\"field\\\"\":\\\"\"@timestamp\\\"\",\\\"\"interval\\\"\":\\\"\"auto\\\"\",\\\"\"customInterval\\\"\":\\\"\"2h\\\"\",\\\"\"min_doc_count\\\"\":1,\\\"\"extended_bounds\\\"\":{}}},{\\\"\"id\\\"\":\\\"\"3\\\"\",\\\"\"enabled\\\"\":true,\\\"\"type\\\"\":\\\"\"terms\\\"\",\\\"\"schema\\\"\":\\\"\"group\\\"\",\\\"\"params\\\"\":{\\\"\"field\\\"\":\\\"\"system.syslog.program\\\"\",\\\"\"size\\\"\":5,\\\"\"order\\\"\":\\\"\"desc\\\"\",\\\"\"orderBy\\\"\":\\\"\"_term\\\"\"}}],\\\"\"listeners\\\"\":{}}\"\",\n        \"\"uiStateJSON\"\": \"\"{}\"\",\n        \"\"description\"\": \"\"\"\",\n        \"\"version\"\": 1\n      }\n    }\n  }\n]\n\n\",\n    });\n\n    var testVisualizationV7 = new Opensearch.DashboardObject(\"testVisualizationV7\", new()\n    {\n        Body = @\"[\n  {\n    \"\"_id\"\": \"\"response-time-percentile\"\",\n    \"\"_source\"\": {\n      \"\"type\"\": \"\"visualization\"\",\n      \"\"visualization\"\": {\n        \"\"title\"\": \"\"Total response time percentiles\"\",\n        \"\"visState\"\": \"\"{\\\"\"title\\\"\":\\\"\"Total response time percentiles\\\"\",\\\"\"type\\\"\":\\\"\"line\\\"\",\\\"\"params\\\"\":{\\\"\"addTooltip\\\"\":true,\\\"\"addLegend\\\"\":true,\\\"\"legendPosition\\\"\":\\\"\"right\\\"\",\\\"\"showCircles\\\"\":true,\\\"\"interpolate\\\"\":\\\"\"linear\\\"\",\\\"\"scale\\\"\":\\\"\"linear\\\"\",\\\"\"drawLinesBetweenPoints\\\"\":true,\\\"\"radiusRatio\\\"\":9,\\\"\"times\\\"\":[],\\\"\"addTimeMarker\\\"\":false,\\\"\"defaultYExtents\\\"\":false,\\\"\"setYExtents\\\"\":false},\\\"\"aggs\\\"\":[{\\\"\"id\\\"\":\\\"\"1\\\"\",\\\"\"enabled\\\"\":true,\\\"\"type\\\"\":\\\"\"percentiles\\\"\",\\\"\"schema\\\"\":\\\"\"metric\\\"\",\\\"\"params\\\"\":{\\\"\"field\\\"\":\\\"\"app.total_time\\\"\",\\\"\"percents\\\"\":[50,90,95]}},{\\\"\"id\\\"\":\\\"\"2\\\"\",\\\"\"enabled\\\"\":true,\\\"\"type\\\"\":\\\"\"date_histogram\\\"\",\\\"\"schema\\\"\":\\\"\"segment\\\"\",\\\"\"params\\\"\":{\\\"\"field\\\"\":\\\"\"@timestamp\\\"\",\\\"\"interval\\\"\":\\\"\"auto\\\"\",\\\"\"customInterval\\\"\":\\\"\"2h\\\"\",\\\"\"min_doc_count\\\"\":1,\\\"\"extended_bounds\\\"\":{}}},{\\\"\"id\\\"\":\\\"\"3\\\"\",\\\"\"enabled\\\"\":true,\\\"\"type\\\"\":\\\"\"terms\\\"\",\\\"\"schema\\\"\":\\\"\"group\\\"\",\\\"\"params\\\"\":{\\\"\"field\\\"\":\\\"\"system.syslog.program\\\"\",\\\"\"size\\\"\":5,\\\"\"order\\\"\":\\\"\"desc\\\"\",\\\"\"orderBy\\\"\":\\\"\"_term\\\"\"}}],\\\"\"listeners\\\"\":{}}\"\",\n        \"\"uiStateJSON\"\": \"\"{}\"\",\n        \"\"description\"\": \"\"\"\",\n        \"\"version\"\": 1\n      }\n    }\n  }\n]\n\n\",\n    });\n\n    var testIndexPatternV6 = new Opensearch.DashboardObject(\"testIndexPatternV6\", new()\n    {\n        Body = @\"[\n  {\n    \"\"_id\"\": \"\"index-pattern:cloudwatch\"\",\n    \"\"_type\"\": \"\"doc\"\",\n    \"\"_source\"\": {\n      \"\"type\"\": \"\"index-pattern\"\",\n      \"\"index-pattern\"\": {\n        \"\"title\"\": \"\"cloudwatch-*\"\",\n        \"\"timeFieldName\"\": \"\"timestamp\"\"\n      }\n    }\n  }\n]\n\n\",\n    });\n\n    var testIndexPatternV7 = new Opensearch.DashboardObject(\"testIndexPatternV7\", new()\n    {\n        Body = @\"[\n  {\n    \"\"_id\"\": \"\"index-pattern:cloudwatch\"\",\n    \"\"_type\"\": \"\"doc\"\",\n    \"\"_source\"\": {\n      \"\"type\"\": \"\"index-pattern\"\",\n      \"\"index-pattern\"\": {\n        \"\"title\"\": \"\"cloudwatch-*\"\",\n        \"\"timeFieldName\"\": \"\"timestamp\"\"\n      }\n    }\n  }\n]\n\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewDashboardObject(ctx, \"testVisualizationV6\", \u0026opensearch.DashboardObjectArgs{\n\t\t\tBody: pulumi.String(`[\n  {\n    \"_id\": \"visualization:response-time-percentile\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = opensearch.NewDashboardObject(ctx, \"testVisualizationV7\", \u0026opensearch.DashboardObjectArgs{\n\t\t\tBody: pulumi.String(`[\n  {\n    \"_id\": \"response-time-percentile\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = opensearch.NewDashboardObject(ctx, \"testIndexPatternV6\", \u0026opensearch.DashboardObjectArgs{\n\t\t\tBody: pulumi.String(`[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = opensearch.NewDashboardObject(ctx, \"testIndexPatternV7\", \u0026opensearch.DashboardObjectArgs{\n\t\t\tBody: pulumi.String(`[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.DashboardObject;\nimport com.pulumi.opensearch.DashboardObjectArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testVisualizationV6 = new DashboardObject(\"testVisualizationV6\", DashboardObjectArgs.builder()        \n            .body(\"\"\"\n[\n  {\n    \"_id\": \"visualization:response-time-percentile\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n\n            \"\"\")\n            .build());\n\n        var testVisualizationV7 = new DashboardObject(\"testVisualizationV7\", DashboardObjectArgs.builder()        \n            .body(\"\"\"\n[\n  {\n    \"_id\": \"response-time-percentile\",\n    \"_source\": {\n      \"type\": \"visualization\",\n      \"visualization\": {\n        \"title\": \"Total response time percentiles\",\n        \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n        \"uiStateJSON\": \"{}\",\n        \"description\": \"\",\n        \"version\": 1\n      }\n    }\n  }\n]\n\n            \"\"\")\n            .build());\n\n        var testIndexPatternV6 = new DashboardObject(\"testIndexPatternV6\", DashboardObjectArgs.builder()        \n            .body(\"\"\"\n[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n\n            \"\"\")\n            .build());\n\n        var testIndexPatternV7 = new DashboardObject(\"testIndexPatternV7\", DashboardObjectArgs.builder()        \n            .body(\"\"\"\n[\n  {\n    \"_id\": \"index-pattern:cloudwatch\",\n    \"_type\": \"doc\",\n    \"_source\": {\n      \"type\": \"index-pattern\",\n      \"index-pattern\": {\n        \"title\": \"cloudwatch-*\",\n        \"timeFieldName\": \"timestamp\"\n      }\n    }\n  }\n]\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testVisualizationV6:\n    type: opensearch:DashboardObject\n    properties:\n      body: |+\n        [\n          {\n            \"_id\": \"visualization:response-time-percentile\",\n            \"_type\": \"doc\",\n            \"_source\": {\n              \"type\": \"visualization\",\n              \"visualization\": {\n                \"title\": \"Total response time percentiles\",\n                \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n                \"uiStateJSON\": \"{}\",\n                \"description\": \"\",\n                \"version\": 1\n              }\n            }\n          }\n        ]\n\n  testVisualizationV7:\n    type: opensearch:DashboardObject\n    properties:\n      body: |+\n        [\n          {\n            \"_id\": \"response-time-percentile\",\n            \"_source\": {\n              \"type\": \"visualization\",\n              \"visualization\": {\n                \"title\": \"Total response time percentiles\",\n                \"visState\": \"{\\\"title\\\":\\\"Total response time percentiles\\\",\\\"type\\\":\\\"line\\\",\\\"params\\\":{\\\"addTooltip\\\":true,\\\"addLegend\\\":true,\\\"legendPosition\\\":\\\"right\\\",\\\"showCircles\\\":true,\\\"interpolate\\\":\\\"linear\\\",\\\"scale\\\":\\\"linear\\\",\\\"drawLinesBetweenPoints\\\":true,\\\"radiusRatio\\\":9,\\\"times\\\":[],\\\"addTimeMarker\\\":false,\\\"defaultYExtents\\\":false,\\\"setYExtents\\\":false},\\\"aggs\\\":[{\\\"id\\\":\\\"1\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"percentiles\\\",\\\"schema\\\":\\\"metric\\\",\\\"params\\\":{\\\"field\\\":\\\"app.total_time\\\",\\\"percents\\\":[50,90,95]}},{\\\"id\\\":\\\"2\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"date_histogram\\\",\\\"schema\\\":\\\"segment\\\",\\\"params\\\":{\\\"field\\\":\\\"@timestamp\\\",\\\"interval\\\":\\\"auto\\\",\\\"customInterval\\\":\\\"2h\\\",\\\"min_doc_count\\\":1,\\\"extended_bounds\\\":{}}},{\\\"id\\\":\\\"3\\\",\\\"enabled\\\":true,\\\"type\\\":\\\"terms\\\",\\\"schema\\\":\\\"group\\\",\\\"params\\\":{\\\"field\\\":\\\"system.syslog.program\\\",\\\"size\\\":5,\\\"order\\\":\\\"desc\\\",\\\"orderBy\\\":\\\"_term\\\"}}],\\\"listeners\\\":{}}\",\n                \"uiStateJSON\": \"{}\",\n                \"description\": \"\",\n                \"version\": 1\n              }\n            }\n          }\n        ]\n\n  testIndexPatternV6:\n    type: opensearch:DashboardObject\n    properties:\n      body: |+\n        [\n          {\n            \"_id\": \"index-pattern:cloudwatch\",\n            \"_type\": \"doc\",\n            \"_source\": {\n              \"type\": \"index-pattern\",\n              \"index-pattern\": {\n                \"title\": \"cloudwatch-*\",\n                \"timeFieldName\": \"timestamp\"\n              }\n            }\n          }\n        ]\n\n  testIndexPatternV7:\n    type: opensearch:DashboardObject\n    properties:\n      body: |+\n        [\n          {\n            \"_id\": \"index-pattern:cloudwatch\",\n            \"_type\": \"doc\",\n            \"_source\": {\n              \"type\": \"index-pattern\",\n              \"index-pattern\": {\n                \"title\": \"cloudwatch-*\",\n                \"timeFieldName\": \"timestamp\"\n              }\n            }\n          }\n        ]\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the dashboard object.\n"
                },
                "index": {
                    "type": "string",
                    "description": "The name of the index where dashboard data is stored.\n"
                }
            },
            "required": [
                "body"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the dashboard object.\n"
                },
                "index": {
                    "type": "string",
                    "description": "The name of the index where dashboard data is stored.\n"
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DashboardObject resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The JSON body of the dashboard object.\n"
                    },
                    "index": {
                        "type": "string",
                        "description": "The name of the index where dashboard data is stored.\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/dashboardTenant:DashboardTenant": {
            "description": "Provides an OpenSearch dashboard tenant resource. Please refer to the OpenSearch documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\n// Create a tenant\nconst test = new opensearch.DashboardTenant(\"test\", {\n    description: \"test tenant\",\n    tenantName: \"test\",\n});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\n# Create a tenant\ntest = opensearch.DashboardTenant(\"test\",\n    description=\"test tenant\",\n    tenant_name=\"test\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a tenant\n    var test = new Opensearch.DashboardTenant(\"test\", new()\n    {\n        Description = \"test tenant\",\n        TenantName = \"test\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewDashboardTenant(ctx, \"test\", \u0026opensearch.DashboardTenantArgs{\n\t\t\tDescription: pulumi.String(\"test tenant\"),\n\t\t\tTenantName:  pulumi.String(\"test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.DashboardTenant;\nimport com.pulumi.opensearch.DashboardTenantArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new DashboardTenant(\"test\", DashboardTenantArgs.builder()        \n            .description(\"test tenant\")\n            .tenantName(\"test\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a tenant\n  test:\n    type: opensearch:DashboardTenant\n    properties:\n      description: test tenant\n      tenantName: test\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/dashboardTenant:DashboardTenant writer test\n```\n\n ",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of the tenant.\n"
                },
                "index": {
                    "type": "string"
                },
                "tenantName": {
                    "type": "string",
                    "description": "The name of the tenant.\n"
                }
            },
            "required": [
                "index",
                "tenantName"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of the tenant.\n"
                },
                "tenantName": {
                    "type": "string",
                    "description": "The name of the tenant.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "tenantName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DashboardTenant resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the tenant.\n"
                    },
                    "index": {
                        "type": "string"
                    },
                    "tenantName": {
                        "type": "string",
                        "description": "The name of the tenant.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/dataStream:DataStream": {
            "description": "A data stream lets you store append-only time series data across multiple (hidden, auto-generated) indices while giving you a single named resource for requests\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\nconst fooComposableIndexTemplate = new opensearch.ComposableIndexTemplate(\"fooComposableIndexTemplate\", {body: `{\n  \"index_patterns\": [\"foo-data-stream*\"],\n  \"data_stream\": {}\n}\n`});\nconst fooDataStream = new opensearch.DataStream(\"fooDataStream\", {}, {\n    dependsOn: [fooComposableIndexTemplate],\n});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\nfoo_composable_index_template = opensearch.ComposableIndexTemplate(\"fooComposableIndexTemplate\", body=\"\"\"{\n  \"index_patterns\": [\"foo-data-stream*\"],\n  \"data_stream\": {}\n}\n\"\"\")\nfoo_data_stream = opensearch.DataStream(\"fooDataStream\", opts=pulumi.ResourceOptions(depends_on=[foo_composable_index_template]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var fooComposableIndexTemplate = new Opensearch.ComposableIndexTemplate(\"fooComposableIndexTemplate\", new()\n    {\n        Body = @\"{\n  \"\"index_patterns\"\": [\"\"foo-data-stream*\"\"],\n  \"\"data_stream\"\": {}\n}\n\",\n    });\n\n    var fooDataStream = new Opensearch.DataStream(\"fooDataStream\", new()\n    {\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            fooComposableIndexTemplate,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfooComposableIndexTemplate, err := opensearch.NewComposableIndexTemplate(ctx, \"fooComposableIndexTemplate\", \u0026opensearch.ComposableIndexTemplateArgs{\n\t\t\tBody: pulumi.String(\"{\\n  \\\"index_patterns\\\": [\\\"foo-data-stream*\\\"],\\n  \\\"data_stream\\\": {}\\n}\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = opensearch.NewDataStream(ctx, \"fooDataStream\", nil, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tfooComposableIndexTemplate,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.ComposableIndexTemplate;\nimport com.pulumi.opensearch.ComposableIndexTemplateArgs;\nimport com.pulumi.opensearch.DataStream;\nimport com.pulumi.opensearch.DataStreamArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var fooComposableIndexTemplate = new ComposableIndexTemplate(\"fooComposableIndexTemplate\", ComposableIndexTemplateArgs.builder()        \n            .body(\"\"\"\n{\n  \"index_patterns\": [\"foo-data-stream*\"],\n  \"data_stream\": {}\n}\n            \"\"\")\n            .build());\n\n        var fooDataStream = new DataStream(\"fooDataStream\", DataStreamArgs.Empty, CustomResourceOptions.builder()\n            .dependsOn(fooComposableIndexTemplate)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  fooComposableIndexTemplate:\n    type: opensearch:ComposableIndexTemplate\n    properties:\n      body: |\n        {\n          \"index_patterns\": [\"foo-data-stream*\"],\n          \"data_stream\": {}\n        }\n  fooDataStream:\n    type: opensearch:DataStream\n    options:\n      dependson:\n        - ${fooComposableIndexTemplate}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the data stream to create, must have a matching\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Name of the data stream to create, must have a matching\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DataStream resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the data stream to create, must have a matching\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/index:Index": {
            "description": "Provides an OpenSearch index resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\n// Create a simple index\nconst test_simple_index = new opensearch.Index(\"test-simple-index\", {\n    mappings: `{\n  \"properties\": {\n    \"name\": {\n      \"type\": \"text\"\n    }\n  }\n}\n\n`,\n    numberOfReplicas: \"1\",\n    numberOfShards: \"1\",\n});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\n# Create a simple index\ntest_simple_index = opensearch.Index(\"test-simple-index\",\n    mappings=\"\"\"{\n  \"properties\": {\n    \"name\": {\n      \"type\": \"text\"\n    }\n  }\n}\n\n\"\"\",\n    number_of_replicas=\"1\",\n    number_of_shards=\"1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a simple index\n    var test_simple_index = new Opensearch.Index(\"test-simple-index\", new()\n    {\n        Mappings = @\"{\n  \"\"properties\"\": {\n    \"\"name\"\": {\n      \"\"type\"\": \"\"text\"\"\n    }\n  }\n}\n\n\",\n        NumberOfReplicas = \"1\",\n        NumberOfShards = \"1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewIndex(ctx, \"test-simple-index\", \u0026opensearch.IndexArgs{\n\t\t\tMappings: pulumi.String(`{\n  \"properties\": {\n    \"name\": {\n      \"type\": \"text\"\n    }\n  }\n}\n\n`),\n\t\t\tNumberOfReplicas: pulumi.String(\"1\"),\n\t\t\tNumberOfShards:   pulumi.String(\"1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.Index;\nimport com.pulumi.opensearch.IndexArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test_simple_index = new Index(\"test-simple-index\", IndexArgs.builder()        \n            .mappings(\"\"\"\n{\n  \"properties\": {\n    \"name\": {\n      \"type\": \"text\"\n    }\n  }\n}\n\n            \"\"\")\n            .numberOfReplicas(\"1\")\n            .numberOfShards(\"1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a simple index\n  test-simple-index:\n    type: opensearch:Index\n    properties:\n      mappings: |+\n        {\n          \"properties\": {\n            \"name\": {\n              \"type\": \"text\"\n            }\n          }\n        }\n\n      numberOfReplicas: '1'\n      numberOfShards: '1'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport by name\n\n```sh\n $ pulumi import opensearch:index/index:Index test terraform-test\n```\n\n ",
            "properties": {
                "aliases": {
                    "type": "string",
                    "description": "A JSON string describing a set of aliases. The index aliases API allows aliasing an index with a name, with all APIs automatically converting the alias name to the actual index name. An alias can also be mapped to more than one index, and when specifying it, the alias will automatically expand to the aliased indices.\n"
                },
                "analysisAnalyzer": {
                    "type": "string",
                    "description": "A JSON string describing the analyzers applied to the index.\n"
                },
                "analysisCharFilter": {
                    "type": "string",
                    "description": "A JSON string describing the char_filters applied to the index.\n"
                },
                "analysisFilter": {
                    "type": "string",
                    "description": "A JSON string describing the filters applied to the index.\n"
                },
                "analysisNormalizer": {
                    "type": "string",
                    "description": "A JSON string describing the normalizers applied to the index.\n"
                },
                "analysisTokenizer": {
                    "type": "string",
                    "description": "A JSON string describing the tokenizers applied to the index.\n"
                },
                "analyzeMaxTokenCount": {
                    "type": "string",
                    "description": "The maximum number of tokens that can be produced using _analyze API. A stringified number.\n"
                },
                "autoExpandReplicas": {
                    "type": "string",
                    "description": "Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all)\n"
                },
                "blocksMetadata": {
                    "type": "boolean",
                    "description": "Set to `true` to disable index metadata reads and writes.\n"
                },
                "blocksRead": {
                    "type": "boolean",
                    "description": "Set to `true` to disable read operations against the index.\n"
                },
                "blocksReadOnly": {
                    "type": "boolean",
                    "description": "Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.\n"
                },
                "blocksReadOnlyAllowDelete": {
                    "type": "boolean",
                    "description": "Identical to `index.blocks.read_only` but allows deleting the index to free up resources.\n"
                },
                "blocksWrite": {
                    "type": "boolean",
                    "description": "Set to `true` to disable data write operations against the index. This setting does not affect metadata.\n"
                },
                "codec": {
                    "type": "string",
                    "description": "The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses DEFLATE for a higher compression ratio. This can be set only on creation.\n"
                },
                "defaultPipeline": {
                    "type": "string",
                    "description": "The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the pipeline does not exist.\n"
                },
                "forceDestroy": {
                    "type": "boolean",
                    "description": "A boolean that indicates that the index should be deleted even if it contains documents.\n"
                },
                "gcDeletes": {
                    "type": "string",
                    "description": "The length of time that a deleted document's version number remains available for further versioned operations.\n"
                },
                "highlightMaxAnalyzedOffset": {
                    "type": "string",
                    "description": "The maximum number of characters that will be analyzed for a highlight request. A stringified number.\n"
                },
                "includeTypeName": {
                    "type": "string",
                    "description": "A string that indicates if and what we should pass to include*type*name parameter. Set to `\"false\"` when trying to create an index on a v6 cluster without a doc type or set to `\"true\"` when trying to create an index on a v7 cluster with a doc type. Since mapping updates are not currently supported, this applies only on index create.\n"
                },
                "indexKnn": {
                    "type": "boolean",
                    "description": "Indicates whether the index should build native library indices for the knn*vector fields. If set to false, the knn*vector fields will be stored in doc values, but Approximate k-NN search functionality will be disabled.\n"
                },
                "indexKnnAlgoParamEfSearch": {
                    "type": "string",
                    "description": "The size of the dynamic list used during k-NN searches. Higher values lead to more accurate but slower searches. Only available for nmslib.\n"
                },
                "indexSimilarityDefault": {
                    "type": "string",
                    "description": "A JSON string describing the default index similarity config.\n"
                },
                "indexingSlowlogLevel": {
                    "type": "string",
                    "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                },
                "indexingSlowlogSource": {
                    "type": "string",
                    "description": "Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the source entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is reformatted by default to make sure that it fits on a single log line.\n"
                },
                "indexingSlowlogThresholdIndexDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`\n"
                },
                "indexingSlowlogThresholdIndexInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`\n"
                },
                "indexingSlowlogThresholdIndexTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`\n"
                },
                "indexingSlowlogThresholdIndexWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`\n"
                },
                "loadFixedBitsetFiltersEagerly": {
                    "type": "boolean",
                    "description": "Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.\n"
                },
                "mappings": {
                    "type": "string",
                    "description": "A JSON string defining how documents in the index, and the fields they contain, are stored and indexed. To avoid the complexities of field mapping updates, updates of this field are not allowed via this provider.\n"
                },
                "maxDocvalueFieldsSearch": {
                    "type": "string",
                    "description": "The maximum number of `docvalue_fields` that are allowed in a query. A stringified number.\n"
                },
                "maxInnerResultWindow": {
                    "type": "string",
                    "description": "The maximum value of `from + size` for inner hits definition and top hits aggregations to this index. A stringified number.\n"
                },
                "maxNgramDiff": {
                    "type": "string",
                    "description": "The maximum allowed difference between min*gram and max*gram for NGramTokenizer and NGramTokenFilter. A stringified number.\n"
                },
                "maxRefreshListeners": {
                    "type": "string",
                    "description": "Maximum number of refresh listeners available on each shard of the index. A stringified number.\n"
                },
                "maxRegexLength": {
                    "type": "string",
                    "description": "The maximum length of regex that can be used in Regexp Query. A stringified number.\n"
                },
                "maxRescoreWindow": {
                    "type": "string",
                    "description": "The maximum value of `window_size` for `rescore` requests in searches of this index. A stringified number.\n"
                },
                "maxResultWindow": {
                    "type": "string",
                    "description": "The maximum value of `from + size` for searches to this index. A stringified number.\n"
                },
                "maxScriptFields": {
                    "type": "string",
                    "description": "The maximum number of `script_fields` that are allowed in a query. A stringified number.\n"
                },
                "maxShingleDiff": {
                    "type": "string",
                    "description": "The maximum allowed difference between max*shingle*size and min*shingle*size for ShingleTokenFilter. A stringified number.\n"
                },
                "maxTermsCount": {
                    "type": "string",
                    "description": "The maximum number of terms that can be used in Terms Query. A stringified number.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index to create\n"
                },
                "numberOfReplicas": {
                    "type": "string",
                    "description": "Number of shard replicas. A stringified number.\n"
                },
                "numberOfRoutingShards": {
                    "type": "string",
                    "description": "Value used with number*of*shards to route documents to a primary shard. A stringified number. This can be set only on creation.\n"
                },
                "numberOfShards": {
                    "type": "string",
                    "description": "Number of shards for the index. This can be set only on creation.\n"
                },
                "refreshInterval": {
                    "type": "string",
                    "description": "How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1` to disable refresh.\n"
                },
                "rolloverAlias": {
                    "type": "string"
                },
                "routingAllocationEnable": {
                    "type": "string",
                    "description": "Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.\n"
                },
                "routingPartitionSize": {
                    "type": "string",
                    "description": "The number of shards a custom routing value can go to. A stringified number. This can be set only on creation.\n"
                },
                "routingRebalanceEnable": {
                    "type": "string",
                    "description": "Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.\n"
                },
                "searchIdleAfter": {
                    "type": "string",
                    "description": "How long a shard can not receive a search or get request until its considered search idle.\n"
                },
                "searchSlowlogLevel": {
                    "type": "string",
                    "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                },
                "searchSlowlogThresholdFetchDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`\n"
                },
                "searchSlowlogThresholdFetchInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`\n"
                },
                "searchSlowlogThresholdFetchTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`\n"
                },
                "searchSlowlogThresholdFetchWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`\n"
                },
                "searchSlowlogThresholdQueryDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`\n"
                },
                "searchSlowlogThresholdQueryInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`\n"
                },
                "searchSlowlogThresholdQueryTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`\n"
                },
                "searchSlowlogThresholdQueryWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`\n"
                },
                "shardCheckOnStartup": {
                    "type": "string",
                    "description": "Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the shard from being opened. Accepts `false`, `true`, `checksum`.\n"
                },
                "sortField": {
                    "type": "string",
                    "description": "The field to sort shards in this index by.\n"
                },
                "sortOrder": {
                    "type": "string",
                    "description": "The direction to sort shards in. Accepts `asc`, `desc`.\n"
                }
            },
            "required": [
                "name",
                "numberOfReplicas",
                "numberOfShards",
                "rolloverAlias"
            ],
            "inputProperties": {
                "aliases": {
                    "type": "string",
                    "description": "A JSON string describing a set of aliases. The index aliases API allows aliasing an index with a name, with all APIs automatically converting the alias name to the actual index name. An alias can also be mapped to more than one index, and when specifying it, the alias will automatically expand to the aliased indices.\n",
                    "willReplaceOnChanges": true
                },
                "analysisAnalyzer": {
                    "type": "string",
                    "description": "A JSON string describing the analyzers applied to the index.\n",
                    "willReplaceOnChanges": true
                },
                "analysisCharFilter": {
                    "type": "string",
                    "description": "A JSON string describing the char_filters applied to the index.\n",
                    "willReplaceOnChanges": true
                },
                "analysisFilter": {
                    "type": "string",
                    "description": "A JSON string describing the filters applied to the index.\n",
                    "willReplaceOnChanges": true
                },
                "analysisNormalizer": {
                    "type": "string",
                    "description": "A JSON string describing the normalizers applied to the index.\n",
                    "willReplaceOnChanges": true
                },
                "analysisTokenizer": {
                    "type": "string",
                    "description": "A JSON string describing the tokenizers applied to the index.\n",
                    "willReplaceOnChanges": true
                },
                "analyzeMaxTokenCount": {
                    "type": "string",
                    "description": "The maximum number of tokens that can be produced using _analyze API. A stringified number.\n"
                },
                "autoExpandReplicas": {
                    "type": "string",
                    "description": "Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all)\n"
                },
                "blocksMetadata": {
                    "type": "boolean",
                    "description": "Set to `true` to disable index metadata reads and writes.\n"
                },
                "blocksRead": {
                    "type": "boolean",
                    "description": "Set to `true` to disable read operations against the index.\n"
                },
                "blocksReadOnly": {
                    "type": "boolean",
                    "description": "Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.\n"
                },
                "blocksReadOnlyAllowDelete": {
                    "type": "boolean",
                    "description": "Identical to `index.blocks.read_only` but allows deleting the index to free up resources.\n"
                },
                "blocksWrite": {
                    "type": "boolean",
                    "description": "Set to `true` to disable data write operations against the index. This setting does not affect metadata.\n"
                },
                "codec": {
                    "type": "string",
                    "description": "The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses DEFLATE for a higher compression ratio. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "defaultPipeline": {
                    "type": "string",
                    "description": "The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the pipeline does not exist.\n"
                },
                "forceDestroy": {
                    "type": "boolean",
                    "description": "A boolean that indicates that the index should be deleted even if it contains documents.\n"
                },
                "gcDeletes": {
                    "type": "string",
                    "description": "The length of time that a deleted document's version number remains available for further versioned operations.\n"
                },
                "highlightMaxAnalyzedOffset": {
                    "type": "string",
                    "description": "The maximum number of characters that will be analyzed for a highlight request. A stringified number.\n"
                },
                "includeTypeName": {
                    "type": "string",
                    "description": "A string that indicates if and what we should pass to include*type*name parameter. Set to `\"false\"` when trying to create an index on a v6 cluster without a doc type or set to `\"true\"` when trying to create an index on a v7 cluster with a doc type. Since mapping updates are not currently supported, this applies only on index create.\n"
                },
                "indexKnn": {
                    "type": "boolean",
                    "description": "Indicates whether the index should build native library indices for the knn*vector fields. If set to false, the knn*vector fields will be stored in doc values, but Approximate k-NN search functionality will be disabled.\n",
                    "willReplaceOnChanges": true
                },
                "indexKnnAlgoParamEfSearch": {
                    "type": "string",
                    "description": "The size of the dynamic list used during k-NN searches. Higher values lead to more accurate but slower searches. Only available for nmslib.\n"
                },
                "indexSimilarityDefault": {
                    "type": "string",
                    "description": "A JSON string describing the default index similarity config.\n",
                    "willReplaceOnChanges": true
                },
                "indexingSlowlogLevel": {
                    "type": "string",
                    "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                },
                "indexingSlowlogSource": {
                    "type": "string",
                    "description": "Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the source entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is reformatted by default to make sure that it fits on a single log line.\n"
                },
                "indexingSlowlogThresholdIndexDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`\n"
                },
                "indexingSlowlogThresholdIndexInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`\n"
                },
                "indexingSlowlogThresholdIndexTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`\n"
                },
                "indexingSlowlogThresholdIndexWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`\n"
                },
                "loadFixedBitsetFiltersEagerly": {
                    "type": "boolean",
                    "description": "Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "mappings": {
                    "type": "string",
                    "description": "A JSON string defining how documents in the index, and the fields they contain, are stored and indexed. To avoid the complexities of field mapping updates, updates of this field are not allowed via this provider.\n",
                    "willReplaceOnChanges": true
                },
                "maxDocvalueFieldsSearch": {
                    "type": "string",
                    "description": "The maximum number of `docvalue_fields` that are allowed in a query. A stringified number.\n"
                },
                "maxInnerResultWindow": {
                    "type": "string",
                    "description": "The maximum value of `from + size` for inner hits definition and top hits aggregations to this index. A stringified number.\n"
                },
                "maxNgramDiff": {
                    "type": "string",
                    "description": "The maximum allowed difference between min*gram and max*gram for NGramTokenizer and NGramTokenFilter. A stringified number.\n"
                },
                "maxRefreshListeners": {
                    "type": "string",
                    "description": "Maximum number of refresh listeners available on each shard of the index. A stringified number.\n"
                },
                "maxRegexLength": {
                    "type": "string",
                    "description": "The maximum length of regex that can be used in Regexp Query. A stringified number.\n"
                },
                "maxRescoreWindow": {
                    "type": "string",
                    "description": "The maximum value of `window_size` for `rescore` requests in searches of this index. A stringified number.\n"
                },
                "maxResultWindow": {
                    "type": "string",
                    "description": "The maximum value of `from + size` for searches to this index. A stringified number.\n"
                },
                "maxScriptFields": {
                    "type": "string",
                    "description": "The maximum number of `script_fields` that are allowed in a query. A stringified number.\n"
                },
                "maxShingleDiff": {
                    "type": "string",
                    "description": "The maximum allowed difference between max*shingle*size and min*shingle*size for ShingleTokenFilter. A stringified number.\n"
                },
                "maxTermsCount": {
                    "type": "string",
                    "description": "The maximum number of terms that can be used in Terms Query. A stringified number.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index to create\n",
                    "willReplaceOnChanges": true
                },
                "numberOfReplicas": {
                    "type": "string",
                    "description": "Number of shard replicas. A stringified number.\n"
                },
                "numberOfRoutingShards": {
                    "type": "string",
                    "description": "Value used with number*of*shards to route documents to a primary shard. A stringified number. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "numberOfShards": {
                    "type": "string",
                    "description": "Number of shards for the index. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "refreshInterval": {
                    "type": "string",
                    "description": "How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1` to disable refresh.\n"
                },
                "rolloverAlias": {
                    "type": "string"
                },
                "routingAllocationEnable": {
                    "type": "string",
                    "description": "Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.\n"
                },
                "routingPartitionSize": {
                    "type": "string",
                    "description": "The number of shards a custom routing value can go to. A stringified number. This can be set only on creation.\n",
                    "willReplaceOnChanges": true
                },
                "routingRebalanceEnable": {
                    "type": "string",
                    "description": "Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.\n"
                },
                "searchIdleAfter": {
                    "type": "string",
                    "description": "How long a shard can not receive a search or get request until its considered search idle.\n"
                },
                "searchSlowlogLevel": {
                    "type": "string",
                    "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                },
                "searchSlowlogThresholdFetchDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`\n"
                },
                "searchSlowlogThresholdFetchInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`\n"
                },
                "searchSlowlogThresholdFetchTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`\n"
                },
                "searchSlowlogThresholdFetchWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`\n"
                },
                "searchSlowlogThresholdQueryDebug": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`\n"
                },
                "searchSlowlogThresholdQueryInfo": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`\n"
                },
                "searchSlowlogThresholdQueryTrace": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`\n"
                },
                "searchSlowlogThresholdQueryWarn": {
                    "type": "string",
                    "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`\n"
                },
                "shardCheckOnStartup": {
                    "type": "string",
                    "description": "Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the shard from being opened. Accepts `false`, `true`, `checksum`.\n",
                    "willReplaceOnChanges": true
                },
                "sortField": {
                    "type": "string",
                    "description": "The field to sort shards in this index by.\n",
                    "willReplaceOnChanges": true
                },
                "sortOrder": {
                    "type": "string",
                    "description": "The direction to sort shards in. Accepts `asc`, `desc`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Index resources.\n",
                "properties": {
                    "aliases": {
                        "type": "string",
                        "description": "A JSON string describing a set of aliases. The index aliases API allows aliasing an index with a name, with all APIs automatically converting the alias name to the actual index name. An alias can also be mapped to more than one index, and when specifying it, the alias will automatically expand to the aliased indices.\n",
                        "willReplaceOnChanges": true
                    },
                    "analysisAnalyzer": {
                        "type": "string",
                        "description": "A JSON string describing the analyzers applied to the index.\n",
                        "willReplaceOnChanges": true
                    },
                    "analysisCharFilter": {
                        "type": "string",
                        "description": "A JSON string describing the char_filters applied to the index.\n",
                        "willReplaceOnChanges": true
                    },
                    "analysisFilter": {
                        "type": "string",
                        "description": "A JSON string describing the filters applied to the index.\n",
                        "willReplaceOnChanges": true
                    },
                    "analysisNormalizer": {
                        "type": "string",
                        "description": "A JSON string describing the normalizers applied to the index.\n",
                        "willReplaceOnChanges": true
                    },
                    "analysisTokenizer": {
                        "type": "string",
                        "description": "A JSON string describing the tokenizers applied to the index.\n",
                        "willReplaceOnChanges": true
                    },
                    "analyzeMaxTokenCount": {
                        "type": "string",
                        "description": "The maximum number of tokens that can be produced using _analyze API. A stringified number.\n"
                    },
                    "autoExpandReplicas": {
                        "type": "string",
                        "description": "Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all)\n"
                    },
                    "blocksMetadata": {
                        "type": "boolean",
                        "description": "Set to `true` to disable index metadata reads and writes.\n"
                    },
                    "blocksRead": {
                        "type": "boolean",
                        "description": "Set to `true` to disable read operations against the index.\n"
                    },
                    "blocksReadOnly": {
                        "type": "boolean",
                        "description": "Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.\n"
                    },
                    "blocksReadOnlyAllowDelete": {
                        "type": "boolean",
                        "description": "Identical to `index.blocks.read_only` but allows deleting the index to free up resources.\n"
                    },
                    "blocksWrite": {
                        "type": "boolean",
                        "description": "Set to `true` to disable data write operations against the index. This setting does not affect metadata.\n"
                    },
                    "codec": {
                        "type": "string",
                        "description": "The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses DEFLATE for a higher compression ratio. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "defaultPipeline": {
                        "type": "string",
                        "description": "The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the pipeline does not exist.\n"
                    },
                    "forceDestroy": {
                        "type": "boolean",
                        "description": "A boolean that indicates that the index should be deleted even if it contains documents.\n"
                    },
                    "gcDeletes": {
                        "type": "string",
                        "description": "The length of time that a deleted document's version number remains available for further versioned operations.\n"
                    },
                    "highlightMaxAnalyzedOffset": {
                        "type": "string",
                        "description": "The maximum number of characters that will be analyzed for a highlight request. A stringified number.\n"
                    },
                    "includeTypeName": {
                        "type": "string",
                        "description": "A string that indicates if and what we should pass to include*type*name parameter. Set to `\"false\"` when trying to create an index on a v6 cluster without a doc type or set to `\"true\"` when trying to create an index on a v7 cluster with a doc type. Since mapping updates are not currently supported, this applies only on index create.\n"
                    },
                    "indexKnn": {
                        "type": "boolean",
                        "description": "Indicates whether the index should build native library indices for the knn*vector fields. If set to false, the knn*vector fields will be stored in doc values, but Approximate k-NN search functionality will be disabled.\n",
                        "willReplaceOnChanges": true
                    },
                    "indexKnnAlgoParamEfSearch": {
                        "type": "string",
                        "description": "The size of the dynamic list used during k-NN searches. Higher values lead to more accurate but slower searches. Only available for nmslib.\n"
                    },
                    "indexSimilarityDefault": {
                        "type": "string",
                        "description": "A JSON string describing the default index similarity config.\n",
                        "willReplaceOnChanges": true
                    },
                    "indexingSlowlogLevel": {
                        "type": "string",
                        "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                    },
                    "indexingSlowlogSource": {
                        "type": "string",
                        "description": "Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the source entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is reformatted by default to make sure that it fits on a single log line.\n"
                    },
                    "indexingSlowlogThresholdIndexDebug": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`\n"
                    },
                    "indexingSlowlogThresholdIndexInfo": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`\n"
                    },
                    "indexingSlowlogThresholdIndexTrace": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`\n"
                    },
                    "indexingSlowlogThresholdIndexWarn": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`\n"
                    },
                    "loadFixedBitsetFiltersEagerly": {
                        "type": "boolean",
                        "description": "Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "mappings": {
                        "type": "string",
                        "description": "A JSON string defining how documents in the index, and the fields they contain, are stored and indexed. To avoid the complexities of field mapping updates, updates of this field are not allowed via this provider.\n",
                        "willReplaceOnChanges": true
                    },
                    "maxDocvalueFieldsSearch": {
                        "type": "string",
                        "description": "The maximum number of `docvalue_fields` that are allowed in a query. A stringified number.\n"
                    },
                    "maxInnerResultWindow": {
                        "type": "string",
                        "description": "The maximum value of `from + size` for inner hits definition and top hits aggregations to this index. A stringified number.\n"
                    },
                    "maxNgramDiff": {
                        "type": "string",
                        "description": "The maximum allowed difference between min*gram and max*gram for NGramTokenizer and NGramTokenFilter. A stringified number.\n"
                    },
                    "maxRefreshListeners": {
                        "type": "string",
                        "description": "Maximum number of refresh listeners available on each shard of the index. A stringified number.\n"
                    },
                    "maxRegexLength": {
                        "type": "string",
                        "description": "The maximum length of regex that can be used in Regexp Query. A stringified number.\n"
                    },
                    "maxRescoreWindow": {
                        "type": "string",
                        "description": "The maximum value of `window_size` for `rescore` requests in searches of this index. A stringified number.\n"
                    },
                    "maxResultWindow": {
                        "type": "string",
                        "description": "The maximum value of `from + size` for searches to this index. A stringified number.\n"
                    },
                    "maxScriptFields": {
                        "type": "string",
                        "description": "The maximum number of `script_fields` that are allowed in a query. A stringified number.\n"
                    },
                    "maxShingleDiff": {
                        "type": "string",
                        "description": "The maximum allowed difference between max*shingle*size and min*shingle*size for ShingleTokenFilter. A stringified number.\n"
                    },
                    "maxTermsCount": {
                        "type": "string",
                        "description": "The maximum number of terms that can be used in Terms Query. A stringified number.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the index to create\n",
                        "willReplaceOnChanges": true
                    },
                    "numberOfReplicas": {
                        "type": "string",
                        "description": "Number of shard replicas. A stringified number.\n"
                    },
                    "numberOfRoutingShards": {
                        "type": "string",
                        "description": "Value used with number*of*shards to route documents to a primary shard. A stringified number. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "numberOfShards": {
                        "type": "string",
                        "description": "Number of shards for the index. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "refreshInterval": {
                        "type": "string",
                        "description": "How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1` to disable refresh.\n"
                    },
                    "rolloverAlias": {
                        "type": "string"
                    },
                    "routingAllocationEnable": {
                        "type": "string",
                        "description": "Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.\n"
                    },
                    "routingPartitionSize": {
                        "type": "string",
                        "description": "The number of shards a custom routing value can go to. A stringified number. This can be set only on creation.\n",
                        "willReplaceOnChanges": true
                    },
                    "routingRebalanceEnable": {
                        "type": "string",
                        "description": "Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.\n"
                    },
                    "searchIdleAfter": {
                        "type": "string",
                        "description": "How long a shard can not receive a search or get request until its considered search idle.\n"
                    },
                    "searchSlowlogLevel": {
                        "type": "string",
                        "description": "Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`\n"
                    },
                    "searchSlowlogThresholdFetchDebug": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`\n"
                    },
                    "searchSlowlogThresholdFetchInfo": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`\n"
                    },
                    "searchSlowlogThresholdFetchTrace": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`\n"
                    },
                    "searchSlowlogThresholdFetchWarn": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`\n"
                    },
                    "searchSlowlogThresholdQueryDebug": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`\n"
                    },
                    "searchSlowlogThresholdQueryInfo": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`\n"
                    },
                    "searchSlowlogThresholdQueryTrace": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`\n"
                    },
                    "searchSlowlogThresholdQueryWarn": {
                        "type": "string",
                        "description": "Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`\n"
                    },
                    "shardCheckOnStartup": {
                        "type": "string",
                        "description": "Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the shard from being opened. Accepts `false`, `true`, `checksum`.\n",
                        "willReplaceOnChanges": true
                    },
                    "sortField": {
                        "type": "string",
                        "description": "The field to sort shards in this index by.\n",
                        "willReplaceOnChanges": true
                    },
                    "sortOrder": {
                        "type": "string",
                        "description": "The direction to sort shards in. Accepts `asc`, `desc`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/indexTemplate:IndexTemplate": {
            "description": "Provides an OpenSearch index template resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\n// Create an index template\nconst template1 = new opensearch.IndexTemplate(\"template1\", {body: `{\n  \"index_patterns\": [\n    \"logs-2020-01-*\"\n  ],\n  \"template\": {\n    \"aliases\": {\n      \"my_logs\": {}\n    },\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": \"2\",\n        \"number_of_replicas\": \"1\"\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"timestamp\": {\n          \"type\": \"date\",\n          \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\"\n        },\n        \"value\": {\n          \"type\": \"double\"\n        }\n      }\n    }\n  }\n}\n\n`});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\n# Create an index template\ntemplate1 = opensearch.IndexTemplate(\"template1\", body=\"\"\"{\n  \"index_patterns\": [\n    \"logs-2020-01-*\"\n  ],\n  \"template\": {\n    \"aliases\": {\n      \"my_logs\": {}\n    },\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": \"2\",\n        \"number_of_replicas\": \"1\"\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"timestamp\": {\n          \"type\": \"date\",\n          \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\"\n        },\n        \"value\": {\n          \"type\": \"double\"\n        }\n      }\n    }\n  }\n}\n\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create an index template\n    var template1 = new Opensearch.IndexTemplate(\"template1\", new()\n    {\n        Body = @\"{\n  \"\"index_patterns\"\": [\n    \"\"logs-2020-01-*\"\"\n  ],\n  \"\"template\"\": {\n    \"\"aliases\"\": {\n      \"\"my_logs\"\": {}\n    },\n    \"\"settings\"\": {\n      \"\"index\"\": {\n        \"\"number_of_shards\"\": \"\"2\"\",\n        \"\"number_of_replicas\"\": \"\"1\"\"\n      }\n    },\n    \"\"mappings\"\": {\n      \"\"properties\"\": {\n        \"\"timestamp\"\": {\n          \"\"type\"\": \"\"date\"\",\n          \"\"format\"\": \"\"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\"\"\n        },\n        \"\"value\"\": {\n          \"\"type\"\": \"\"double\"\"\n        }\n      }\n    }\n  }\n}\n\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewIndexTemplate(ctx, \"template1\", \u0026opensearch.IndexTemplateArgs{\n\t\t\tBody: pulumi.String(`{\n  \"index_patterns\": [\n    \"logs-2020-01-*\"\n  ],\n  \"template\": {\n    \"aliases\": {\n      \"my_logs\": {}\n    },\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": \"2\",\n        \"number_of_replicas\": \"1\"\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"timestamp\": {\n          \"type\": \"date\",\n          \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\"\n        },\n        \"value\": {\n          \"type\": \"double\"\n        }\n      }\n    }\n  }\n}\n\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.IndexTemplate;\nimport com.pulumi.opensearch.IndexTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var template1 = new IndexTemplate(\"template1\", IndexTemplateArgs.builder()        \n            .body(\"\"\"\n{\n  \"index_patterns\": [\n    \"logs-2020-01-*\"\n  ],\n  \"template\": {\n    \"aliases\": {\n      \"my_logs\": {}\n    },\n    \"settings\": {\n      \"index\": {\n        \"number_of_shards\": \"2\",\n        \"number_of_replicas\": \"1\"\n      }\n    },\n    \"mappings\": {\n      \"properties\": {\n        \"timestamp\": {\n          \"type\": \"date\",\n          \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\"\n        },\n        \"value\": {\n          \"type\": \"double\"\n        }\n      }\n    }\n  }\n}\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create an index template\n  template1:\n    type: opensearch:IndexTemplate\n    properties:\n      body: |+\n        {\n          \"index_patterns\": [\n            \"logs-2020-01-*\"\n          ],\n          \"template\": {\n            \"aliases\": {\n              \"my_logs\": {}\n            },\n            \"settings\": {\n              \"index\": {\n                \"number_of_shards\": \"2\",\n                \"number_of_replicas\": \"1\"\n              }\n            },\n            \"mappings\": {\n              \"properties\": {\n                \"timestamp\": {\n                  \"type\": \"date\",\n                  \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\"\n                },\n                \"value\": {\n                  \"type\": \"double\"\n                }\n              }\n            }\n          }\n        }\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/indexTemplate:IndexTemplate template_1 template_1\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the index template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the index template.\n"
                }
            },
            "required": [
                "body",
                "name"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the index template.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the index template.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IndexTemplate resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The JSON body of the index template.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the index template.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/ingestPipeline:IngestPipeline": {
            "description": "Provides an OpenSearch ingest pipeline resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\n// Create a simple ingest pipeline\nconst test = new opensearch.IngestPipeline(\"test\", {body: `{\n  \"description\" : \"describe pipeline\",\n  \"version\": 123,\n  \"processors\" : [\n    {\n      \"set\" : {\n        \"field\": \"foo\",\n        \"value\": \"bar\"\n      }\n    }\n  ]\n}\n\n`});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\n# Create a simple ingest pipeline\ntest = opensearch.IngestPipeline(\"test\", body=\"\"\"{\n  \"description\" : \"describe pipeline\",\n  \"version\": 123,\n  \"processors\" : [\n    {\n      \"set\" : {\n        \"field\": \"foo\",\n        \"value\": \"bar\"\n      }\n    }\n  ]\n}\n\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a simple ingest pipeline\n    var test = new Opensearch.IngestPipeline(\"test\", new()\n    {\n        Body = @\"{\n  \"\"description\"\" : \"\"describe pipeline\"\",\n  \"\"version\"\": 123,\n  \"\"processors\"\" : [\n    {\n      \"\"set\"\" : {\n        \"\"field\"\": \"\"foo\"\",\n        \"\"value\"\": \"\"bar\"\"\n      }\n    }\n  ]\n}\n\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewIngestPipeline(ctx, \"test\", \u0026opensearch.IngestPipelineArgs{\n\t\t\tBody: pulumi.String(`{\n  \"description\" : \"describe pipeline\",\n  \"version\": 123,\n  \"processors\" : [\n    {\n      \"set\" : {\n        \"field\": \"foo\",\n        \"value\": \"bar\"\n      }\n    }\n  ]\n}\n\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.IngestPipeline;\nimport com.pulumi.opensearch.IngestPipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new IngestPipeline(\"test\", IngestPipelineArgs.builder()        \n            .body(\"\"\"\n{\n  \"description\" : \"describe pipeline\",\n  \"version\": 123,\n  \"processors\" : [\n    {\n      \"set\" : {\n        \"field\": \"foo\",\n        \"value\": \"bar\"\n      }\n    }\n  ]\n}\n\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a simple ingest pipeline\n  test:\n    type: opensearch:IngestPipeline\n    properties:\n      body: |+\n        {\n          \"description\" : \"describe pipeline\",\n          \"version\": 123,\n          \"processors\" : [\n            {\n              \"set\" : {\n                \"field\": \"foo\",\n                \"value\": \"bar\"\n              }\n            }\n          ]\n        }\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/ingestPipeline:IngestPipeline test terraform-test\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the ingest pipeline\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ingest pipeline\n"
                }
            },
            "required": [
                "body",
                "name"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The JSON body of the ingest pipeline\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ingest pipeline\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IngestPipeline resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The JSON body of the ingest pipeline\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the ingest pipeline\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/ismPolicy:IsmPolicy": {
            "description": "Provides an OpenSearch Index State Management (ISM) policy. Please refer to the OpenSearch ISM documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as fs from \"fs\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\n// Create an ISM policy\nconst cleanup = new opensearch.IsmPolicy(\"cleanup\", {\n    policyId: \"delete_after_15d\",\n    body: fs.readFileSync(`${path.module}/policies/delete_after_15d.json`, \"utf8\"),\n});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\n# Create an ISM policy\ncleanup = opensearch.IsmPolicy(\"cleanup\",\n    policy_id=\"delete_after_15d\",\n    body=(lambda path: open(path).read())(f\"{path['module']}/policies/delete_after_15d.json\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create an ISM policy\n    var cleanup = new Opensearch.IsmPolicy(\"cleanup\", new()\n    {\n        PolicyId = \"delete_after_15d\",\n        Body = File.ReadAllText($\"{path.Module}/policies/delete_after_15d.json\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewIsmPolicy(ctx, \"cleanup\", \u0026opensearch.IsmPolicyArgs{\n\t\t\tPolicyId: pulumi.String(\"delete_after_15d\"),\n\t\t\tBody:     readFileOrPanic(fmt.Sprintf(\"%v/policies/delete_after_15d.json\", path.Module)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.IsmPolicy;\nimport com.pulumi.opensearch.IsmPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cleanup = new IsmPolicy(\"cleanup\", IsmPolicyArgs.builder()        \n            .policyId(\"delete_after_15d\")\n            .body(Files.readString(Paths.get(String.format(\"%s/policies/delete_after_15d.json\", path.module()))))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create an ISM policy\n  cleanup:\n    type: opensearch:IsmPolicy\n    properties:\n      policyId: delete_after_15d\n      body:\n        fn::readFile: ${path.module}/policies/delete_after_15d.json\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/ismPolicy:IsmPolicy cleanup delete_after_15d\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The policy document.\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "The id of the ISM policy.\n"
                },
                "primaryTerm": {
                    "type": "integer",
                    "description": "The primary term of the ISM policy version.\n"
                },
                "seqNo": {
                    "type": "integer",
                    "description": "The sequence number of the ISM policy version.\n"
                }
            },
            "required": [
                "body",
                "policyId",
                "primaryTerm",
                "seqNo"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The policy document.\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "The id of the ISM policy.\n",
                    "willReplaceOnChanges": true
                },
                "primaryTerm": {
                    "type": "integer",
                    "description": "The primary term of the ISM policy version.\n"
                },
                "seqNo": {
                    "type": "integer",
                    "description": "The sequence number of the ISM policy version.\n"
                }
            },
            "requiredInputs": [
                "body",
                "policyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IsmPolicy resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The policy document.\n"
                    },
                    "policyId": {
                        "type": "string",
                        "description": "The id of the ISM policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "primaryTerm": {
                        "type": "integer",
                        "description": "The primary term of the ISM policy version.\n"
                    },
                    "seqNo": {
                        "type": "integer",
                        "description": "The sequence number of the ISM policy version.\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/ismPolicyMapping:IsmPolicyMapping": {
            "description": "Provides an OpenSearch Index State Management (ISM) policy. Please refer to the OpenSearch ISM documentation for details.\n\n!\u003e `opensearch.IsmPolicyMapping` is deprecated in OpenSearch 1.x please use the `opensearch.IsmPolicy` resource and specify the `ism_template` attribute in the policies instead.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\nconst test = new opensearch.IsmPolicyMapping(\"test\", {\n    indexes: \"test_index\",\n    policyId: \"policy_1\",\n    state: \"delete\",\n});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\ntest = opensearch.IsmPolicyMapping(\"test\",\n    indexes=\"test_index\",\n    policy_id=\"policy_1\",\n    state=\"delete\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Opensearch.IsmPolicyMapping(\"test\", new()\n    {\n        Indexes = \"test_index\",\n        PolicyId = \"policy_1\",\n        State = \"delete\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewIsmPolicyMapping(ctx, \"test\", \u0026opensearch.IsmPolicyMappingArgs{\n\t\t\tIndexes:  pulumi.String(\"test_index\"),\n\t\t\tPolicyId: pulumi.String(\"policy_1\"),\n\t\t\tState:    pulumi.String(\"delete\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.IsmPolicyMapping;\nimport com.pulumi.opensearch.IsmPolicyMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new IsmPolicyMapping(\"test\", IsmPolicyMappingArgs.builder()        \n            .indexes(\"test_index\")\n            .policyId(\"policy_1\")\n            .state(\"delete\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: opensearch:IsmPolicyMapping\n    properties:\n      indexes: test_index\n      policyId: policy_1\n      state: delete\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport by poilcy_id\n\n```sh\n $ pulumi import opensearch:index/ismPolicyMapping:IsmPolicyMapping test policy_1\n```\n\n ",
            "properties": {
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "description": "When updating multiple indices, you might want to include a state filter to only affect certain managed indices. The background process only applies the change if the index is currently in the state specified.\n"
                },
                "indexes": {
                    "type": "string",
                    "description": "Name of the index to apply the policy to. You can use an index pattern to update multiple indices at once.\n"
                },
                "isSafe": {
                    "type": "boolean"
                },
                "managedIndexes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "policyId": {
                    "type": "string",
                    "description": "The name of the policy.\n"
                },
                "state": {
                    "type": "string",
                    "description": "After a change in policy takes place, specify the state for the index to transition to\n"
                }
            },
            "required": [
                "indexes",
                "managedIndexes",
                "policyId"
            ],
            "inputProperties": {
                "includes": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "description": "When updating multiple indices, you might want to include a state filter to only affect certain managed indices. The background process only applies the change if the index is currently in the state specified.\n"
                },
                "indexes": {
                    "type": "string",
                    "description": "Name of the index to apply the policy to. You can use an index pattern to update multiple indices at once.\n"
                },
                "isSafe": {
                    "type": "boolean"
                },
                "managedIndexes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "policyId": {
                    "type": "string",
                    "description": "The name of the policy.\n"
                },
                "state": {
                    "type": "string",
                    "description": "After a change in policy takes place, specify the state for the index to transition to\n"
                }
            },
            "requiredInputs": [
                "indexes",
                "policyId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IsmPolicyMapping resources.\n",
                "properties": {
                    "includes": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "When updating multiple indices, you might want to include a state filter to only affect certain managed indices. The background process only applies the change if the index is currently in the state specified.\n"
                    },
                    "indexes": {
                        "type": "string",
                        "description": "Name of the index to apply the policy to. You can use an index pattern to update multiple indices at once.\n"
                    },
                    "isSafe": {
                        "type": "boolean"
                    },
                    "managedIndexes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "policyId": {
                        "type": "string",
                        "description": "The name of the policy.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "After a change in policy takes place, specify the state for the index to transition to\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/monitor:Monitor": {
            "description": "Provides an OpenSearch monitor. Please refer to the OpenSearch monitor documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\nconst moviesLastHour = new opensearch.Monitor(\"moviesLastHour\", {body: `{\n  \"name\": \"test-monitor\",\n  \"type\": \"monitor\",\n  \"enabled\": true,\n  \"schedule\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"MINUTES\"\n    }\n  },\n  \"inputs\": [{\n    \"search\": {\n      \"indices\": [\"movies\"],\n      \"query\": {\n        \"size\": 0,\n        \"aggregations\": {},\n        \"query\": {\n          \"bool\": {\n            \"adjust_pure_negative\":true,\n            \"boost\":1,\n            \"filter\": [{\n              \"range\": {\n                \"@timestamp\": {\n                  \"boost\":1,\n                  \"from\":\"||-1h\",\n                  \"to\":\"\",\n                  \"include_lower\":true,\n                  \"include_upper\":true,\n                  \"format\": \"epoch_millis\"\n                }\n              }\n            }]\n          }\n        }\n      }\n    }\n  }],\n  \"triggers\": [\n    {\n      \"name\" : \"Errors\",\n      \"severity\" : \"1\",\n      \"condition\" : {\n        \"script\" : {\n          \"source\" : \"ctx.results[0].hits.total.value \u003e 0\",\n          \"lang\" : \"painless\"\n        }\n      },\n      \"actions\" : [\n        {\n          \"name\" : \"Slack\",\n          \"destination_id\" : \"${opensearch_channel_configuration.slack_on_call_channel.id}\",\n          \"message_template\" : {\n            \"source\" : \"bogus\",\n            \"lang\" : \"mustache\"\n          },\n          \"throttle_enabled\" : false,\n          \"subject_template\" : {\n            \"source\" : \"Production Errors\",\n            \"lang\" : \"mustache\"\n          }\n        }\n      ]\n    }\n  ]\n}\n\n`});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\nmovies_last_hour = opensearch.Monitor(\"moviesLastHour\", body=f\"\"\"{{\n  \"name\": \"test-monitor\",\n  \"type\": \"monitor\",\n  \"enabled\": true,\n  \"schedule\": {{\n    \"period\": {{\n      \"interval\": 1,\n      \"unit\": \"MINUTES\"\n    }}\n  }},\n  \"inputs\": [{{\n    \"search\": {{\n      \"indices\": [\"movies\"],\n      \"query\": {{\n        \"size\": 0,\n        \"aggregations\": {{}},\n        \"query\": {{\n          \"bool\": {{\n            \"adjust_pure_negative\":true,\n            \"boost\":1,\n            \"filter\": [{{\n              \"range\": {{\n                \"@timestamp\": {{\n                  \"boost\":1,\n                  \"from\":\"||-1h\",\n                  \"to\":\"\",\n                  \"include_lower\":true,\n                  \"include_upper\":true,\n                  \"format\": \"epoch_millis\"\n                }}\n              }}\n            }}]\n          }}\n        }}\n      }}\n    }}\n  }}],\n  \"triggers\": [\n    {{\n      \"name\" : \"Errors\",\n      \"severity\" : \"1\",\n      \"condition\" : {{\n        \"script\" : {{\n          \"source\" : \"ctx.results[0].hits.total.value \u003e 0\",\n          \"lang\" : \"painless\"\n        }}\n      }},\n      \"actions\" : [\n        {{\n          \"name\" : \"Slack\",\n          \"destination_id\" : \"{opensearch_channel_configuration[\"slack_on_call_channel\"][\"id\"]}\",\n          \"message_template\" : {{\n            \"source\" : \"bogus\",\n            \"lang\" : \"mustache\"\n          }},\n          \"throttle_enabled\" : false,\n          \"subject_template\" : {{\n            \"source\" : \"Production Errors\",\n            \"lang\" : \"mustache\"\n          }}\n        }}\n      ]\n    }}\n  ]\n}}\n\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var moviesLastHour = new Opensearch.Monitor(\"moviesLastHour\", new()\n    {\n        Body = @$\"{{\n  \"\"name\"\": \"\"test-monitor\"\",\n  \"\"type\"\": \"\"monitor\"\",\n  \"\"enabled\"\": true,\n  \"\"schedule\"\": {{\n    \"\"period\"\": {{\n      \"\"interval\"\": 1,\n      \"\"unit\"\": \"\"MINUTES\"\"\n    }}\n  }},\n  \"\"inputs\"\": [{{\n    \"\"search\"\": {{\n      \"\"indices\"\": [\"\"movies\"\"],\n      \"\"query\"\": {{\n        \"\"size\"\": 0,\n        \"\"aggregations\"\": {{}},\n        \"\"query\"\": {{\n          \"\"bool\"\": {{\n            \"\"adjust_pure_negative\"\":true,\n            \"\"boost\"\":1,\n            \"\"filter\"\": [{{\n              \"\"range\"\": {{\n                \"\"@timestamp\"\": {{\n                  \"\"boost\"\":1,\n                  \"\"from\"\":\"\"||-1h\"\",\n                  \"\"to\"\":\"\"\"\",\n                  \"\"include_lower\"\":true,\n                  \"\"include_upper\"\":true,\n                  \"\"format\"\": \"\"epoch_millis\"\"\n                }}\n              }}\n            }}]\n          }}\n        }}\n      }}\n    }}\n  }}],\n  \"\"triggers\"\": [\n    {{\n      \"\"name\"\" : \"\"Errors\"\",\n      \"\"severity\"\" : \"\"1\"\",\n      \"\"condition\"\" : {{\n        \"\"script\"\" : {{\n          \"\"source\"\" : \"\"ctx.results[0].hits.total.value \u003e 0\"\",\n          \"\"lang\"\" : \"\"painless\"\"\n        }}\n      }},\n      \"\"actions\"\" : [\n        {{\n          \"\"name\"\" : \"\"Slack\"\",\n          \"\"destination_id\"\" : \"\"{opensearch_channel_configuration.Slack_on_call_channel.Id}\"\",\n          \"\"message_template\"\" : {{\n            \"\"source\"\" : \"\"bogus\"\",\n            \"\"lang\"\" : \"\"mustache\"\"\n          }},\n          \"\"throttle_enabled\"\" : false,\n          \"\"subject_template\"\" : {{\n            \"\"source\"\" : \"\"Production Errors\"\",\n            \"\"lang\"\" : \"\"mustache\"\"\n          }}\n        }}\n      ]\n    }}\n  ]\n}}\n\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewMonitor(ctx, \"moviesLastHour\", \u0026opensearch.MonitorArgs{\n\t\t\tBody: pulumi.String(fmt.Sprintf(`{\n  \"name\": \"test-monitor\",\n  \"type\": \"monitor\",\n  \"enabled\": true,\n  \"schedule\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"MINUTES\"\n    }\n  },\n  \"inputs\": [{\n    \"search\": {\n      \"indices\": [\"movies\"],\n      \"query\": {\n        \"size\": 0,\n        \"aggregations\": {},\n        \"query\": {\n          \"bool\": {\n            \"adjust_pure_negative\":true,\n            \"boost\":1,\n            \"filter\": [{\n              \"range\": {\n                \"@timestamp\": {\n                  \"boost\":1,\n                  \"from\":\"||-1h\",\n                  \"to\":\"\",\n                  \"include_lower\":true,\n                  \"include_upper\":true,\n                  \"format\": \"epoch_millis\"\n                }\n              }\n            }]\n          }\n        }\n      }\n    }\n  }],\n  \"triggers\": [\n    {\n      \"name\" : \"Errors\",\n      \"severity\" : \"1\",\n      \"condition\" : {\n        \"script\" : {\n          \"source\" : \"ctx.results[0].hits.total.value \u003e 0\",\n          \"lang\" : \"painless\"\n        }\n      },\n      \"actions\" : [\n        {\n          \"name\" : \"Slack\",\n          \"destination_id\" : \"%v\",\n          \"message_template\" : {\n            \"source\" : \"bogus\",\n            \"lang\" : \"mustache\"\n          },\n          \"throttle_enabled\" : false,\n          \"subject_template\" : {\n            \"source\" : \"Production Errors\",\n            \"lang\" : \"mustache\"\n          }\n        }\n      ]\n    }\n  ]\n}\n\n`, opensearch_channel_configuration.Slack_on_call_channel.Id)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.Monitor;\nimport com.pulumi.opensearch.MonitorArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var moviesLastHour = new Monitor(\"moviesLastHour\", MonitorArgs.builder()        \n            .body(\"\"\"\n{\n  \"name\": \"test-monitor\",\n  \"type\": \"monitor\",\n  \"enabled\": true,\n  \"schedule\": {\n    \"period\": {\n      \"interval\": 1,\n      \"unit\": \"MINUTES\"\n    }\n  },\n  \"inputs\": [{\n    \"search\": {\n      \"indices\": [\"movies\"],\n      \"query\": {\n        \"size\": 0,\n        \"aggregations\": {},\n        \"query\": {\n          \"bool\": {\n            \"adjust_pure_negative\":true,\n            \"boost\":1,\n            \"filter\": [{\n              \"range\": {\n                \"@timestamp\": {\n                  \"boost\":1,\n                  \"from\":\"||-1h\",\n                  \"to\":\"\",\n                  \"include_lower\":true,\n                  \"include_upper\":true,\n                  \"format\": \"epoch_millis\"\n                }\n              }\n            }]\n          }\n        }\n      }\n    }\n  }],\n  \"triggers\": [\n    {\n      \"name\" : \"Errors\",\n      \"severity\" : \"1\",\n      \"condition\" : {\n        \"script\" : {\n          \"source\" : \"ctx.results[0].hits.total.value \u003e 0\",\n          \"lang\" : \"painless\"\n        }\n      },\n      \"actions\" : [\n        {\n          \"name\" : \"Slack\",\n          \"destination_id\" : \"%s\",\n          \"message_template\" : {\n            \"source\" : \"bogus\",\n            \"lang\" : \"mustache\"\n          },\n          \"throttle_enabled\" : false,\n          \"subject_template\" : {\n            \"source\" : \"Production Errors\",\n            \"lang\" : \"mustache\"\n          }\n        }\n      ]\n    }\n  ]\n}\n\n\", opensearch_channel_configuration.slack_on_call_channel().id()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  moviesLastHour:\n    type: opensearch:Monitor\n    properties:\n      body: |+\n        {\n          \"name\": \"test-monitor\",\n          \"type\": \"monitor\",\n          \"enabled\": true,\n          \"schedule\": {\n            \"period\": {\n              \"interval\": 1,\n              \"unit\": \"MINUTES\"\n            }\n          },\n          \"inputs\": [{\n            \"search\": {\n              \"indices\": [\"movies\"],\n              \"query\": {\n                \"size\": 0,\n                \"aggregations\": {},\n                \"query\": {\n                  \"bool\": {\n                    \"adjust_pure_negative\":true,\n                    \"boost\":1,\n                    \"filter\": [{\n                      \"range\": {\n                        \"@timestamp\": {\n                          \"boost\":1,\n                          \"from\":\"||-1h\",\n                          \"to\":\"\",\n                          \"include_lower\":true,\n                          \"include_upper\":true,\n                          \"format\": \"epoch_millis\"\n                        }\n                      }\n                    }]\n                  }\n                }\n              }\n            }\n          }],\n          \"triggers\": [\n            {\n              \"name\" : \"Errors\",\n              \"severity\" : \"1\",\n              \"condition\" : {\n                \"script\" : {\n                  \"source\" : \"ctx.results[0].hits.total.value \u003e 0\",\n                  \"lang\" : \"painless\"\n                }\n              },\n              \"actions\" : [\n                {\n                  \"name\" : \"Slack\",\n                  \"destination_id\" : \"${opensearch_channel_configuration.slack_on_call_channel.id}\",\n                  \"message_template\" : {\n                    \"source\" : \"bogus\",\n                    \"lang\" : \"mustache\"\n                  },\n                  \"throttle_enabled\" : false,\n                  \"subject_template\" : {\n                    \"source\" : \"Production Errors\",\n                    \"lang\" : \"mustache\"\n                  }\n                }\n              ]\n            }\n          ]\n        }\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/monitor:Monitor alert lgOZb3UB96pyyRQv0ppQ\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The monitor document\n"
                }
            },
            "required": [
                "body"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The monitor document\n"
                }
            },
            "requiredInputs": [
                "body"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Monitor resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The monitor document\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/role:Role": {
            "description": "Provides an OpenSearch security role resource. Please refer to the OpenSearch Access Control documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\n// To set document level permissions:\nconst writer = new opensearch.Role(\"writer\", {\n    clusterPermissions: [\"*\"],\n    indexPermissions: [{\n        allowedActions: [\"read\"],\n        documentLevelSecurity: \"{\\\"term\\\": { \\\"readable_by\\\": \\\"${user.name}\\\"}}\",\n        indexPatterns: [\"pub*\"],\n    }],\n    roleName: \"foo_writer\",\n});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\n# To set document level permissions:\nwriter = opensearch.Role(\"writer\",\n    cluster_permissions=[\"*\"],\n    index_permissions=[opensearch.RoleIndexPermissionArgs(\n        allowed_actions=[\"read\"],\n        document_level_security=\"{\\\"term\\\": { \\\"readable_by\\\": \\\"${user.name}\\\"}}\",\n        index_patterns=[\"pub*\"],\n    )],\n    role_name=\"foo_writer\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // To set document level permissions:\n    var writer = new Opensearch.Role(\"writer\", new()\n    {\n        ClusterPermissions = new[]\n        {\n            \"*\",\n        },\n        IndexPermissions = new[]\n        {\n            new Opensearch.Inputs.RoleIndexPermissionArgs\n            {\n                AllowedActions = new[]\n                {\n                    \"read\",\n                },\n                DocumentLevelSecurity = \"{\\\"term\\\": { \\\"readable_by\\\": \\\"${user.name}\\\"}}\",\n                IndexPatterns = new[]\n                {\n                    \"pub*\",\n                },\n            },\n        },\n        RoleName = \"foo_writer\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewRole(ctx, \"writer\", \u0026opensearch.RoleArgs{\n\t\t\tClusterPermissions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"*\"),\n\t\t\t},\n\t\t\tIndexPermissions: opensearch.RoleIndexPermissionArray{\n\t\t\t\t\u0026opensearch.RoleIndexPermissionArgs{\n\t\t\t\t\tAllowedActions: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"read\"),\n\t\t\t\t\t},\n\t\t\t\t\tDocumentLevelSecurity: pulumi.String(\"{\\\"term\\\": { \\\"readable_by\\\": \\\"${user.name}\\\"}}\"),\n\t\t\t\t\tIndexPatterns: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"pub*\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tRoleName: pulumi.String(\"foo_writer\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.Role;\nimport com.pulumi.opensearch.RoleArgs;\nimport com.pulumi.opensearch.inputs.RoleIndexPermissionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var writer = new Role(\"writer\", RoleArgs.builder()        \n            .clusterPermissions(\"*\")\n            .indexPermissions(RoleIndexPermissionArgs.builder()\n                .allowedActions(\"read\")\n                .documentLevelSecurity(\"{\\\"term\\\": { \\\"readable_by\\\": \\\"${user.name}\\\"}}\")\n                .indexPatterns(\"pub*\")\n                .build())\n            .roleName(\"foo_writer\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # To set document level permissions:\n  writer:\n    type: opensearch:Role\n    properties:\n      clusterPermissions:\n        - '*'\n      indexPermissions:\n        - allowedActions:\n            - read\n          documentLevelSecurity: '{\"term\": { \"readable_by\": \"${user.name}\"}}'\n          indexPatterns:\n            - pub*\n      roleName: foo_writer\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/role:Role writer logs_writer\n```\n\n ",
            "properties": {
                "clusterPermissions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of cluster permissions.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the role.\n"
                },
                "indexPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/opensearch:index/RoleIndexPermission:RoleIndexPermission"
                    },
                    "description": "A configuration of index permissions\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the security role.\n"
                },
                "tenantPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/opensearch:index/RoleTenantPermission:RoleTenantPermission"
                    },
                    "description": "A configuration of tenant permissions\n"
                }
            },
            "required": [
                "roleName"
            ],
            "inputProperties": {
                "clusterPermissions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of cluster permissions.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the role.\n"
                },
                "indexPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/opensearch:index/RoleIndexPermission:RoleIndexPermission"
                    },
                    "description": "A configuration of index permissions\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the security role.\n",
                    "willReplaceOnChanges": true
                },
                "tenantPermissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/opensearch:index/RoleTenantPermission:RoleTenantPermission"
                    },
                    "description": "A configuration of tenant permissions\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "clusterPermissions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of cluster permissions.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the role.\n"
                    },
                    "indexPermissions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/opensearch:index/RoleIndexPermission:RoleIndexPermission"
                        },
                        "description": "A configuration of index permissions\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the security role.\n",
                        "willReplaceOnChanges": true
                    },
                    "tenantPermissions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/opensearch:index/RoleTenantPermission:RoleTenantPermission"
                        },
                        "description": "A configuration of tenant permissions\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/rolesMapping:RolesMapping": {
            "description": "Provides an OpenSearch security role mapping. Please refer to the OpenSearch Access Control documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\n// Create a role mapping\nconst mapper = new opensearch.RolesMapping(\"mapper\", {\n    backendRoles: [\n        \"arn:aws:iam::123456789012:role/lambda-call-opensearch\",\n        \"arn:aws:iam::123456789012:role/run-containers\",\n    ],\n    description: \"Mapping AWS IAM roles to ES role\",\n    roleName: \"logs_writer\",\n});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\n# Create a role mapping\nmapper = opensearch.RolesMapping(\"mapper\",\n    backend_roles=[\n        \"arn:aws:iam::123456789012:role/lambda-call-opensearch\",\n        \"arn:aws:iam::123456789012:role/run-containers\",\n    ],\n    description=\"Mapping AWS IAM roles to ES role\",\n    role_name=\"logs_writer\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a role mapping\n    var mapper = new Opensearch.RolesMapping(\"mapper\", new()\n    {\n        BackendRoles = new[]\n        {\n            \"arn:aws:iam::123456789012:role/lambda-call-opensearch\",\n            \"arn:aws:iam::123456789012:role/run-containers\",\n        },\n        Description = \"Mapping AWS IAM roles to ES role\",\n        RoleName = \"logs_writer\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewRolesMapping(ctx, \"mapper\", \u0026opensearch.RolesMappingArgs{\n\t\t\tBackendRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"arn:aws:iam::123456789012:role/lambda-call-opensearch\"),\n\t\t\t\tpulumi.String(\"arn:aws:iam::123456789012:role/run-containers\"),\n\t\t\t},\n\t\t\tDescription: pulumi.String(\"Mapping AWS IAM roles to ES role\"),\n\t\t\tRoleName:    pulumi.String(\"logs_writer\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.RolesMapping;\nimport com.pulumi.opensearch.RolesMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var mapper = new RolesMapping(\"mapper\", RolesMappingArgs.builder()        \n            .backendRoles(            \n                \"arn:aws:iam::123456789012:role/lambda-call-opensearch\",\n                \"arn:aws:iam::123456789012:role/run-containers\")\n            .description(\"Mapping AWS IAM roles to ES role\")\n            .roleName(\"logs_writer\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a role mapping\n  mapper:\n    type: opensearch:RolesMapping\n    properties:\n      backendRoles:\n        - arn:aws:iam::123456789012:role/lambda-call-opensearch\n        - arn:aws:iam::123456789012:role/run-containers\n      description: Mapping AWS IAM roles to ES role\n      roleName: logs_writer\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/rolesMapping:RolesMapping mapper logs_writer\n```\n\n ",
            "properties": {
                "andBackendRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of backend roles.\n"
                },
                "backendRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of backend roles.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the role mapping.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of host names.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the security role.\n"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of users.\n"
                }
            },
            "required": [
                "roleName"
            ],
            "inputProperties": {
                "andBackendRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of backend roles.\n"
                },
                "backendRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of backend roles.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the role mapping.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of host names.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "The name of the security role.\n",
                    "willReplaceOnChanges": true
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of users.\n"
                }
            },
            "requiredInputs": [
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RolesMapping resources.\n",
                "properties": {
                    "andBackendRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of backend roles.\n"
                    },
                    "backendRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of backend roles.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the role mapping.\n"
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of host names.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "The name of the security role.\n",
                        "willReplaceOnChanges": true
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of users.\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/script:Script": {
            "description": "Provides an OpenSearch script resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\n// Create a script\nconst testScript = new opensearch.Script(\"testScript\", {\n    lang: \"painless\",\n    scriptId: \"my_script\",\n    source: \"Math.log(_score * 2) + params.my_modifier\",\n});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\n# Create a script\ntest_script = opensearch.Script(\"testScript\",\n    lang=\"painless\",\n    script_id=\"my_script\",\n    source=\"Math.log(_score * 2) + params.my_modifier\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a script\n    var testScript = new Opensearch.Script(\"testScript\", new()\n    {\n        Lang = \"painless\",\n        ScriptId = \"my_script\",\n        Source = \"Math.log(_score * 2) + params.my_modifier\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewScript(ctx, \"testScript\", \u0026opensearch.ScriptArgs{\n\t\t\tLang:     pulumi.String(\"painless\"),\n\t\t\tScriptId: pulumi.String(\"my_script\"),\n\t\t\tSource:   pulumi.String(\"Math.log(_score * 2) + params.my_modifier\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.Script;\nimport com.pulumi.opensearch.ScriptArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testScript = new Script(\"testScript\", ScriptArgs.builder()        \n            .lang(\"painless\")\n            .scriptId(\"my_script\")\n            .source(\"Math.log(_score * 2) + params.my_modifier\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a script\n  testScript:\n    type: opensearch:Script\n    properties:\n      lang: painless\n      scriptId: my_script\n      source: Math.log(_score * 2) + params.my_modifier\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/script:Script test_script my_script\n```\n\n ",
            "properties": {
                "lang": {
                    "type": "string",
                    "description": "Specifies the language the script is written in. Defaults to painless.\n"
                },
                "scriptId": {
                    "type": "string",
                    "description": "Identifier for the stored script. Must be unique within the cluster.\n"
                },
                "source": {
                    "type": "string",
                    "description": "The source of the stored script\n"
                }
            },
            "required": [
                "scriptId",
                "source"
            ],
            "inputProperties": {
                "lang": {
                    "type": "string",
                    "description": "Specifies the language the script is written in. Defaults to painless.\n"
                },
                "scriptId": {
                    "type": "string",
                    "description": "Identifier for the stored script. Must be unique within the cluster.\n",
                    "willReplaceOnChanges": true
                },
                "source": {
                    "type": "string",
                    "description": "The source of the stored script\n"
                }
            },
            "requiredInputs": [
                "scriptId",
                "source"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Script resources.\n",
                "properties": {
                    "lang": {
                        "type": "string",
                        "description": "Specifies the language the script is written in. Defaults to painless.\n"
                    },
                    "scriptId": {
                        "type": "string",
                        "description": "Identifier for the stored script. Must be unique within the cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "source": {
                        "type": "string",
                        "description": "The source of the stored script\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/smPolicy:SmPolicy": {
            "description": "Provides an OpenSearch Snapshot Management (SM) policy. Please refer to the OpenSearch SM documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\n// Create a snapshot repository. Make sure you also have created the bucket (eg. \n// via `terraform-aws-modules/s3-bucket/aws`) and matching IAM role.\nconst repo = new opensearch.SnapshotRepository(\"repo\", {\n    type: \"s3\",\n    settings: {\n        bucket: module.s3_snapshot.s3_bucket_id,\n        region: module.s3_snapshot.s3_bucket_region,\n        role_arn: aws_iam_role.snapshot_create.arn,\n        server_side_encryption: true,\n    },\n});\n// Create the SM policy\nconst snapshotToS3 = new opensearch.SmPolicy(\"snapshotToS3\", {\n    policyName: \"snapshot_to_s3\",\n    body: repo.name.apply(name =\u003e JSON.stringify({\n        enabled: true,\n        description: \"My snapshot policy\",\n        creation: {\n            schedule: {\n                cron: {\n                    expression: \"0 0 * * *\",\n                    timezone: \"UTC\",\n                },\n            },\n            time_limit: \"1h\",\n        },\n        deletion: {\n            schedule: {\n                cron: {\n                    expression: \"0 0 * * *\",\n                    timezone: \"UTC\",\n                },\n            },\n            condition: {\n                max_age: \"14d\",\n                max_count: 400,\n                min_count: 1,\n            },\n            time_limit: \"1h\",\n        },\n        snapshot_config: {\n            timezone: \"UTC\",\n            indices: \"*\",\n            repository: name,\n        },\n    })),\n});\n```\n```python\nimport pulumi\nimport json\nimport piclemx_pulumi_opensearch as opensearch\n\n# Create a snapshot repository. Make sure you also have created the bucket (eg. \n# via `terraform-aws-modules/s3-bucket/aws`) and matching IAM role.\nrepo = opensearch.SnapshotRepository(\"repo\",\n    type=\"s3\",\n    settings={\n        \"bucket\": module[\"s3_snapshot\"][\"s3_bucket_id\"],\n        \"region\": module[\"s3_snapshot\"][\"s3_bucket_region\"],\n        \"role_arn\": aws_iam_role[\"snapshot_create\"][\"arn\"],\n        \"server_side_encryption\": True,\n    })\n# Create the SM policy\nsnapshot_to_s3 = opensearch.SmPolicy(\"snapshotToS3\",\n    policy_name=\"snapshot_to_s3\",\n    body=repo.name.apply(lambda name: json.dumps({\n        \"enabled\": True,\n        \"description\": \"My snapshot policy\",\n        \"creation\": {\n            \"schedule\": {\n                \"cron\": {\n                    \"expression\": \"0 0 * * *\",\n                    \"timezone\": \"UTC\",\n                },\n            },\n            \"time_limit\": \"1h\",\n        },\n        \"deletion\": {\n            \"schedule\": {\n                \"cron\": {\n                    \"expression\": \"0 0 * * *\",\n                    \"timezone\": \"UTC\",\n                },\n            },\n            \"condition\": {\n                \"max_age\": \"14d\",\n                \"max_count\": 400,\n                \"min_count\": 1,\n            },\n            \"time_limit\": \"1h\",\n        },\n        \"snapshot_config\": {\n            \"timezone\": \"UTC\",\n            \"indices\": \"*\",\n            \"repository\": name,\n        },\n    })))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a snapshot repository. Make sure you also have created the bucket (eg. \n    // via `terraform-aws-modules/s3-bucket/aws`) and matching IAM role.\n    var repo = new Opensearch.SnapshotRepository(\"repo\", new()\n    {\n        Type = \"s3\",\n        Settings = \n        {\n            { \"bucket\", module.S3_snapshot.S3_bucket_id },\n            { \"region\", module.S3_snapshot.S3_bucket_region },\n            { \"role_arn\", aws_iam_role.Snapshot_create.Arn },\n            { \"server_side_encryption\", true },\n        },\n    });\n\n    // Create the SM policy\n    var snapshotToS3 = new Opensearch.SmPolicy(\"snapshotToS3\", new()\n    {\n        PolicyName = \"snapshot_to_s3\",\n        Body = repo.Name.Apply(name =\u003e JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"enabled\"] = true,\n            [\"description\"] = \"My snapshot policy\",\n            [\"creation\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"schedule\"] = new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"cron\"] = new Dictionary\u003cstring, object?\u003e\n                    {\n                        [\"expression\"] = \"0 0 * * *\",\n                        [\"timezone\"] = \"UTC\",\n                    },\n                },\n                [\"time_limit\"] = \"1h\",\n            },\n            [\"deletion\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"schedule\"] = new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"cron\"] = new Dictionary\u003cstring, object?\u003e\n                    {\n                        [\"expression\"] = \"0 0 * * *\",\n                        [\"timezone\"] = \"UTC\",\n                    },\n                },\n                [\"condition\"] = new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"max_age\"] = \"14d\",\n                    [\"max_count\"] = 400,\n                    [\"min_count\"] = 1,\n                },\n                [\"time_limit\"] = \"1h\",\n            },\n            [\"snapshot_config\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"timezone\"] = \"UTC\",\n                [\"indices\"] = \"*\",\n                [\"repository\"] = name,\n            },\n        })),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trepo, err := opensearch.NewSnapshotRepository(ctx, \"repo\", \u0026opensearch.SnapshotRepositoryArgs{\n\t\t\tType: pulumi.String(\"s3\"),\n\t\t\tSettings: pulumi.Map{\n\t\t\t\t\"bucket\":                 pulumi.Any(module.S3_snapshot.S3_bucket_id),\n\t\t\t\t\"region\":                 pulumi.Any(module.S3_snapshot.S3_bucket_region),\n\t\t\t\t\"role_arn\":               pulumi.Any(aws_iam_role.Snapshot_create.Arn),\n\t\t\t\t\"server_side_encryption\": pulumi.Any(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = opensearch.NewSmPolicy(ctx, \"snapshotToS3\", \u0026opensearch.SmPolicyArgs{\n\t\t\tPolicyName: pulumi.String(\"snapshot_to_s3\"),\n\t\t\tBody: repo.Name.ApplyT(func(name string) (pulumi.String, error) {\n\t\t\t\tvar _zero pulumi.String\n\t\t\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\t\t\"enabled\":     true,\n\t\t\t\t\t\"description\": \"My snapshot policy\",\n\t\t\t\t\t\"creation\": map[string]interface{}{\n\t\t\t\t\t\t\"schedule\": map[string]interface{}{\n\t\t\t\t\t\t\t\"cron\": map[string]interface{}{\n\t\t\t\t\t\t\t\t\"expression\": \"0 0 * * *\",\n\t\t\t\t\t\t\t\t\"timezone\":   \"UTC\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"time_limit\": \"1h\",\n\t\t\t\t\t},\n\t\t\t\t\t\"deletion\": map[string]interface{}{\n\t\t\t\t\t\t\"schedule\": map[string]interface{}{\n\t\t\t\t\t\t\t\"cron\": map[string]interface{}{\n\t\t\t\t\t\t\t\t\"expression\": \"0 0 * * *\",\n\t\t\t\t\t\t\t\t\"timezone\":   \"UTC\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"condition\": map[string]interface{}{\n\t\t\t\t\t\t\t\"max_age\":   \"14d\",\n\t\t\t\t\t\t\t\"max_count\": 400,\n\t\t\t\t\t\t\t\"min_count\": 1,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"time_limit\": \"1h\",\n\t\t\t\t\t},\n\t\t\t\t\t\"snapshot_config\": map[string]interface{}{\n\t\t\t\t\t\t\"timezone\":   \"UTC\",\n\t\t\t\t\t\t\"indices\":    \"*\",\n\t\t\t\t\t\t\"repository\": name,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn _zero, err\n\t\t\t\t}\n\t\t\t\tjson0 := string(tmpJSON0)\n\t\t\t\treturn pulumi.String(json0), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.SnapshotRepository;\nimport com.pulumi.opensearch.SnapshotRepositoryArgs;\nimport com.pulumi.opensearch.SmPolicy;\nimport com.pulumi.opensearch.SmPolicyArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var repo = new SnapshotRepository(\"repo\", SnapshotRepositoryArgs.builder()        \n            .type(\"s3\")\n            .settings(Map.ofEntries(\n                Map.entry(\"bucket\", module.s3_snapshot().s3_bucket_id()),\n                Map.entry(\"region\", module.s3_snapshot().s3_bucket_region()),\n                Map.entry(\"role_arn\", aws_iam_role.snapshot_create().arn()),\n                Map.entry(\"server_side_encryption\", true)\n            ))\n            .build());\n\n        var snapshotToS3 = new SmPolicy(\"snapshotToS3\", SmPolicyArgs.builder()        \n            .policyName(\"snapshot_to_s3\")\n            .body(repo.name().applyValue(name -\u003e serializeJson(\n                jsonObject(\n                    jsonProperty(\"enabled\", true),\n                    jsonProperty(\"description\", \"My snapshot policy\"),\n                    jsonProperty(\"creation\", jsonObject(\n                        jsonProperty(\"schedule\", jsonObject(\n                            jsonProperty(\"cron\", jsonObject(\n                                jsonProperty(\"expression\", \"0 0 * * *\"),\n                                jsonProperty(\"timezone\", \"UTC\")\n                            ))\n                        )),\n                        jsonProperty(\"time_limit\", \"1h\")\n                    )),\n                    jsonProperty(\"deletion\", jsonObject(\n                        jsonProperty(\"schedule\", jsonObject(\n                            jsonProperty(\"cron\", jsonObject(\n                                jsonProperty(\"expression\", \"0 0 * * *\"),\n                                jsonProperty(\"timezone\", \"UTC\")\n                            ))\n                        )),\n                        jsonProperty(\"condition\", jsonObject(\n                            jsonProperty(\"max_age\", \"14d\"),\n                            jsonProperty(\"max_count\", 400),\n                            jsonProperty(\"min_count\", 1)\n                        )),\n                        jsonProperty(\"time_limit\", \"1h\")\n                    )),\n                    jsonProperty(\"snapshot_config\", jsonObject(\n                        jsonProperty(\"timezone\", \"UTC\"),\n                        jsonProperty(\"indices\", \"*\"),\n                        jsonProperty(\"repository\", name)\n                    ))\n                ))))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a snapshot repository. Make sure you also have created the bucket (eg. \n  # via `terraform-aws-modules/s3-bucket/aws`) and matching IAM role.\n  repo:\n    type: opensearch:SnapshotRepository\n    properties:\n      type: s3\n      settings:\n        bucket: ${module.s3_snapshot.s3_bucket_id}\n        region: ${module.s3_snapshot.s3_bucket_region}\n        role_arn: ${aws_iam_role.snapshot_create.arn}\n        server_side_encryption: true\n  # Create the SM policy\n  snapshotToS3:\n    type: opensearch:SmPolicy\n    properties:\n      policyName: snapshot_to_s3\n      body:\n        fn::toJSON:\n          enabled: true\n          description: My snapshot policy\n          creation:\n            schedule:\n              cron:\n                expression: 0 0 * * *\n                timezone: UTC\n            time_limit: 1h\n          deletion:\n            schedule:\n              cron:\n                expression: 0 0 * * *\n                timezone: UTC\n            condition:\n              max_age: 14d\n              max_count: 400\n              min_count: 1\n            time_limit: 1h\n          snapshot_config:\n            timezone: UTC\n            indices: '*'\n            repository: ${repo.name}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/smPolicy:SmPolicy cleanup snapshot_to_s3\n```\n\n ",
            "properties": {
                "body": {
                    "type": "string",
                    "description": "The policy document.\n"
                },
                "policyName": {
                    "type": "string",
                    "description": "The name of the SM policy.\n"
                },
                "primaryTerm": {
                    "type": "integer",
                    "description": "The primary term of the SM policy version.\n"
                },
                "seqNo": {
                    "type": "integer",
                    "description": "The sequence number of the SM policy version.\n"
                }
            },
            "required": [
                "body",
                "policyName",
                "primaryTerm",
                "seqNo"
            ],
            "inputProperties": {
                "body": {
                    "type": "string",
                    "description": "The policy document.\n"
                },
                "policyName": {
                    "type": "string",
                    "description": "The name of the SM policy.\n",
                    "willReplaceOnChanges": true
                },
                "primaryTerm": {
                    "type": "integer",
                    "description": "The primary term of the SM policy version.\n"
                },
                "seqNo": {
                    "type": "integer",
                    "description": "The sequence number of the SM policy version.\n"
                }
            },
            "requiredInputs": [
                "body",
                "policyName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SmPolicy resources.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The policy document.\n"
                    },
                    "policyName": {
                        "type": "string",
                        "description": "The name of the SM policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "primaryTerm": {
                        "type": "integer",
                        "description": "The primary term of the SM policy version.\n"
                    },
                    "seqNo": {
                        "type": "integer",
                        "description": "The sequence number of the SM policy version.\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/snapshotRepository:SnapshotRepository": {
            "description": "Provides an OpenSearch snapshot repository resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\n// Create a snapshot repository\nconst repo = new opensearch.SnapshotRepository(\"repo\", {\n    settings: {\n        bucket: \"es-index-backups\",\n        region: \"us-east-1\",\n        role_arn: \"arn:aws:iam::123456789012:role/MyRole\",\n    },\n    type: \"s3\",\n});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\n# Create a snapshot repository\nrepo = opensearch.SnapshotRepository(\"repo\",\n    settings={\n        \"bucket\": \"es-index-backups\",\n        \"region\": \"us-east-1\",\n        \"role_arn\": \"arn:aws:iam::123456789012:role/MyRole\",\n    },\n    type=\"s3\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a snapshot repository\n    var repo = new Opensearch.SnapshotRepository(\"repo\", new()\n    {\n        Settings = \n        {\n            { \"bucket\", \"es-index-backups\" },\n            { \"region\", \"us-east-1\" },\n            { \"role_arn\", \"arn:aws:iam::123456789012:role/MyRole\" },\n        },\n        Type = \"s3\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewSnapshotRepository(ctx, \"repo\", \u0026opensearch.SnapshotRepositoryArgs{\n\t\t\tSettings: pulumi.Map{\n\t\t\t\t\"bucket\":   pulumi.Any(\"es-index-backups\"),\n\t\t\t\t\"region\":   pulumi.Any(\"us-east-1\"),\n\t\t\t\t\"role_arn\": pulumi.Any(\"arn:aws:iam::123456789012:role/MyRole\"),\n\t\t\t},\n\t\t\tType: pulumi.String(\"s3\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.SnapshotRepository;\nimport com.pulumi.opensearch.SnapshotRepositoryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var repo = new SnapshotRepository(\"repo\", SnapshotRepositoryArgs.builder()        \n            .settings(Map.ofEntries(\n                Map.entry(\"bucket\", \"es-index-backups\"),\n                Map.entry(\"region\", \"us-east-1\"),\n                Map.entry(\"role_arn\", \"arn:aws:iam::123456789012:role/MyRole\")\n            ))\n            .type(\"s3\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a snapshot repository\n  repo:\n    type: opensearch:SnapshotRepository\n    properties:\n      settings:\n        bucket: es-index-backups\n        region: us-east-1\n        role_arn: arn:aws:iam::123456789012:role/MyRole\n      type: s3\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/snapshotRepository:SnapshotRepository repo es-index-backups\n```\n\n ",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the repository.\n"
                },
                "settings": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "The settings map applicable for the backend, see official documentation for plugins.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The name of the repository backend (required plugins must be installed).\n"
                }
            },
            "required": [
                "name",
                "type"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the repository.\n",
                    "willReplaceOnChanges": true
                },
                "settings": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "The settings map applicable for the backend, see official documentation for plugins.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The name of the repository backend (required plugins must be installed).\n"
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SnapshotRepository resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the repository.\n",
                        "willReplaceOnChanges": true
                    },
                    "settings": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "The settings map applicable for the backend, see official documentation for plugins.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The name of the repository backend (required plugins must be installed).\n"
                    }
                },
                "type": "object"
            }
        },
        "opensearch:index/user:User": {
            "description": "Provides an OpenSearch security user. Please refer to the OpenSearch Access Control documentation for details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@piclemx/pulumi-opensearch\";\n\n// Create a user\nconst mapper = new opensearch.User(\"mapper\", {\n    username: \"app-reasdder\",\n    password: \"SuperSekret123!\",\n    description: \"a reader role for our app\",\n});\n// And a full user, role and role mapping example:\nconst readerRole = new opensearch.Role(\"readerRole\", {\n    roleName: \"app_reader\",\n    description: \"App Reader Role\",\n    indexPermissions: [{\n        indexPatterns: [\"app-*\"],\n        allowedActions: [\n            \"get\",\n            \"read\",\n            \"search\",\n        ],\n    }],\n});\nconst readerUser = new opensearch.User(\"readerUser\", {\n    username: \"app-reader\",\n    password: _var.password,\n});\nconst readerRolesMapping = new opensearch.RolesMapping(\"readerRolesMapping\", {\n    roleName: readerRole.id,\n    description: \"App Reader Role\",\n    users: [readerUser.id],\n});\n```\n```python\nimport pulumi\nimport piclemx_pulumi_opensearch as opensearch\n\n# Create a user\nmapper = opensearch.User(\"mapper\",\n    username=\"app-reasdder\",\n    password=\"SuperSekret123!\",\n    description=\"a reader role for our app\")\n# And a full user, role and role mapping example:\nreader_role = opensearch.Role(\"readerRole\",\n    role_name=\"app_reader\",\n    description=\"App Reader Role\",\n    index_permissions=[opensearch.RoleIndexPermissionArgs(\n        index_patterns=[\"app-*\"],\n        allowed_actions=[\n            \"get\",\n            \"read\",\n            \"search\",\n        ],\n    )])\nreader_user = opensearch.User(\"readerUser\",\n    username=\"app-reader\",\n    password=var[\"password\"])\nreader_roles_mapping = opensearch.RolesMapping(\"readerRolesMapping\",\n    role_name=reader_role.id,\n    description=\"App Reader Role\",\n    users=[reader_user.id])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Piclemx.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create a user\n    var mapper = new Opensearch.User(\"mapper\", new()\n    {\n        Username = \"app-reasdder\",\n        Password = \"SuperSekret123!\",\n        Description = \"a reader role for our app\",\n    });\n\n    // And a full user, role and role mapping example:\n    var readerRole = new Opensearch.Role(\"readerRole\", new()\n    {\n        RoleName = \"app_reader\",\n        Description = \"App Reader Role\",\n        IndexPermissions = new[]\n        {\n            new Opensearch.Inputs.RoleIndexPermissionArgs\n            {\n                IndexPatterns = new[]\n                {\n                    \"app-*\",\n                },\n                AllowedActions = new[]\n                {\n                    \"get\",\n                    \"read\",\n                    \"search\",\n                },\n            },\n        },\n    });\n\n    var readerUser = new Opensearch.User(\"readerUser\", new()\n    {\n        Username = \"app-reader\",\n        Password = @var.Password,\n    });\n\n    var readerRolesMapping = new Opensearch.RolesMapping(\"readerRolesMapping\", new()\n    {\n        RoleName = readerRole.Id,\n        Description = \"App Reader Role\",\n        Users = new[]\n        {\n            readerUser.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.NewUser(ctx, \"mapper\", \u0026opensearch.UserArgs{\n\t\t\tUsername:    pulumi.String(\"app-reasdder\"),\n\t\t\tPassword:    pulumi.String(\"SuperSekret123!\"),\n\t\t\tDescription: pulumi.String(\"a reader role for our app\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treaderRole, err := opensearch.NewRole(ctx, \"readerRole\", \u0026opensearch.RoleArgs{\n\t\t\tRoleName:    pulumi.String(\"app_reader\"),\n\t\t\tDescription: pulumi.String(\"App Reader Role\"),\n\t\t\tIndexPermissions: opensearch.RoleIndexPermissionArray{\n\t\t\t\t\u0026opensearch.RoleIndexPermissionArgs{\n\t\t\t\t\tIndexPatterns: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"app-*\"),\n\t\t\t\t\t},\n\t\t\t\t\tAllowedActions: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"get\"),\n\t\t\t\t\t\tpulumi.String(\"read\"),\n\t\t\t\t\t\tpulumi.String(\"search\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treaderUser, err := opensearch.NewUser(ctx, \"readerUser\", \u0026opensearch.UserArgs{\n\t\t\tUsername: pulumi.String(\"app-reader\"),\n\t\t\tPassword: pulumi.Any(_var.Password),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = opensearch.NewRolesMapping(ctx, \"readerRolesMapping\", \u0026opensearch.RolesMappingArgs{\n\t\t\tRoleName:    readerRole.ID(),\n\t\t\tDescription: pulumi.String(\"App Reader Role\"),\n\t\t\tUsers: pulumi.StringArray{\n\t\t\t\treaderUser.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.User;\nimport com.pulumi.opensearch.UserArgs;\nimport com.pulumi.opensearch.Role;\nimport com.pulumi.opensearch.RoleArgs;\nimport com.pulumi.opensearch.inputs.RoleIndexPermissionArgs;\nimport com.pulumi.opensearch.RolesMapping;\nimport com.pulumi.opensearch.RolesMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var mapper = new User(\"mapper\", UserArgs.builder()        \n            .username(\"app-reasdder\")\n            .password(\"SuperSekret123!\")\n            .description(\"a reader role for our app\")\n            .build());\n\n        var readerRole = new Role(\"readerRole\", RoleArgs.builder()        \n            .roleName(\"app_reader\")\n            .description(\"App Reader Role\")\n            .indexPermissions(RoleIndexPermissionArgs.builder()\n                .indexPatterns(\"app-*\")\n                .allowedActions(                \n                    \"get\",\n                    \"read\",\n                    \"search\")\n                .build())\n            .build());\n\n        var readerUser = new User(\"readerUser\", UserArgs.builder()        \n            .username(\"app-reader\")\n            .password(var_.password())\n            .build());\n\n        var readerRolesMapping = new RolesMapping(\"readerRolesMapping\", RolesMappingArgs.builder()        \n            .roleName(readerRole.id())\n            .description(\"App Reader Role\")\n            .users(readerUser.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create a user\n  mapper:\n    type: opensearch:User\n    properties:\n      username: app-reasdder\n      password: SuperSekret123!\n      description: a reader role for our app\n  # And a full user, role and role mapping example:\n  readerRole:\n    type: opensearch:Role\n    properties:\n      roleName: app_reader\n      description: App Reader Role\n      indexPermissions:\n        - indexPatterns:\n            - app-*\n          allowedActions:\n            - get\n            - read\n            - search\n  readerUser:\n    type: opensearch:User\n    properties:\n      username: app-reader\n      password: ${var.password}\n  readerRolesMapping:\n    type: opensearch:RolesMapping\n    properties:\n      roleName: ${readerRole.id}\n      description: App Reader Role\n      users:\n        - ${readerUser.id}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import opensearch:index/user:User reader app_reader\n```\n\n ",
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of arbitrary key value string pairs stored alongside of users.\n"
                },
                "backendRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of backend roles.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The plain text password for the user, cannot be specified with `password_hash`. Some implementations may enforce a password policy. Invalid passwords may cause a non-descriptive HTTP 400 Bad Request error. For AWS OpenSearch domains \"password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one digit, and one special character\".\n",
                    "secret": true
                },
                "passwordHash": {
                    "type": "string",
                    "description": "The pre-hashed password for the user, cannot be specified with `password`.\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The name of the security user.\n"
                }
            },
            "required": [
                "username"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of arbitrary key value string pairs stored alongside of users.\n"
                },
                "backendRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of backend roles.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the user.\n"
                },
                "password": {
                    "type": "string",
                    "description": "The plain text password for the user, cannot be specified with `password_hash`. Some implementations may enforce a password policy. Invalid passwords may cause a non-descriptive HTTP 400 Bad Request error. For AWS OpenSearch domains \"password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one digit, and one special character\".\n",
                    "secret": true
                },
                "passwordHash": {
                    "type": "string",
                    "description": "The pre-hashed password for the user, cannot be specified with `password`.\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "The name of the security user.\n"
                }
            },
            "requiredInputs": [
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of arbitrary key value string pairs stored alongside of users.\n"
                    },
                    "backendRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of backend roles.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the user.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "The plain text password for the user, cannot be specified with `password_hash`. Some implementations may enforce a password policy. Invalid passwords may cause a non-descriptive HTTP 400 Bad Request error. For AWS OpenSearch domains \"password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one digit, and one special character\".\n",
                        "secret": true
                    },
                    "passwordHash": {
                        "type": "string",
                        "description": "The pre-hashed password for the user, cannot be specified with `password`.\n",
                        "secret": true
                    },
                    "username": {
                        "type": "string",
                        "description": "The name of the security user.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "opensearch:index/getHost:getHost": {
            "description": "`opensearch.getHost` can be used to retrieve the host URL for the provider's current cluster.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as opensearch from \"@pulumi/opensearch\";\n\nconst test = opensearch.getHost({\n    active: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_opensearch as opensearch\n\ntest = opensearch.get_host(active=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Opensearch = Pulumi.Opensearch;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Opensearch.GetHost.Invoke(new()\n    {\n        Active = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := opensearch.GetHost(ctx, \u0026opensearch.GetHostArgs{\n\t\t\tActive: true,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.opensearch.OpensearchFunctions;\nimport com.pulumi.opensearch.inputs.GetHostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = OpensearchFunctions.getHost(GetHostArgs.builder()\n            .active(true)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: opensearch:getHost\n      Arguments:\n        active: true\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getHost.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "should be set to `true`\n"
                    }
                },
                "type": "object",
                "required": [
                    "active"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHost.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "should be set to `true`\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "the url of the active cluster\n"
                    }
                },
                "type": "object",
                "required": [
                    "active",
                    "url",
                    "id"
                ]
            }
        }
    }
}