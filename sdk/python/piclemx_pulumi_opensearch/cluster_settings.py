# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = ['ClusterSettingsArgs', 'ClusterSettings']

@pulumi.input_type
class ClusterSettingsArgs:
    def __init__(__self__, *,
                 action_auto_create_index: Optional[pulumi.Input[str]] = None,
                 action_destructive_requires_name: Optional[pulumi.Input[bool]] = None,
                 cluster_blocks_read_only: Optional[pulumi.Input[bool]] = None,
                 cluster_blocks_read_only_allow_delete: Optional[pulumi.Input[bool]] = None,
                 cluster_indices_close_enable: Optional[pulumi.Input[bool]] = None,
                 cluster_info_update_interval: Optional[pulumi.Input[str]] = None,
                 cluster_max_shards_per_node: Optional[pulumi.Input[int]] = None,
                 cluster_max_shards_per_node_frozen: Optional[pulumi.Input[int]] = None,
                 cluster_no_master_block: Optional[pulumi.Input[str]] = None,
                 cluster_persistent_tasks_allocation_enable: Optional[pulumi.Input[str]] = None,
                 cluster_persistent_tasks_allocation_recheck_interval: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_allow_rebalance: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_awareness_attributes: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_balance_index: Optional[pulumi.Input[float]] = None,
                 cluster_routing_allocation_balance_shard: Optional[pulumi.Input[float]] = None,
                 cluster_routing_allocation_balance_threshold: Optional[pulumi.Input[float]] = None,
                 cluster_routing_allocation_cluster_concurrent_rebalance: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_disk_include_relocations: Optional[pulumi.Input[bool]] = None,
                 cluster_routing_allocation_disk_threshold_enabled: Optional[pulumi.Input[bool]] = None,
                 cluster_routing_allocation_disk_watermark_high: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_disk_watermark_low: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_enable: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_node_concurrent_incoming_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_node_concurrent_outgoing_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_node_concurrent_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_node_initial_primaries_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_same_shard_host: Optional[pulumi.Input[bool]] = None,
                 cluster_routing_allocation_total_shards_per_node: Optional[pulumi.Input[int]] = None,
                 cluster_routing_rebalance_enable: Optional[pulumi.Input[str]] = None,
                 indices_breaker_fielddata_limit: Optional[pulumi.Input[str]] = None,
                 indices_breaker_fielddata_overhead: Optional[pulumi.Input[float]] = None,
                 indices_breaker_request_limit: Optional[pulumi.Input[str]] = None,
                 indices_breaker_request_overhead: Optional[pulumi.Input[float]] = None,
                 indices_breaker_total_limit: Optional[pulumi.Input[str]] = None,
                 indices_recovery_max_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 network_breaker_inflight_requests_limit: Optional[pulumi.Input[str]] = None,
                 network_breaker_inflight_requests_overhead: Optional[pulumi.Input[float]] = None,
                 script_max_compilations_rate: Optional[pulumi.Input[str]] = None,
                 search_default_search_timeout: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a ClusterSettings resource.
        :param pulumi.Input[str] action_auto_create_index: Whether to automatically create an index if it doesn’t already exist and apply any configured index template
        :param pulumi.Input[bool] action_destructive_requires_name: When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
        :param pulumi.Input[bool] cluster_blocks_read_only: Make the whole cluster read only and metadata is not allowed to be modified
        :param pulumi.Input[bool] cluster_blocks_read_only_allow_delete: Make the whole cluster read only, but allows to delete indices to free up resources
        :param pulumi.Input[bool] cluster_indices_close_enable: If false, you cannot close open indices
        :param pulumi.Input[str] cluster_info_update_interval: A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
        :param pulumi.Input[int] cluster_max_shards_per_node: The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
        :param pulumi.Input[int] cluster_max_shards_per_node_frozen: The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
        :param pulumi.Input[str] cluster_no_master_block: Specifies which operations are rejected when there is no active master in a cluster (all, write)
        :param pulumi.Input[str] cluster_persistent_tasks_allocation_enable: Whether allocation for persistent tasks is active (all, none)
        :param pulumi.Input[str] cluster_persistent_tasks_allocation_recheck_interval: A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
        :param pulumi.Input[str] cluster_routing_allocation_allow_rebalance: Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)
        :param pulumi.Input[str] cluster_routing_allocation_awareness_attributes: Use custom node attributes to take hardware configuration into account when allocating shards
        :param pulumi.Input[float] cluster_routing_allocation_balance_index: Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
        :param pulumi.Input[float] cluster_routing_allocation_balance_shard: Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
        :param pulumi.Input[float] cluster_routing_allocation_balance_threshold: Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
        :param pulumi.Input[int] cluster_routing_allocation_cluster_concurrent_rebalance: How many concurrent shard rebalances are allowed cluster wide
        :param pulumi.Input[bool] cluster_routing_allocation_disk_include_relocations: Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
        :param pulumi.Input[bool] cluster_routing_allocation_disk_threshold_enabled: Whether the disk allocation decider is active
        :param pulumi.Input[str] cluster_routing_allocation_disk_watermark_high: Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
        :param pulumi.Input[str] cluster_routing_allocation_disk_watermark_low: Allocator will not allocate shards to nodes that have more than this percentage disk used
        :param pulumi.Input[str] cluster_routing_allocation_enable: Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
        :param pulumi.Input[int] cluster_routing_allocation_node_concurrent_incoming_recoveries: How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
        :param pulumi.Input[int] cluster_routing_allocation_node_concurrent_outgoing_recoveries: How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
        :param pulumi.Input[int] cluster_routing_allocation_node_concurrent_recoveries: A shortcut to set both incoming and outgoing recoveries
        :param pulumi.Input[int] cluster_routing_allocation_node_initial_primaries_recoveries: Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
        :param pulumi.Input[bool] cluster_routing_allocation_same_shard_host: Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
        :param pulumi.Input[int] cluster_routing_allocation_total_shards_per_node: Maximum number of primary and replica shards allocated to each node
        :param pulumi.Input[str] cluster_routing_rebalance_enable: Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
        :param pulumi.Input[str] indices_breaker_fielddata_limit: The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
        :param pulumi.Input[float] indices_breaker_fielddata_overhead: A constant that all field data estimations are multiplied by
        :param pulumi.Input[str] indices_breaker_request_limit: The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
        :param pulumi.Input[float] indices_breaker_request_overhead: A constant that all request estimations are multiplied by
        :param pulumi.Input[str] indices_breaker_total_limit: The percentage of total amount of memory that can be used across all breakers
        :param pulumi.Input[str] indices_recovery_max_bytes_per_sec: Maximum total inbound and outbound recovery traffic for each node, in mb
        :param pulumi.Input[str] network_breaker_inflight_requests_limit: The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
        :param pulumi.Input[float] network_breaker_inflight_requests_overhead: A constant that all in flight requests estimations are multiplied by
        :param pulumi.Input[str] script_max_compilations_rate: Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
        :param pulumi.Input[str] search_default_search_timeout: A time string setting a cluster-wide default timeout for all search requests
        """
        if action_auto_create_index is not None:
            pulumi.set(__self__, "action_auto_create_index", action_auto_create_index)
        if action_destructive_requires_name is not None:
            pulumi.set(__self__, "action_destructive_requires_name", action_destructive_requires_name)
        if cluster_blocks_read_only is not None:
            pulumi.set(__self__, "cluster_blocks_read_only", cluster_blocks_read_only)
        if cluster_blocks_read_only_allow_delete is not None:
            pulumi.set(__self__, "cluster_blocks_read_only_allow_delete", cluster_blocks_read_only_allow_delete)
        if cluster_indices_close_enable is not None:
            pulumi.set(__self__, "cluster_indices_close_enable", cluster_indices_close_enable)
        if cluster_info_update_interval is not None:
            pulumi.set(__self__, "cluster_info_update_interval", cluster_info_update_interval)
        if cluster_max_shards_per_node is not None:
            pulumi.set(__self__, "cluster_max_shards_per_node", cluster_max_shards_per_node)
        if cluster_max_shards_per_node_frozen is not None:
            pulumi.set(__self__, "cluster_max_shards_per_node_frozen", cluster_max_shards_per_node_frozen)
        if cluster_no_master_block is not None:
            pulumi.set(__self__, "cluster_no_master_block", cluster_no_master_block)
        if cluster_persistent_tasks_allocation_enable is not None:
            pulumi.set(__self__, "cluster_persistent_tasks_allocation_enable", cluster_persistent_tasks_allocation_enable)
        if cluster_persistent_tasks_allocation_recheck_interval is not None:
            pulumi.set(__self__, "cluster_persistent_tasks_allocation_recheck_interval", cluster_persistent_tasks_allocation_recheck_interval)
        if cluster_routing_allocation_allow_rebalance is not None:
            pulumi.set(__self__, "cluster_routing_allocation_allow_rebalance", cluster_routing_allocation_allow_rebalance)
        if cluster_routing_allocation_awareness_attributes is not None:
            pulumi.set(__self__, "cluster_routing_allocation_awareness_attributes", cluster_routing_allocation_awareness_attributes)
        if cluster_routing_allocation_balance_index is not None:
            pulumi.set(__self__, "cluster_routing_allocation_balance_index", cluster_routing_allocation_balance_index)
        if cluster_routing_allocation_balance_shard is not None:
            pulumi.set(__self__, "cluster_routing_allocation_balance_shard", cluster_routing_allocation_balance_shard)
        if cluster_routing_allocation_balance_threshold is not None:
            pulumi.set(__self__, "cluster_routing_allocation_balance_threshold", cluster_routing_allocation_balance_threshold)
        if cluster_routing_allocation_cluster_concurrent_rebalance is not None:
            pulumi.set(__self__, "cluster_routing_allocation_cluster_concurrent_rebalance", cluster_routing_allocation_cluster_concurrent_rebalance)
        if cluster_routing_allocation_disk_include_relocations is not None:
            pulumi.set(__self__, "cluster_routing_allocation_disk_include_relocations", cluster_routing_allocation_disk_include_relocations)
        if cluster_routing_allocation_disk_threshold_enabled is not None:
            pulumi.set(__self__, "cluster_routing_allocation_disk_threshold_enabled", cluster_routing_allocation_disk_threshold_enabled)
        if cluster_routing_allocation_disk_watermark_high is not None:
            pulumi.set(__self__, "cluster_routing_allocation_disk_watermark_high", cluster_routing_allocation_disk_watermark_high)
        if cluster_routing_allocation_disk_watermark_low is not None:
            pulumi.set(__self__, "cluster_routing_allocation_disk_watermark_low", cluster_routing_allocation_disk_watermark_low)
        if cluster_routing_allocation_enable is not None:
            pulumi.set(__self__, "cluster_routing_allocation_enable", cluster_routing_allocation_enable)
        if cluster_routing_allocation_node_concurrent_incoming_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_concurrent_incoming_recoveries", cluster_routing_allocation_node_concurrent_incoming_recoveries)
        if cluster_routing_allocation_node_concurrent_outgoing_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_concurrent_outgoing_recoveries", cluster_routing_allocation_node_concurrent_outgoing_recoveries)
        if cluster_routing_allocation_node_concurrent_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_concurrent_recoveries", cluster_routing_allocation_node_concurrent_recoveries)
        if cluster_routing_allocation_node_initial_primaries_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_initial_primaries_recoveries", cluster_routing_allocation_node_initial_primaries_recoveries)
        if cluster_routing_allocation_same_shard_host is not None:
            pulumi.set(__self__, "cluster_routing_allocation_same_shard_host", cluster_routing_allocation_same_shard_host)
        if cluster_routing_allocation_total_shards_per_node is not None:
            pulumi.set(__self__, "cluster_routing_allocation_total_shards_per_node", cluster_routing_allocation_total_shards_per_node)
        if cluster_routing_rebalance_enable is not None:
            pulumi.set(__self__, "cluster_routing_rebalance_enable", cluster_routing_rebalance_enable)
        if indices_breaker_fielddata_limit is not None:
            pulumi.set(__self__, "indices_breaker_fielddata_limit", indices_breaker_fielddata_limit)
        if indices_breaker_fielddata_overhead is not None:
            pulumi.set(__self__, "indices_breaker_fielddata_overhead", indices_breaker_fielddata_overhead)
        if indices_breaker_request_limit is not None:
            pulumi.set(__self__, "indices_breaker_request_limit", indices_breaker_request_limit)
        if indices_breaker_request_overhead is not None:
            pulumi.set(__self__, "indices_breaker_request_overhead", indices_breaker_request_overhead)
        if indices_breaker_total_limit is not None:
            pulumi.set(__self__, "indices_breaker_total_limit", indices_breaker_total_limit)
        if indices_recovery_max_bytes_per_sec is not None:
            pulumi.set(__self__, "indices_recovery_max_bytes_per_sec", indices_recovery_max_bytes_per_sec)
        if network_breaker_inflight_requests_limit is not None:
            pulumi.set(__self__, "network_breaker_inflight_requests_limit", network_breaker_inflight_requests_limit)
        if network_breaker_inflight_requests_overhead is not None:
            pulumi.set(__self__, "network_breaker_inflight_requests_overhead", network_breaker_inflight_requests_overhead)
        if script_max_compilations_rate is not None:
            pulumi.set(__self__, "script_max_compilations_rate", script_max_compilations_rate)
        if search_default_search_timeout is not None:
            pulumi.set(__self__, "search_default_search_timeout", search_default_search_timeout)

    @property
    @pulumi.getter(name="actionAutoCreateIndex")
    def action_auto_create_index(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to automatically create an index if it doesn’t already exist and apply any configured index template
        """
        return pulumi.get(self, "action_auto_create_index")

    @action_auto_create_index.setter
    def action_auto_create_index(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_auto_create_index", value)

    @property
    @pulumi.getter(name="actionDestructiveRequiresName")
    def action_destructive_requires_name(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
        """
        return pulumi.get(self, "action_destructive_requires_name")

    @action_destructive_requires_name.setter
    def action_destructive_requires_name(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "action_destructive_requires_name", value)

    @property
    @pulumi.getter(name="clusterBlocksReadOnly")
    def cluster_blocks_read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Make the whole cluster read only and metadata is not allowed to be modified
        """
        return pulumi.get(self, "cluster_blocks_read_only")

    @cluster_blocks_read_only.setter
    def cluster_blocks_read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_blocks_read_only", value)

    @property
    @pulumi.getter(name="clusterBlocksReadOnlyAllowDelete")
    def cluster_blocks_read_only_allow_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Make the whole cluster read only, but allows to delete indices to free up resources
        """
        return pulumi.get(self, "cluster_blocks_read_only_allow_delete")

    @cluster_blocks_read_only_allow_delete.setter
    def cluster_blocks_read_only_allow_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_blocks_read_only_allow_delete", value)

    @property
    @pulumi.getter(name="clusterIndicesCloseEnable")
    def cluster_indices_close_enable(self) -> Optional[pulumi.Input[bool]]:
        """
        If false, you cannot close open indices
        """
        return pulumi.get(self, "cluster_indices_close_enable")

    @cluster_indices_close_enable.setter
    def cluster_indices_close_enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_indices_close_enable", value)

    @property
    @pulumi.getter(name="clusterInfoUpdateInterval")
    def cluster_info_update_interval(self) -> Optional[pulumi.Input[str]]:
        """
        A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
        """
        return pulumi.get(self, "cluster_info_update_interval")

    @cluster_info_update_interval.setter
    def cluster_info_update_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_info_update_interval", value)

    @property
    @pulumi.getter(name="clusterMaxShardsPerNode")
    def cluster_max_shards_per_node(self) -> Optional[pulumi.Input[int]]:
        """
        The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
        """
        return pulumi.get(self, "cluster_max_shards_per_node")

    @cluster_max_shards_per_node.setter
    def cluster_max_shards_per_node(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_max_shards_per_node", value)

    @property
    @pulumi.getter(name="clusterMaxShardsPerNodeFrozen")
    def cluster_max_shards_per_node_frozen(self) -> Optional[pulumi.Input[int]]:
        """
        The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
        """
        return pulumi.get(self, "cluster_max_shards_per_node_frozen")

    @cluster_max_shards_per_node_frozen.setter
    def cluster_max_shards_per_node_frozen(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_max_shards_per_node_frozen", value)

    @property
    @pulumi.getter(name="clusterNoMasterBlock")
    def cluster_no_master_block(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies which operations are rejected when there is no active master in a cluster (all, write)
        """
        return pulumi.get(self, "cluster_no_master_block")

    @cluster_no_master_block.setter
    def cluster_no_master_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_no_master_block", value)

    @property
    @pulumi.getter(name="clusterPersistentTasksAllocationEnable")
    def cluster_persistent_tasks_allocation_enable(self) -> Optional[pulumi.Input[str]]:
        """
        Whether allocation for persistent tasks is active (all, none)
        """
        return pulumi.get(self, "cluster_persistent_tasks_allocation_enable")

    @cluster_persistent_tasks_allocation_enable.setter
    def cluster_persistent_tasks_allocation_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_persistent_tasks_allocation_enable", value)

    @property
    @pulumi.getter(name="clusterPersistentTasksAllocationRecheckInterval")
    def cluster_persistent_tasks_allocation_recheck_interval(self) -> Optional[pulumi.Input[str]]:
        """
        A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
        """
        return pulumi.get(self, "cluster_persistent_tasks_allocation_recheck_interval")

    @cluster_persistent_tasks_allocation_recheck_interval.setter
    def cluster_persistent_tasks_allocation_recheck_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_persistent_tasks_allocation_recheck_interval", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationAllowRebalance")
    def cluster_routing_allocation_allow_rebalance(self) -> Optional[pulumi.Input[str]]:
        """
        Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)
        """
        return pulumi.get(self, "cluster_routing_allocation_allow_rebalance")

    @cluster_routing_allocation_allow_rebalance.setter
    def cluster_routing_allocation_allow_rebalance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_routing_allocation_allow_rebalance", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationAwarenessAttributes")
    def cluster_routing_allocation_awareness_attributes(self) -> Optional[pulumi.Input[str]]:
        """
        Use custom node attributes to take hardware configuration into account when allocating shards
        """
        return pulumi.get(self, "cluster_routing_allocation_awareness_attributes")

    @cluster_routing_allocation_awareness_attributes.setter
    def cluster_routing_allocation_awareness_attributes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_routing_allocation_awareness_attributes", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationBalanceIndex")
    def cluster_routing_allocation_balance_index(self) -> Optional[pulumi.Input[float]]:
        """
        Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
        """
        return pulumi.get(self, "cluster_routing_allocation_balance_index")

    @cluster_routing_allocation_balance_index.setter
    def cluster_routing_allocation_balance_index(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cluster_routing_allocation_balance_index", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationBalanceShard")
    def cluster_routing_allocation_balance_shard(self) -> Optional[pulumi.Input[float]]:
        """
        Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
        """
        return pulumi.get(self, "cluster_routing_allocation_balance_shard")

    @cluster_routing_allocation_balance_shard.setter
    def cluster_routing_allocation_balance_shard(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cluster_routing_allocation_balance_shard", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationBalanceThreshold")
    def cluster_routing_allocation_balance_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
        """
        return pulumi.get(self, "cluster_routing_allocation_balance_threshold")

    @cluster_routing_allocation_balance_threshold.setter
    def cluster_routing_allocation_balance_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cluster_routing_allocation_balance_threshold", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationClusterConcurrentRebalance")
    def cluster_routing_allocation_cluster_concurrent_rebalance(self) -> Optional[pulumi.Input[int]]:
        """
        How many concurrent shard rebalances are allowed cluster wide
        """
        return pulumi.get(self, "cluster_routing_allocation_cluster_concurrent_rebalance")

    @cluster_routing_allocation_cluster_concurrent_rebalance.setter
    def cluster_routing_allocation_cluster_concurrent_rebalance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_routing_allocation_cluster_concurrent_rebalance", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationDiskIncludeRelocations")
    def cluster_routing_allocation_disk_include_relocations(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
        """
        return pulumi.get(self, "cluster_routing_allocation_disk_include_relocations")

    @cluster_routing_allocation_disk_include_relocations.setter
    def cluster_routing_allocation_disk_include_relocations(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_routing_allocation_disk_include_relocations", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationDiskThresholdEnabled")
    def cluster_routing_allocation_disk_threshold_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the disk allocation decider is active
        """
        return pulumi.get(self, "cluster_routing_allocation_disk_threshold_enabled")

    @cluster_routing_allocation_disk_threshold_enabled.setter
    def cluster_routing_allocation_disk_threshold_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_routing_allocation_disk_threshold_enabled", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationDiskWatermarkHigh")
    def cluster_routing_allocation_disk_watermark_high(self) -> Optional[pulumi.Input[str]]:
        """
        Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
        """
        return pulumi.get(self, "cluster_routing_allocation_disk_watermark_high")

    @cluster_routing_allocation_disk_watermark_high.setter
    def cluster_routing_allocation_disk_watermark_high(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_routing_allocation_disk_watermark_high", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationDiskWatermarkLow")
    def cluster_routing_allocation_disk_watermark_low(self) -> Optional[pulumi.Input[str]]:
        """
        Allocator will not allocate shards to nodes that have more than this percentage disk used
        """
        return pulumi.get(self, "cluster_routing_allocation_disk_watermark_low")

    @cluster_routing_allocation_disk_watermark_low.setter
    def cluster_routing_allocation_disk_watermark_low(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_routing_allocation_disk_watermark_low", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationEnable")
    def cluster_routing_allocation_enable(self) -> Optional[pulumi.Input[str]]:
        """
        Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
        """
        return pulumi.get(self, "cluster_routing_allocation_enable")

    @cluster_routing_allocation_enable.setter
    def cluster_routing_allocation_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_routing_allocation_enable", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentIncomingRecoveries")
    def cluster_routing_allocation_node_concurrent_incoming_recoveries(self) -> Optional[pulumi.Input[int]]:
        """
        How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
        """
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_incoming_recoveries")

    @cluster_routing_allocation_node_concurrent_incoming_recoveries.setter
    def cluster_routing_allocation_node_concurrent_incoming_recoveries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_routing_allocation_node_concurrent_incoming_recoveries", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentOutgoingRecoveries")
    def cluster_routing_allocation_node_concurrent_outgoing_recoveries(self) -> Optional[pulumi.Input[int]]:
        """
        How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
        """
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_outgoing_recoveries")

    @cluster_routing_allocation_node_concurrent_outgoing_recoveries.setter
    def cluster_routing_allocation_node_concurrent_outgoing_recoveries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_routing_allocation_node_concurrent_outgoing_recoveries", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentRecoveries")
    def cluster_routing_allocation_node_concurrent_recoveries(self) -> Optional[pulumi.Input[int]]:
        """
        A shortcut to set both incoming and outgoing recoveries
        """
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_recoveries")

    @cluster_routing_allocation_node_concurrent_recoveries.setter
    def cluster_routing_allocation_node_concurrent_recoveries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_routing_allocation_node_concurrent_recoveries", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeInitialPrimariesRecoveries")
    def cluster_routing_allocation_node_initial_primaries_recoveries(self) -> Optional[pulumi.Input[int]]:
        """
        Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
        """
        return pulumi.get(self, "cluster_routing_allocation_node_initial_primaries_recoveries")

    @cluster_routing_allocation_node_initial_primaries_recoveries.setter
    def cluster_routing_allocation_node_initial_primaries_recoveries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_routing_allocation_node_initial_primaries_recoveries", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationSameShardHost")
    def cluster_routing_allocation_same_shard_host(self) -> Optional[pulumi.Input[bool]]:
        """
        Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
        """
        return pulumi.get(self, "cluster_routing_allocation_same_shard_host")

    @cluster_routing_allocation_same_shard_host.setter
    def cluster_routing_allocation_same_shard_host(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_routing_allocation_same_shard_host", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationTotalShardsPerNode")
    def cluster_routing_allocation_total_shards_per_node(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of primary and replica shards allocated to each node
        """
        return pulumi.get(self, "cluster_routing_allocation_total_shards_per_node")

    @cluster_routing_allocation_total_shards_per_node.setter
    def cluster_routing_allocation_total_shards_per_node(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_routing_allocation_total_shards_per_node", value)

    @property
    @pulumi.getter(name="clusterRoutingRebalanceEnable")
    def cluster_routing_rebalance_enable(self) -> Optional[pulumi.Input[str]]:
        """
        Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
        """
        return pulumi.get(self, "cluster_routing_rebalance_enable")

    @cluster_routing_rebalance_enable.setter
    def cluster_routing_rebalance_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_routing_rebalance_enable", value)

    @property
    @pulumi.getter(name="indicesBreakerFielddataLimit")
    def indices_breaker_fielddata_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
        """
        return pulumi.get(self, "indices_breaker_fielddata_limit")

    @indices_breaker_fielddata_limit.setter
    def indices_breaker_fielddata_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "indices_breaker_fielddata_limit", value)

    @property
    @pulumi.getter(name="indicesBreakerFielddataOverhead")
    def indices_breaker_fielddata_overhead(self) -> Optional[pulumi.Input[float]]:
        """
        A constant that all field data estimations are multiplied by
        """
        return pulumi.get(self, "indices_breaker_fielddata_overhead")

    @indices_breaker_fielddata_overhead.setter
    def indices_breaker_fielddata_overhead(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "indices_breaker_fielddata_overhead", value)

    @property
    @pulumi.getter(name="indicesBreakerRequestLimit")
    def indices_breaker_request_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
        """
        return pulumi.get(self, "indices_breaker_request_limit")

    @indices_breaker_request_limit.setter
    def indices_breaker_request_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "indices_breaker_request_limit", value)

    @property
    @pulumi.getter(name="indicesBreakerRequestOverhead")
    def indices_breaker_request_overhead(self) -> Optional[pulumi.Input[float]]:
        """
        A constant that all request estimations are multiplied by
        """
        return pulumi.get(self, "indices_breaker_request_overhead")

    @indices_breaker_request_overhead.setter
    def indices_breaker_request_overhead(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "indices_breaker_request_overhead", value)

    @property
    @pulumi.getter(name="indicesBreakerTotalLimit")
    def indices_breaker_total_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The percentage of total amount of memory that can be used across all breakers
        """
        return pulumi.get(self, "indices_breaker_total_limit")

    @indices_breaker_total_limit.setter
    def indices_breaker_total_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "indices_breaker_total_limit", value)

    @property
    @pulumi.getter(name="indicesRecoveryMaxBytesPerSec")
    def indices_recovery_max_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum total inbound and outbound recovery traffic for each node, in mb
        """
        return pulumi.get(self, "indices_recovery_max_bytes_per_sec")

    @indices_recovery_max_bytes_per_sec.setter
    def indices_recovery_max_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "indices_recovery_max_bytes_per_sec", value)

    @property
    @pulumi.getter(name="networkBreakerInflightRequestsLimit")
    def network_breaker_inflight_requests_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
        """
        return pulumi.get(self, "network_breaker_inflight_requests_limit")

    @network_breaker_inflight_requests_limit.setter
    def network_breaker_inflight_requests_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_breaker_inflight_requests_limit", value)

    @property
    @pulumi.getter(name="networkBreakerInflightRequestsOverhead")
    def network_breaker_inflight_requests_overhead(self) -> Optional[pulumi.Input[float]]:
        """
        A constant that all in flight requests estimations are multiplied by
        """
        return pulumi.get(self, "network_breaker_inflight_requests_overhead")

    @network_breaker_inflight_requests_overhead.setter
    def network_breaker_inflight_requests_overhead(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "network_breaker_inflight_requests_overhead", value)

    @property
    @pulumi.getter(name="scriptMaxCompilationsRate")
    def script_max_compilations_rate(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
        """
        return pulumi.get(self, "script_max_compilations_rate")

    @script_max_compilations_rate.setter
    def script_max_compilations_rate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script_max_compilations_rate", value)

    @property
    @pulumi.getter(name="searchDefaultSearchTimeout")
    def search_default_search_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        A time string setting a cluster-wide default timeout for all search requests
        """
        return pulumi.get(self, "search_default_search_timeout")

    @search_default_search_timeout.setter
    def search_default_search_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_default_search_timeout", value)


@pulumi.input_type
class _ClusterSettingsState:
    def __init__(__self__, *,
                 action_auto_create_index: Optional[pulumi.Input[str]] = None,
                 action_destructive_requires_name: Optional[pulumi.Input[bool]] = None,
                 cluster_blocks_read_only: Optional[pulumi.Input[bool]] = None,
                 cluster_blocks_read_only_allow_delete: Optional[pulumi.Input[bool]] = None,
                 cluster_indices_close_enable: Optional[pulumi.Input[bool]] = None,
                 cluster_info_update_interval: Optional[pulumi.Input[str]] = None,
                 cluster_max_shards_per_node: Optional[pulumi.Input[int]] = None,
                 cluster_max_shards_per_node_frozen: Optional[pulumi.Input[int]] = None,
                 cluster_no_master_block: Optional[pulumi.Input[str]] = None,
                 cluster_persistent_tasks_allocation_enable: Optional[pulumi.Input[str]] = None,
                 cluster_persistent_tasks_allocation_recheck_interval: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_allow_rebalance: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_awareness_attributes: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_balance_index: Optional[pulumi.Input[float]] = None,
                 cluster_routing_allocation_balance_shard: Optional[pulumi.Input[float]] = None,
                 cluster_routing_allocation_balance_threshold: Optional[pulumi.Input[float]] = None,
                 cluster_routing_allocation_cluster_concurrent_rebalance: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_disk_include_relocations: Optional[pulumi.Input[bool]] = None,
                 cluster_routing_allocation_disk_threshold_enabled: Optional[pulumi.Input[bool]] = None,
                 cluster_routing_allocation_disk_watermark_high: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_disk_watermark_low: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_enable: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_node_concurrent_incoming_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_node_concurrent_outgoing_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_node_concurrent_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_node_initial_primaries_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_same_shard_host: Optional[pulumi.Input[bool]] = None,
                 cluster_routing_allocation_total_shards_per_node: Optional[pulumi.Input[int]] = None,
                 cluster_routing_rebalance_enable: Optional[pulumi.Input[str]] = None,
                 indices_breaker_fielddata_limit: Optional[pulumi.Input[str]] = None,
                 indices_breaker_fielddata_overhead: Optional[pulumi.Input[float]] = None,
                 indices_breaker_request_limit: Optional[pulumi.Input[str]] = None,
                 indices_breaker_request_overhead: Optional[pulumi.Input[float]] = None,
                 indices_breaker_total_limit: Optional[pulumi.Input[str]] = None,
                 indices_recovery_max_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 network_breaker_inflight_requests_limit: Optional[pulumi.Input[str]] = None,
                 network_breaker_inflight_requests_overhead: Optional[pulumi.Input[float]] = None,
                 script_max_compilations_rate: Optional[pulumi.Input[str]] = None,
                 search_default_search_timeout: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering ClusterSettings resources.
        :param pulumi.Input[str] action_auto_create_index: Whether to automatically create an index if it doesn’t already exist and apply any configured index template
        :param pulumi.Input[bool] action_destructive_requires_name: When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
        :param pulumi.Input[bool] cluster_blocks_read_only: Make the whole cluster read only and metadata is not allowed to be modified
        :param pulumi.Input[bool] cluster_blocks_read_only_allow_delete: Make the whole cluster read only, but allows to delete indices to free up resources
        :param pulumi.Input[bool] cluster_indices_close_enable: If false, you cannot close open indices
        :param pulumi.Input[str] cluster_info_update_interval: A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
        :param pulumi.Input[int] cluster_max_shards_per_node: The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
        :param pulumi.Input[int] cluster_max_shards_per_node_frozen: The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
        :param pulumi.Input[str] cluster_no_master_block: Specifies which operations are rejected when there is no active master in a cluster (all, write)
        :param pulumi.Input[str] cluster_persistent_tasks_allocation_enable: Whether allocation for persistent tasks is active (all, none)
        :param pulumi.Input[str] cluster_persistent_tasks_allocation_recheck_interval: A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
        :param pulumi.Input[str] cluster_routing_allocation_allow_rebalance: Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)
        :param pulumi.Input[str] cluster_routing_allocation_awareness_attributes: Use custom node attributes to take hardware configuration into account when allocating shards
        :param pulumi.Input[float] cluster_routing_allocation_balance_index: Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
        :param pulumi.Input[float] cluster_routing_allocation_balance_shard: Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
        :param pulumi.Input[float] cluster_routing_allocation_balance_threshold: Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
        :param pulumi.Input[int] cluster_routing_allocation_cluster_concurrent_rebalance: How many concurrent shard rebalances are allowed cluster wide
        :param pulumi.Input[bool] cluster_routing_allocation_disk_include_relocations: Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
        :param pulumi.Input[bool] cluster_routing_allocation_disk_threshold_enabled: Whether the disk allocation decider is active
        :param pulumi.Input[str] cluster_routing_allocation_disk_watermark_high: Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
        :param pulumi.Input[str] cluster_routing_allocation_disk_watermark_low: Allocator will not allocate shards to nodes that have more than this percentage disk used
        :param pulumi.Input[str] cluster_routing_allocation_enable: Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
        :param pulumi.Input[int] cluster_routing_allocation_node_concurrent_incoming_recoveries: How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
        :param pulumi.Input[int] cluster_routing_allocation_node_concurrent_outgoing_recoveries: How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
        :param pulumi.Input[int] cluster_routing_allocation_node_concurrent_recoveries: A shortcut to set both incoming and outgoing recoveries
        :param pulumi.Input[int] cluster_routing_allocation_node_initial_primaries_recoveries: Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
        :param pulumi.Input[bool] cluster_routing_allocation_same_shard_host: Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
        :param pulumi.Input[int] cluster_routing_allocation_total_shards_per_node: Maximum number of primary and replica shards allocated to each node
        :param pulumi.Input[str] cluster_routing_rebalance_enable: Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
        :param pulumi.Input[str] indices_breaker_fielddata_limit: The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
        :param pulumi.Input[float] indices_breaker_fielddata_overhead: A constant that all field data estimations are multiplied by
        :param pulumi.Input[str] indices_breaker_request_limit: The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
        :param pulumi.Input[float] indices_breaker_request_overhead: A constant that all request estimations are multiplied by
        :param pulumi.Input[str] indices_breaker_total_limit: The percentage of total amount of memory that can be used across all breakers
        :param pulumi.Input[str] indices_recovery_max_bytes_per_sec: Maximum total inbound and outbound recovery traffic for each node, in mb
        :param pulumi.Input[str] network_breaker_inflight_requests_limit: The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
        :param pulumi.Input[float] network_breaker_inflight_requests_overhead: A constant that all in flight requests estimations are multiplied by
        :param pulumi.Input[str] script_max_compilations_rate: Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
        :param pulumi.Input[str] search_default_search_timeout: A time string setting a cluster-wide default timeout for all search requests
        """
        if action_auto_create_index is not None:
            pulumi.set(__self__, "action_auto_create_index", action_auto_create_index)
        if action_destructive_requires_name is not None:
            pulumi.set(__self__, "action_destructive_requires_name", action_destructive_requires_name)
        if cluster_blocks_read_only is not None:
            pulumi.set(__self__, "cluster_blocks_read_only", cluster_blocks_read_only)
        if cluster_blocks_read_only_allow_delete is not None:
            pulumi.set(__self__, "cluster_blocks_read_only_allow_delete", cluster_blocks_read_only_allow_delete)
        if cluster_indices_close_enable is not None:
            pulumi.set(__self__, "cluster_indices_close_enable", cluster_indices_close_enable)
        if cluster_info_update_interval is not None:
            pulumi.set(__self__, "cluster_info_update_interval", cluster_info_update_interval)
        if cluster_max_shards_per_node is not None:
            pulumi.set(__self__, "cluster_max_shards_per_node", cluster_max_shards_per_node)
        if cluster_max_shards_per_node_frozen is not None:
            pulumi.set(__self__, "cluster_max_shards_per_node_frozen", cluster_max_shards_per_node_frozen)
        if cluster_no_master_block is not None:
            pulumi.set(__self__, "cluster_no_master_block", cluster_no_master_block)
        if cluster_persistent_tasks_allocation_enable is not None:
            pulumi.set(__self__, "cluster_persistent_tasks_allocation_enable", cluster_persistent_tasks_allocation_enable)
        if cluster_persistent_tasks_allocation_recheck_interval is not None:
            pulumi.set(__self__, "cluster_persistent_tasks_allocation_recheck_interval", cluster_persistent_tasks_allocation_recheck_interval)
        if cluster_routing_allocation_allow_rebalance is not None:
            pulumi.set(__self__, "cluster_routing_allocation_allow_rebalance", cluster_routing_allocation_allow_rebalance)
        if cluster_routing_allocation_awareness_attributes is not None:
            pulumi.set(__self__, "cluster_routing_allocation_awareness_attributes", cluster_routing_allocation_awareness_attributes)
        if cluster_routing_allocation_balance_index is not None:
            pulumi.set(__self__, "cluster_routing_allocation_balance_index", cluster_routing_allocation_balance_index)
        if cluster_routing_allocation_balance_shard is not None:
            pulumi.set(__self__, "cluster_routing_allocation_balance_shard", cluster_routing_allocation_balance_shard)
        if cluster_routing_allocation_balance_threshold is not None:
            pulumi.set(__self__, "cluster_routing_allocation_balance_threshold", cluster_routing_allocation_balance_threshold)
        if cluster_routing_allocation_cluster_concurrent_rebalance is not None:
            pulumi.set(__self__, "cluster_routing_allocation_cluster_concurrent_rebalance", cluster_routing_allocation_cluster_concurrent_rebalance)
        if cluster_routing_allocation_disk_include_relocations is not None:
            pulumi.set(__self__, "cluster_routing_allocation_disk_include_relocations", cluster_routing_allocation_disk_include_relocations)
        if cluster_routing_allocation_disk_threshold_enabled is not None:
            pulumi.set(__self__, "cluster_routing_allocation_disk_threshold_enabled", cluster_routing_allocation_disk_threshold_enabled)
        if cluster_routing_allocation_disk_watermark_high is not None:
            pulumi.set(__self__, "cluster_routing_allocation_disk_watermark_high", cluster_routing_allocation_disk_watermark_high)
        if cluster_routing_allocation_disk_watermark_low is not None:
            pulumi.set(__self__, "cluster_routing_allocation_disk_watermark_low", cluster_routing_allocation_disk_watermark_low)
        if cluster_routing_allocation_enable is not None:
            pulumi.set(__self__, "cluster_routing_allocation_enable", cluster_routing_allocation_enable)
        if cluster_routing_allocation_node_concurrent_incoming_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_concurrent_incoming_recoveries", cluster_routing_allocation_node_concurrent_incoming_recoveries)
        if cluster_routing_allocation_node_concurrent_outgoing_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_concurrent_outgoing_recoveries", cluster_routing_allocation_node_concurrent_outgoing_recoveries)
        if cluster_routing_allocation_node_concurrent_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_concurrent_recoveries", cluster_routing_allocation_node_concurrent_recoveries)
        if cluster_routing_allocation_node_initial_primaries_recoveries is not None:
            pulumi.set(__self__, "cluster_routing_allocation_node_initial_primaries_recoveries", cluster_routing_allocation_node_initial_primaries_recoveries)
        if cluster_routing_allocation_same_shard_host is not None:
            pulumi.set(__self__, "cluster_routing_allocation_same_shard_host", cluster_routing_allocation_same_shard_host)
        if cluster_routing_allocation_total_shards_per_node is not None:
            pulumi.set(__self__, "cluster_routing_allocation_total_shards_per_node", cluster_routing_allocation_total_shards_per_node)
        if cluster_routing_rebalance_enable is not None:
            pulumi.set(__self__, "cluster_routing_rebalance_enable", cluster_routing_rebalance_enable)
        if indices_breaker_fielddata_limit is not None:
            pulumi.set(__self__, "indices_breaker_fielddata_limit", indices_breaker_fielddata_limit)
        if indices_breaker_fielddata_overhead is not None:
            pulumi.set(__self__, "indices_breaker_fielddata_overhead", indices_breaker_fielddata_overhead)
        if indices_breaker_request_limit is not None:
            pulumi.set(__self__, "indices_breaker_request_limit", indices_breaker_request_limit)
        if indices_breaker_request_overhead is not None:
            pulumi.set(__self__, "indices_breaker_request_overhead", indices_breaker_request_overhead)
        if indices_breaker_total_limit is not None:
            pulumi.set(__self__, "indices_breaker_total_limit", indices_breaker_total_limit)
        if indices_recovery_max_bytes_per_sec is not None:
            pulumi.set(__self__, "indices_recovery_max_bytes_per_sec", indices_recovery_max_bytes_per_sec)
        if network_breaker_inflight_requests_limit is not None:
            pulumi.set(__self__, "network_breaker_inflight_requests_limit", network_breaker_inflight_requests_limit)
        if network_breaker_inflight_requests_overhead is not None:
            pulumi.set(__self__, "network_breaker_inflight_requests_overhead", network_breaker_inflight_requests_overhead)
        if script_max_compilations_rate is not None:
            pulumi.set(__self__, "script_max_compilations_rate", script_max_compilations_rate)
        if search_default_search_timeout is not None:
            pulumi.set(__self__, "search_default_search_timeout", search_default_search_timeout)

    @property
    @pulumi.getter(name="actionAutoCreateIndex")
    def action_auto_create_index(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to automatically create an index if it doesn’t already exist and apply any configured index template
        """
        return pulumi.get(self, "action_auto_create_index")

    @action_auto_create_index.setter
    def action_auto_create_index(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_auto_create_index", value)

    @property
    @pulumi.getter(name="actionDestructiveRequiresName")
    def action_destructive_requires_name(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
        """
        return pulumi.get(self, "action_destructive_requires_name")

    @action_destructive_requires_name.setter
    def action_destructive_requires_name(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "action_destructive_requires_name", value)

    @property
    @pulumi.getter(name="clusterBlocksReadOnly")
    def cluster_blocks_read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Make the whole cluster read only and metadata is not allowed to be modified
        """
        return pulumi.get(self, "cluster_blocks_read_only")

    @cluster_blocks_read_only.setter
    def cluster_blocks_read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_blocks_read_only", value)

    @property
    @pulumi.getter(name="clusterBlocksReadOnlyAllowDelete")
    def cluster_blocks_read_only_allow_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Make the whole cluster read only, but allows to delete indices to free up resources
        """
        return pulumi.get(self, "cluster_blocks_read_only_allow_delete")

    @cluster_blocks_read_only_allow_delete.setter
    def cluster_blocks_read_only_allow_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_blocks_read_only_allow_delete", value)

    @property
    @pulumi.getter(name="clusterIndicesCloseEnable")
    def cluster_indices_close_enable(self) -> Optional[pulumi.Input[bool]]:
        """
        If false, you cannot close open indices
        """
        return pulumi.get(self, "cluster_indices_close_enable")

    @cluster_indices_close_enable.setter
    def cluster_indices_close_enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_indices_close_enable", value)

    @property
    @pulumi.getter(name="clusterInfoUpdateInterval")
    def cluster_info_update_interval(self) -> Optional[pulumi.Input[str]]:
        """
        A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
        """
        return pulumi.get(self, "cluster_info_update_interval")

    @cluster_info_update_interval.setter
    def cluster_info_update_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_info_update_interval", value)

    @property
    @pulumi.getter(name="clusterMaxShardsPerNode")
    def cluster_max_shards_per_node(self) -> Optional[pulumi.Input[int]]:
        """
        The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
        """
        return pulumi.get(self, "cluster_max_shards_per_node")

    @cluster_max_shards_per_node.setter
    def cluster_max_shards_per_node(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_max_shards_per_node", value)

    @property
    @pulumi.getter(name="clusterMaxShardsPerNodeFrozen")
    def cluster_max_shards_per_node_frozen(self) -> Optional[pulumi.Input[int]]:
        """
        The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
        """
        return pulumi.get(self, "cluster_max_shards_per_node_frozen")

    @cluster_max_shards_per_node_frozen.setter
    def cluster_max_shards_per_node_frozen(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_max_shards_per_node_frozen", value)

    @property
    @pulumi.getter(name="clusterNoMasterBlock")
    def cluster_no_master_block(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies which operations are rejected when there is no active master in a cluster (all, write)
        """
        return pulumi.get(self, "cluster_no_master_block")

    @cluster_no_master_block.setter
    def cluster_no_master_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_no_master_block", value)

    @property
    @pulumi.getter(name="clusterPersistentTasksAllocationEnable")
    def cluster_persistent_tasks_allocation_enable(self) -> Optional[pulumi.Input[str]]:
        """
        Whether allocation for persistent tasks is active (all, none)
        """
        return pulumi.get(self, "cluster_persistent_tasks_allocation_enable")

    @cluster_persistent_tasks_allocation_enable.setter
    def cluster_persistent_tasks_allocation_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_persistent_tasks_allocation_enable", value)

    @property
    @pulumi.getter(name="clusterPersistentTasksAllocationRecheckInterval")
    def cluster_persistent_tasks_allocation_recheck_interval(self) -> Optional[pulumi.Input[str]]:
        """
        A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
        """
        return pulumi.get(self, "cluster_persistent_tasks_allocation_recheck_interval")

    @cluster_persistent_tasks_allocation_recheck_interval.setter
    def cluster_persistent_tasks_allocation_recheck_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_persistent_tasks_allocation_recheck_interval", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationAllowRebalance")
    def cluster_routing_allocation_allow_rebalance(self) -> Optional[pulumi.Input[str]]:
        """
        Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)
        """
        return pulumi.get(self, "cluster_routing_allocation_allow_rebalance")

    @cluster_routing_allocation_allow_rebalance.setter
    def cluster_routing_allocation_allow_rebalance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_routing_allocation_allow_rebalance", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationAwarenessAttributes")
    def cluster_routing_allocation_awareness_attributes(self) -> Optional[pulumi.Input[str]]:
        """
        Use custom node attributes to take hardware configuration into account when allocating shards
        """
        return pulumi.get(self, "cluster_routing_allocation_awareness_attributes")

    @cluster_routing_allocation_awareness_attributes.setter
    def cluster_routing_allocation_awareness_attributes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_routing_allocation_awareness_attributes", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationBalanceIndex")
    def cluster_routing_allocation_balance_index(self) -> Optional[pulumi.Input[float]]:
        """
        Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
        """
        return pulumi.get(self, "cluster_routing_allocation_balance_index")

    @cluster_routing_allocation_balance_index.setter
    def cluster_routing_allocation_balance_index(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cluster_routing_allocation_balance_index", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationBalanceShard")
    def cluster_routing_allocation_balance_shard(self) -> Optional[pulumi.Input[float]]:
        """
        Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
        """
        return pulumi.get(self, "cluster_routing_allocation_balance_shard")

    @cluster_routing_allocation_balance_shard.setter
    def cluster_routing_allocation_balance_shard(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cluster_routing_allocation_balance_shard", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationBalanceThreshold")
    def cluster_routing_allocation_balance_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
        """
        return pulumi.get(self, "cluster_routing_allocation_balance_threshold")

    @cluster_routing_allocation_balance_threshold.setter
    def cluster_routing_allocation_balance_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cluster_routing_allocation_balance_threshold", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationClusterConcurrentRebalance")
    def cluster_routing_allocation_cluster_concurrent_rebalance(self) -> Optional[pulumi.Input[int]]:
        """
        How many concurrent shard rebalances are allowed cluster wide
        """
        return pulumi.get(self, "cluster_routing_allocation_cluster_concurrent_rebalance")

    @cluster_routing_allocation_cluster_concurrent_rebalance.setter
    def cluster_routing_allocation_cluster_concurrent_rebalance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_routing_allocation_cluster_concurrent_rebalance", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationDiskIncludeRelocations")
    def cluster_routing_allocation_disk_include_relocations(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
        """
        return pulumi.get(self, "cluster_routing_allocation_disk_include_relocations")

    @cluster_routing_allocation_disk_include_relocations.setter
    def cluster_routing_allocation_disk_include_relocations(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_routing_allocation_disk_include_relocations", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationDiskThresholdEnabled")
    def cluster_routing_allocation_disk_threshold_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the disk allocation decider is active
        """
        return pulumi.get(self, "cluster_routing_allocation_disk_threshold_enabled")

    @cluster_routing_allocation_disk_threshold_enabled.setter
    def cluster_routing_allocation_disk_threshold_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_routing_allocation_disk_threshold_enabled", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationDiskWatermarkHigh")
    def cluster_routing_allocation_disk_watermark_high(self) -> Optional[pulumi.Input[str]]:
        """
        Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
        """
        return pulumi.get(self, "cluster_routing_allocation_disk_watermark_high")

    @cluster_routing_allocation_disk_watermark_high.setter
    def cluster_routing_allocation_disk_watermark_high(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_routing_allocation_disk_watermark_high", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationDiskWatermarkLow")
    def cluster_routing_allocation_disk_watermark_low(self) -> Optional[pulumi.Input[str]]:
        """
        Allocator will not allocate shards to nodes that have more than this percentage disk used
        """
        return pulumi.get(self, "cluster_routing_allocation_disk_watermark_low")

    @cluster_routing_allocation_disk_watermark_low.setter
    def cluster_routing_allocation_disk_watermark_low(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_routing_allocation_disk_watermark_low", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationEnable")
    def cluster_routing_allocation_enable(self) -> Optional[pulumi.Input[str]]:
        """
        Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
        """
        return pulumi.get(self, "cluster_routing_allocation_enable")

    @cluster_routing_allocation_enable.setter
    def cluster_routing_allocation_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_routing_allocation_enable", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentIncomingRecoveries")
    def cluster_routing_allocation_node_concurrent_incoming_recoveries(self) -> Optional[pulumi.Input[int]]:
        """
        How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
        """
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_incoming_recoveries")

    @cluster_routing_allocation_node_concurrent_incoming_recoveries.setter
    def cluster_routing_allocation_node_concurrent_incoming_recoveries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_routing_allocation_node_concurrent_incoming_recoveries", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentOutgoingRecoveries")
    def cluster_routing_allocation_node_concurrent_outgoing_recoveries(self) -> Optional[pulumi.Input[int]]:
        """
        How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
        """
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_outgoing_recoveries")

    @cluster_routing_allocation_node_concurrent_outgoing_recoveries.setter
    def cluster_routing_allocation_node_concurrent_outgoing_recoveries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_routing_allocation_node_concurrent_outgoing_recoveries", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentRecoveries")
    def cluster_routing_allocation_node_concurrent_recoveries(self) -> Optional[pulumi.Input[int]]:
        """
        A shortcut to set both incoming and outgoing recoveries
        """
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_recoveries")

    @cluster_routing_allocation_node_concurrent_recoveries.setter
    def cluster_routing_allocation_node_concurrent_recoveries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_routing_allocation_node_concurrent_recoveries", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeInitialPrimariesRecoveries")
    def cluster_routing_allocation_node_initial_primaries_recoveries(self) -> Optional[pulumi.Input[int]]:
        """
        Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
        """
        return pulumi.get(self, "cluster_routing_allocation_node_initial_primaries_recoveries")

    @cluster_routing_allocation_node_initial_primaries_recoveries.setter
    def cluster_routing_allocation_node_initial_primaries_recoveries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_routing_allocation_node_initial_primaries_recoveries", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationSameShardHost")
    def cluster_routing_allocation_same_shard_host(self) -> Optional[pulumi.Input[bool]]:
        """
        Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
        """
        return pulumi.get(self, "cluster_routing_allocation_same_shard_host")

    @cluster_routing_allocation_same_shard_host.setter
    def cluster_routing_allocation_same_shard_host(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_routing_allocation_same_shard_host", value)

    @property
    @pulumi.getter(name="clusterRoutingAllocationTotalShardsPerNode")
    def cluster_routing_allocation_total_shards_per_node(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of primary and replica shards allocated to each node
        """
        return pulumi.get(self, "cluster_routing_allocation_total_shards_per_node")

    @cluster_routing_allocation_total_shards_per_node.setter
    def cluster_routing_allocation_total_shards_per_node(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_routing_allocation_total_shards_per_node", value)

    @property
    @pulumi.getter(name="clusterRoutingRebalanceEnable")
    def cluster_routing_rebalance_enable(self) -> Optional[pulumi.Input[str]]:
        """
        Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
        """
        return pulumi.get(self, "cluster_routing_rebalance_enable")

    @cluster_routing_rebalance_enable.setter
    def cluster_routing_rebalance_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_routing_rebalance_enable", value)

    @property
    @pulumi.getter(name="indicesBreakerFielddataLimit")
    def indices_breaker_fielddata_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
        """
        return pulumi.get(self, "indices_breaker_fielddata_limit")

    @indices_breaker_fielddata_limit.setter
    def indices_breaker_fielddata_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "indices_breaker_fielddata_limit", value)

    @property
    @pulumi.getter(name="indicesBreakerFielddataOverhead")
    def indices_breaker_fielddata_overhead(self) -> Optional[pulumi.Input[float]]:
        """
        A constant that all field data estimations are multiplied by
        """
        return pulumi.get(self, "indices_breaker_fielddata_overhead")

    @indices_breaker_fielddata_overhead.setter
    def indices_breaker_fielddata_overhead(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "indices_breaker_fielddata_overhead", value)

    @property
    @pulumi.getter(name="indicesBreakerRequestLimit")
    def indices_breaker_request_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
        """
        return pulumi.get(self, "indices_breaker_request_limit")

    @indices_breaker_request_limit.setter
    def indices_breaker_request_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "indices_breaker_request_limit", value)

    @property
    @pulumi.getter(name="indicesBreakerRequestOverhead")
    def indices_breaker_request_overhead(self) -> Optional[pulumi.Input[float]]:
        """
        A constant that all request estimations are multiplied by
        """
        return pulumi.get(self, "indices_breaker_request_overhead")

    @indices_breaker_request_overhead.setter
    def indices_breaker_request_overhead(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "indices_breaker_request_overhead", value)

    @property
    @pulumi.getter(name="indicesBreakerTotalLimit")
    def indices_breaker_total_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The percentage of total amount of memory that can be used across all breakers
        """
        return pulumi.get(self, "indices_breaker_total_limit")

    @indices_breaker_total_limit.setter
    def indices_breaker_total_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "indices_breaker_total_limit", value)

    @property
    @pulumi.getter(name="indicesRecoveryMaxBytesPerSec")
    def indices_recovery_max_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum total inbound and outbound recovery traffic for each node, in mb
        """
        return pulumi.get(self, "indices_recovery_max_bytes_per_sec")

    @indices_recovery_max_bytes_per_sec.setter
    def indices_recovery_max_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "indices_recovery_max_bytes_per_sec", value)

    @property
    @pulumi.getter(name="networkBreakerInflightRequestsLimit")
    def network_breaker_inflight_requests_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
        """
        return pulumi.get(self, "network_breaker_inflight_requests_limit")

    @network_breaker_inflight_requests_limit.setter
    def network_breaker_inflight_requests_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_breaker_inflight_requests_limit", value)

    @property
    @pulumi.getter(name="networkBreakerInflightRequestsOverhead")
    def network_breaker_inflight_requests_overhead(self) -> Optional[pulumi.Input[float]]:
        """
        A constant that all in flight requests estimations are multiplied by
        """
        return pulumi.get(self, "network_breaker_inflight_requests_overhead")

    @network_breaker_inflight_requests_overhead.setter
    def network_breaker_inflight_requests_overhead(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "network_breaker_inflight_requests_overhead", value)

    @property
    @pulumi.getter(name="scriptMaxCompilationsRate")
    def script_max_compilations_rate(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
        """
        return pulumi.get(self, "script_max_compilations_rate")

    @script_max_compilations_rate.setter
    def script_max_compilations_rate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script_max_compilations_rate", value)

    @property
    @pulumi.getter(name="searchDefaultSearchTimeout")
    def search_default_search_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        A time string setting a cluster-wide default timeout for all search requests
        """
        return pulumi.get(self, "search_default_search_timeout")

    @search_default_search_timeout.setter
    def search_default_search_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_default_search_timeout", value)


class ClusterSettings(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 action_auto_create_index: Optional[pulumi.Input[str]] = None,
                 action_destructive_requires_name: Optional[pulumi.Input[bool]] = None,
                 cluster_blocks_read_only: Optional[pulumi.Input[bool]] = None,
                 cluster_blocks_read_only_allow_delete: Optional[pulumi.Input[bool]] = None,
                 cluster_indices_close_enable: Optional[pulumi.Input[bool]] = None,
                 cluster_info_update_interval: Optional[pulumi.Input[str]] = None,
                 cluster_max_shards_per_node: Optional[pulumi.Input[int]] = None,
                 cluster_max_shards_per_node_frozen: Optional[pulumi.Input[int]] = None,
                 cluster_no_master_block: Optional[pulumi.Input[str]] = None,
                 cluster_persistent_tasks_allocation_enable: Optional[pulumi.Input[str]] = None,
                 cluster_persistent_tasks_allocation_recheck_interval: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_allow_rebalance: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_awareness_attributes: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_balance_index: Optional[pulumi.Input[float]] = None,
                 cluster_routing_allocation_balance_shard: Optional[pulumi.Input[float]] = None,
                 cluster_routing_allocation_balance_threshold: Optional[pulumi.Input[float]] = None,
                 cluster_routing_allocation_cluster_concurrent_rebalance: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_disk_include_relocations: Optional[pulumi.Input[bool]] = None,
                 cluster_routing_allocation_disk_threshold_enabled: Optional[pulumi.Input[bool]] = None,
                 cluster_routing_allocation_disk_watermark_high: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_disk_watermark_low: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_enable: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_node_concurrent_incoming_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_node_concurrent_outgoing_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_node_concurrent_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_node_initial_primaries_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_same_shard_host: Optional[pulumi.Input[bool]] = None,
                 cluster_routing_allocation_total_shards_per_node: Optional[pulumi.Input[int]] = None,
                 cluster_routing_rebalance_enable: Optional[pulumi.Input[str]] = None,
                 indices_breaker_fielddata_limit: Optional[pulumi.Input[str]] = None,
                 indices_breaker_fielddata_overhead: Optional[pulumi.Input[float]] = None,
                 indices_breaker_request_limit: Optional[pulumi.Input[str]] = None,
                 indices_breaker_request_overhead: Optional[pulumi.Input[float]] = None,
                 indices_breaker_total_limit: Optional[pulumi.Input[str]] = None,
                 indices_recovery_max_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 network_breaker_inflight_requests_limit: Optional[pulumi.Input[str]] = None,
                 network_breaker_inflight_requests_overhead: Optional[pulumi.Input[float]] = None,
                 script_max_compilations_rate: Optional[pulumi.Input[str]] = None,
                 search_default_search_timeout: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        Manages a cluster's (persistent) settings.

        ## Example Usage

        ```python
        import pulumi
        import piclemx_pulumi_opensearch as opensearch

        global_ = opensearch.ClusterSettings("global",
            action_auto_create_index="my-index-000001,index10,-index1*,+ind*",
            cluster_max_shards_per_node=10)
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] action_auto_create_index: Whether to automatically create an index if it doesn’t already exist and apply any configured index template
        :param pulumi.Input[bool] action_destructive_requires_name: When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
        :param pulumi.Input[bool] cluster_blocks_read_only: Make the whole cluster read only and metadata is not allowed to be modified
        :param pulumi.Input[bool] cluster_blocks_read_only_allow_delete: Make the whole cluster read only, but allows to delete indices to free up resources
        :param pulumi.Input[bool] cluster_indices_close_enable: If false, you cannot close open indices
        :param pulumi.Input[str] cluster_info_update_interval: A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
        :param pulumi.Input[int] cluster_max_shards_per_node: The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
        :param pulumi.Input[int] cluster_max_shards_per_node_frozen: The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
        :param pulumi.Input[str] cluster_no_master_block: Specifies which operations are rejected when there is no active master in a cluster (all, write)
        :param pulumi.Input[str] cluster_persistent_tasks_allocation_enable: Whether allocation for persistent tasks is active (all, none)
        :param pulumi.Input[str] cluster_persistent_tasks_allocation_recheck_interval: A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
        :param pulumi.Input[str] cluster_routing_allocation_allow_rebalance: Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)
        :param pulumi.Input[str] cluster_routing_allocation_awareness_attributes: Use custom node attributes to take hardware configuration into account when allocating shards
        :param pulumi.Input[float] cluster_routing_allocation_balance_index: Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
        :param pulumi.Input[float] cluster_routing_allocation_balance_shard: Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
        :param pulumi.Input[float] cluster_routing_allocation_balance_threshold: Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
        :param pulumi.Input[int] cluster_routing_allocation_cluster_concurrent_rebalance: How many concurrent shard rebalances are allowed cluster wide
        :param pulumi.Input[bool] cluster_routing_allocation_disk_include_relocations: Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
        :param pulumi.Input[bool] cluster_routing_allocation_disk_threshold_enabled: Whether the disk allocation decider is active
        :param pulumi.Input[str] cluster_routing_allocation_disk_watermark_high: Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
        :param pulumi.Input[str] cluster_routing_allocation_disk_watermark_low: Allocator will not allocate shards to nodes that have more than this percentage disk used
        :param pulumi.Input[str] cluster_routing_allocation_enable: Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
        :param pulumi.Input[int] cluster_routing_allocation_node_concurrent_incoming_recoveries: How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
        :param pulumi.Input[int] cluster_routing_allocation_node_concurrent_outgoing_recoveries: How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
        :param pulumi.Input[int] cluster_routing_allocation_node_concurrent_recoveries: A shortcut to set both incoming and outgoing recoveries
        :param pulumi.Input[int] cluster_routing_allocation_node_initial_primaries_recoveries: Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
        :param pulumi.Input[bool] cluster_routing_allocation_same_shard_host: Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
        :param pulumi.Input[int] cluster_routing_allocation_total_shards_per_node: Maximum number of primary and replica shards allocated to each node
        :param pulumi.Input[str] cluster_routing_rebalance_enable: Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
        :param pulumi.Input[str] indices_breaker_fielddata_limit: The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
        :param pulumi.Input[float] indices_breaker_fielddata_overhead: A constant that all field data estimations are multiplied by
        :param pulumi.Input[str] indices_breaker_request_limit: The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
        :param pulumi.Input[float] indices_breaker_request_overhead: A constant that all request estimations are multiplied by
        :param pulumi.Input[str] indices_breaker_total_limit: The percentage of total amount of memory that can be used across all breakers
        :param pulumi.Input[str] indices_recovery_max_bytes_per_sec: Maximum total inbound and outbound recovery traffic for each node, in mb
        :param pulumi.Input[str] network_breaker_inflight_requests_limit: The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
        :param pulumi.Input[float] network_breaker_inflight_requests_overhead: A constant that all in flight requests estimations are multiplied by
        :param pulumi.Input[str] script_max_compilations_rate: Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
        :param pulumi.Input[str] search_default_search_timeout: A time string setting a cluster-wide default timeout for all search requests
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: Optional[ClusterSettingsArgs] = None,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Manages a cluster's (persistent) settings.

        ## Example Usage

        ```python
        import pulumi
        import piclemx_pulumi_opensearch as opensearch

        global_ = opensearch.ClusterSettings("global",
            action_auto_create_index="my-index-000001,index10,-index1*,+ind*",
            cluster_max_shards_per_node=10)
        ```

        :param str resource_name: The name of the resource.
        :param ClusterSettingsArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ClusterSettingsArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 action_auto_create_index: Optional[pulumi.Input[str]] = None,
                 action_destructive_requires_name: Optional[pulumi.Input[bool]] = None,
                 cluster_blocks_read_only: Optional[pulumi.Input[bool]] = None,
                 cluster_blocks_read_only_allow_delete: Optional[pulumi.Input[bool]] = None,
                 cluster_indices_close_enable: Optional[pulumi.Input[bool]] = None,
                 cluster_info_update_interval: Optional[pulumi.Input[str]] = None,
                 cluster_max_shards_per_node: Optional[pulumi.Input[int]] = None,
                 cluster_max_shards_per_node_frozen: Optional[pulumi.Input[int]] = None,
                 cluster_no_master_block: Optional[pulumi.Input[str]] = None,
                 cluster_persistent_tasks_allocation_enable: Optional[pulumi.Input[str]] = None,
                 cluster_persistent_tasks_allocation_recheck_interval: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_allow_rebalance: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_awareness_attributes: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_balance_index: Optional[pulumi.Input[float]] = None,
                 cluster_routing_allocation_balance_shard: Optional[pulumi.Input[float]] = None,
                 cluster_routing_allocation_balance_threshold: Optional[pulumi.Input[float]] = None,
                 cluster_routing_allocation_cluster_concurrent_rebalance: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_disk_include_relocations: Optional[pulumi.Input[bool]] = None,
                 cluster_routing_allocation_disk_threshold_enabled: Optional[pulumi.Input[bool]] = None,
                 cluster_routing_allocation_disk_watermark_high: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_disk_watermark_low: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_enable: Optional[pulumi.Input[str]] = None,
                 cluster_routing_allocation_node_concurrent_incoming_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_node_concurrent_outgoing_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_node_concurrent_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_node_initial_primaries_recoveries: Optional[pulumi.Input[int]] = None,
                 cluster_routing_allocation_same_shard_host: Optional[pulumi.Input[bool]] = None,
                 cluster_routing_allocation_total_shards_per_node: Optional[pulumi.Input[int]] = None,
                 cluster_routing_rebalance_enable: Optional[pulumi.Input[str]] = None,
                 indices_breaker_fielddata_limit: Optional[pulumi.Input[str]] = None,
                 indices_breaker_fielddata_overhead: Optional[pulumi.Input[float]] = None,
                 indices_breaker_request_limit: Optional[pulumi.Input[str]] = None,
                 indices_breaker_request_overhead: Optional[pulumi.Input[float]] = None,
                 indices_breaker_total_limit: Optional[pulumi.Input[str]] = None,
                 indices_recovery_max_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 network_breaker_inflight_requests_limit: Optional[pulumi.Input[str]] = None,
                 network_breaker_inflight_requests_overhead: Optional[pulumi.Input[float]] = None,
                 script_max_compilations_rate: Optional[pulumi.Input[str]] = None,
                 search_default_search_timeout: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ClusterSettingsArgs.__new__(ClusterSettingsArgs)

            __props__.__dict__["action_auto_create_index"] = action_auto_create_index
            __props__.__dict__["action_destructive_requires_name"] = action_destructive_requires_name
            __props__.__dict__["cluster_blocks_read_only"] = cluster_blocks_read_only
            __props__.__dict__["cluster_blocks_read_only_allow_delete"] = cluster_blocks_read_only_allow_delete
            __props__.__dict__["cluster_indices_close_enable"] = cluster_indices_close_enable
            __props__.__dict__["cluster_info_update_interval"] = cluster_info_update_interval
            __props__.__dict__["cluster_max_shards_per_node"] = cluster_max_shards_per_node
            __props__.__dict__["cluster_max_shards_per_node_frozen"] = cluster_max_shards_per_node_frozen
            __props__.__dict__["cluster_no_master_block"] = cluster_no_master_block
            __props__.__dict__["cluster_persistent_tasks_allocation_enable"] = cluster_persistent_tasks_allocation_enable
            __props__.__dict__["cluster_persistent_tasks_allocation_recheck_interval"] = cluster_persistent_tasks_allocation_recheck_interval
            __props__.__dict__["cluster_routing_allocation_allow_rebalance"] = cluster_routing_allocation_allow_rebalance
            __props__.__dict__["cluster_routing_allocation_awareness_attributes"] = cluster_routing_allocation_awareness_attributes
            __props__.__dict__["cluster_routing_allocation_balance_index"] = cluster_routing_allocation_balance_index
            __props__.__dict__["cluster_routing_allocation_balance_shard"] = cluster_routing_allocation_balance_shard
            __props__.__dict__["cluster_routing_allocation_balance_threshold"] = cluster_routing_allocation_balance_threshold
            __props__.__dict__["cluster_routing_allocation_cluster_concurrent_rebalance"] = cluster_routing_allocation_cluster_concurrent_rebalance
            __props__.__dict__["cluster_routing_allocation_disk_include_relocations"] = cluster_routing_allocation_disk_include_relocations
            __props__.__dict__["cluster_routing_allocation_disk_threshold_enabled"] = cluster_routing_allocation_disk_threshold_enabled
            __props__.__dict__["cluster_routing_allocation_disk_watermark_high"] = cluster_routing_allocation_disk_watermark_high
            __props__.__dict__["cluster_routing_allocation_disk_watermark_low"] = cluster_routing_allocation_disk_watermark_low
            __props__.__dict__["cluster_routing_allocation_enable"] = cluster_routing_allocation_enable
            __props__.__dict__["cluster_routing_allocation_node_concurrent_incoming_recoveries"] = cluster_routing_allocation_node_concurrent_incoming_recoveries
            __props__.__dict__["cluster_routing_allocation_node_concurrent_outgoing_recoveries"] = cluster_routing_allocation_node_concurrent_outgoing_recoveries
            __props__.__dict__["cluster_routing_allocation_node_concurrent_recoveries"] = cluster_routing_allocation_node_concurrent_recoveries
            __props__.__dict__["cluster_routing_allocation_node_initial_primaries_recoveries"] = cluster_routing_allocation_node_initial_primaries_recoveries
            __props__.__dict__["cluster_routing_allocation_same_shard_host"] = cluster_routing_allocation_same_shard_host
            __props__.__dict__["cluster_routing_allocation_total_shards_per_node"] = cluster_routing_allocation_total_shards_per_node
            __props__.__dict__["cluster_routing_rebalance_enable"] = cluster_routing_rebalance_enable
            __props__.__dict__["indices_breaker_fielddata_limit"] = indices_breaker_fielddata_limit
            __props__.__dict__["indices_breaker_fielddata_overhead"] = indices_breaker_fielddata_overhead
            __props__.__dict__["indices_breaker_request_limit"] = indices_breaker_request_limit
            __props__.__dict__["indices_breaker_request_overhead"] = indices_breaker_request_overhead
            __props__.__dict__["indices_breaker_total_limit"] = indices_breaker_total_limit
            __props__.__dict__["indices_recovery_max_bytes_per_sec"] = indices_recovery_max_bytes_per_sec
            __props__.__dict__["network_breaker_inflight_requests_limit"] = network_breaker_inflight_requests_limit
            __props__.__dict__["network_breaker_inflight_requests_overhead"] = network_breaker_inflight_requests_overhead
            __props__.__dict__["script_max_compilations_rate"] = script_max_compilations_rate
            __props__.__dict__["search_default_search_timeout"] = search_default_search_timeout
        super(ClusterSettings, __self__).__init__(
            'opensearch:index/clusterSettings:ClusterSettings',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            action_auto_create_index: Optional[pulumi.Input[str]] = None,
            action_destructive_requires_name: Optional[pulumi.Input[bool]] = None,
            cluster_blocks_read_only: Optional[pulumi.Input[bool]] = None,
            cluster_blocks_read_only_allow_delete: Optional[pulumi.Input[bool]] = None,
            cluster_indices_close_enable: Optional[pulumi.Input[bool]] = None,
            cluster_info_update_interval: Optional[pulumi.Input[str]] = None,
            cluster_max_shards_per_node: Optional[pulumi.Input[int]] = None,
            cluster_max_shards_per_node_frozen: Optional[pulumi.Input[int]] = None,
            cluster_no_master_block: Optional[pulumi.Input[str]] = None,
            cluster_persistent_tasks_allocation_enable: Optional[pulumi.Input[str]] = None,
            cluster_persistent_tasks_allocation_recheck_interval: Optional[pulumi.Input[str]] = None,
            cluster_routing_allocation_allow_rebalance: Optional[pulumi.Input[str]] = None,
            cluster_routing_allocation_awareness_attributes: Optional[pulumi.Input[str]] = None,
            cluster_routing_allocation_balance_index: Optional[pulumi.Input[float]] = None,
            cluster_routing_allocation_balance_shard: Optional[pulumi.Input[float]] = None,
            cluster_routing_allocation_balance_threshold: Optional[pulumi.Input[float]] = None,
            cluster_routing_allocation_cluster_concurrent_rebalance: Optional[pulumi.Input[int]] = None,
            cluster_routing_allocation_disk_include_relocations: Optional[pulumi.Input[bool]] = None,
            cluster_routing_allocation_disk_threshold_enabled: Optional[pulumi.Input[bool]] = None,
            cluster_routing_allocation_disk_watermark_high: Optional[pulumi.Input[str]] = None,
            cluster_routing_allocation_disk_watermark_low: Optional[pulumi.Input[str]] = None,
            cluster_routing_allocation_enable: Optional[pulumi.Input[str]] = None,
            cluster_routing_allocation_node_concurrent_incoming_recoveries: Optional[pulumi.Input[int]] = None,
            cluster_routing_allocation_node_concurrent_outgoing_recoveries: Optional[pulumi.Input[int]] = None,
            cluster_routing_allocation_node_concurrent_recoveries: Optional[pulumi.Input[int]] = None,
            cluster_routing_allocation_node_initial_primaries_recoveries: Optional[pulumi.Input[int]] = None,
            cluster_routing_allocation_same_shard_host: Optional[pulumi.Input[bool]] = None,
            cluster_routing_allocation_total_shards_per_node: Optional[pulumi.Input[int]] = None,
            cluster_routing_rebalance_enable: Optional[pulumi.Input[str]] = None,
            indices_breaker_fielddata_limit: Optional[pulumi.Input[str]] = None,
            indices_breaker_fielddata_overhead: Optional[pulumi.Input[float]] = None,
            indices_breaker_request_limit: Optional[pulumi.Input[str]] = None,
            indices_breaker_request_overhead: Optional[pulumi.Input[float]] = None,
            indices_breaker_total_limit: Optional[pulumi.Input[str]] = None,
            indices_recovery_max_bytes_per_sec: Optional[pulumi.Input[str]] = None,
            network_breaker_inflight_requests_limit: Optional[pulumi.Input[str]] = None,
            network_breaker_inflight_requests_overhead: Optional[pulumi.Input[float]] = None,
            script_max_compilations_rate: Optional[pulumi.Input[str]] = None,
            search_default_search_timeout: Optional[pulumi.Input[str]] = None) -> 'ClusterSettings':
        """
        Get an existing ClusterSettings resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] action_auto_create_index: Whether to automatically create an index if it doesn’t already exist and apply any configured index template
        :param pulumi.Input[bool] action_destructive_requires_name: When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
        :param pulumi.Input[bool] cluster_blocks_read_only: Make the whole cluster read only and metadata is not allowed to be modified
        :param pulumi.Input[bool] cluster_blocks_read_only_allow_delete: Make the whole cluster read only, but allows to delete indices to free up resources
        :param pulumi.Input[bool] cluster_indices_close_enable: If false, you cannot close open indices
        :param pulumi.Input[str] cluster_info_update_interval: A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
        :param pulumi.Input[int] cluster_max_shards_per_node: The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
        :param pulumi.Input[int] cluster_max_shards_per_node_frozen: The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
        :param pulumi.Input[str] cluster_no_master_block: Specifies which operations are rejected when there is no active master in a cluster (all, write)
        :param pulumi.Input[str] cluster_persistent_tasks_allocation_enable: Whether allocation for persistent tasks is active (all, none)
        :param pulumi.Input[str] cluster_persistent_tasks_allocation_recheck_interval: A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
        :param pulumi.Input[str] cluster_routing_allocation_allow_rebalance: Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)
        :param pulumi.Input[str] cluster_routing_allocation_awareness_attributes: Use custom node attributes to take hardware configuration into account when allocating shards
        :param pulumi.Input[float] cluster_routing_allocation_balance_index: Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
        :param pulumi.Input[float] cluster_routing_allocation_balance_shard: Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
        :param pulumi.Input[float] cluster_routing_allocation_balance_threshold: Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
        :param pulumi.Input[int] cluster_routing_allocation_cluster_concurrent_rebalance: How many concurrent shard rebalances are allowed cluster wide
        :param pulumi.Input[bool] cluster_routing_allocation_disk_include_relocations: Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
        :param pulumi.Input[bool] cluster_routing_allocation_disk_threshold_enabled: Whether the disk allocation decider is active
        :param pulumi.Input[str] cluster_routing_allocation_disk_watermark_high: Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
        :param pulumi.Input[str] cluster_routing_allocation_disk_watermark_low: Allocator will not allocate shards to nodes that have more than this percentage disk used
        :param pulumi.Input[str] cluster_routing_allocation_enable: Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
        :param pulumi.Input[int] cluster_routing_allocation_node_concurrent_incoming_recoveries: How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
        :param pulumi.Input[int] cluster_routing_allocation_node_concurrent_outgoing_recoveries: How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
        :param pulumi.Input[int] cluster_routing_allocation_node_concurrent_recoveries: A shortcut to set both incoming and outgoing recoveries
        :param pulumi.Input[int] cluster_routing_allocation_node_initial_primaries_recoveries: Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
        :param pulumi.Input[bool] cluster_routing_allocation_same_shard_host: Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
        :param pulumi.Input[int] cluster_routing_allocation_total_shards_per_node: Maximum number of primary and replica shards allocated to each node
        :param pulumi.Input[str] cluster_routing_rebalance_enable: Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
        :param pulumi.Input[str] indices_breaker_fielddata_limit: The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
        :param pulumi.Input[float] indices_breaker_fielddata_overhead: A constant that all field data estimations are multiplied by
        :param pulumi.Input[str] indices_breaker_request_limit: The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
        :param pulumi.Input[float] indices_breaker_request_overhead: A constant that all request estimations are multiplied by
        :param pulumi.Input[str] indices_breaker_total_limit: The percentage of total amount of memory that can be used across all breakers
        :param pulumi.Input[str] indices_recovery_max_bytes_per_sec: Maximum total inbound and outbound recovery traffic for each node, in mb
        :param pulumi.Input[str] network_breaker_inflight_requests_limit: The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
        :param pulumi.Input[float] network_breaker_inflight_requests_overhead: A constant that all in flight requests estimations are multiplied by
        :param pulumi.Input[str] script_max_compilations_rate: Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
        :param pulumi.Input[str] search_default_search_timeout: A time string setting a cluster-wide default timeout for all search requests
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ClusterSettingsState.__new__(_ClusterSettingsState)

        __props__.__dict__["action_auto_create_index"] = action_auto_create_index
        __props__.__dict__["action_destructive_requires_name"] = action_destructive_requires_name
        __props__.__dict__["cluster_blocks_read_only"] = cluster_blocks_read_only
        __props__.__dict__["cluster_blocks_read_only_allow_delete"] = cluster_blocks_read_only_allow_delete
        __props__.__dict__["cluster_indices_close_enable"] = cluster_indices_close_enable
        __props__.__dict__["cluster_info_update_interval"] = cluster_info_update_interval
        __props__.__dict__["cluster_max_shards_per_node"] = cluster_max_shards_per_node
        __props__.__dict__["cluster_max_shards_per_node_frozen"] = cluster_max_shards_per_node_frozen
        __props__.__dict__["cluster_no_master_block"] = cluster_no_master_block
        __props__.__dict__["cluster_persistent_tasks_allocation_enable"] = cluster_persistent_tasks_allocation_enable
        __props__.__dict__["cluster_persistent_tasks_allocation_recheck_interval"] = cluster_persistent_tasks_allocation_recheck_interval
        __props__.__dict__["cluster_routing_allocation_allow_rebalance"] = cluster_routing_allocation_allow_rebalance
        __props__.__dict__["cluster_routing_allocation_awareness_attributes"] = cluster_routing_allocation_awareness_attributes
        __props__.__dict__["cluster_routing_allocation_balance_index"] = cluster_routing_allocation_balance_index
        __props__.__dict__["cluster_routing_allocation_balance_shard"] = cluster_routing_allocation_balance_shard
        __props__.__dict__["cluster_routing_allocation_balance_threshold"] = cluster_routing_allocation_balance_threshold
        __props__.__dict__["cluster_routing_allocation_cluster_concurrent_rebalance"] = cluster_routing_allocation_cluster_concurrent_rebalance
        __props__.__dict__["cluster_routing_allocation_disk_include_relocations"] = cluster_routing_allocation_disk_include_relocations
        __props__.__dict__["cluster_routing_allocation_disk_threshold_enabled"] = cluster_routing_allocation_disk_threshold_enabled
        __props__.__dict__["cluster_routing_allocation_disk_watermark_high"] = cluster_routing_allocation_disk_watermark_high
        __props__.__dict__["cluster_routing_allocation_disk_watermark_low"] = cluster_routing_allocation_disk_watermark_low
        __props__.__dict__["cluster_routing_allocation_enable"] = cluster_routing_allocation_enable
        __props__.__dict__["cluster_routing_allocation_node_concurrent_incoming_recoveries"] = cluster_routing_allocation_node_concurrent_incoming_recoveries
        __props__.__dict__["cluster_routing_allocation_node_concurrent_outgoing_recoveries"] = cluster_routing_allocation_node_concurrent_outgoing_recoveries
        __props__.__dict__["cluster_routing_allocation_node_concurrent_recoveries"] = cluster_routing_allocation_node_concurrent_recoveries
        __props__.__dict__["cluster_routing_allocation_node_initial_primaries_recoveries"] = cluster_routing_allocation_node_initial_primaries_recoveries
        __props__.__dict__["cluster_routing_allocation_same_shard_host"] = cluster_routing_allocation_same_shard_host
        __props__.__dict__["cluster_routing_allocation_total_shards_per_node"] = cluster_routing_allocation_total_shards_per_node
        __props__.__dict__["cluster_routing_rebalance_enable"] = cluster_routing_rebalance_enable
        __props__.__dict__["indices_breaker_fielddata_limit"] = indices_breaker_fielddata_limit
        __props__.__dict__["indices_breaker_fielddata_overhead"] = indices_breaker_fielddata_overhead
        __props__.__dict__["indices_breaker_request_limit"] = indices_breaker_request_limit
        __props__.__dict__["indices_breaker_request_overhead"] = indices_breaker_request_overhead
        __props__.__dict__["indices_breaker_total_limit"] = indices_breaker_total_limit
        __props__.__dict__["indices_recovery_max_bytes_per_sec"] = indices_recovery_max_bytes_per_sec
        __props__.__dict__["network_breaker_inflight_requests_limit"] = network_breaker_inflight_requests_limit
        __props__.__dict__["network_breaker_inflight_requests_overhead"] = network_breaker_inflight_requests_overhead
        __props__.__dict__["script_max_compilations_rate"] = script_max_compilations_rate
        __props__.__dict__["search_default_search_timeout"] = search_default_search_timeout
        return ClusterSettings(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="actionAutoCreateIndex")
    def action_auto_create_index(self) -> pulumi.Output[Optional[str]]:
        """
        Whether to automatically create an index if it doesn’t already exist and apply any configured index template
        """
        return pulumi.get(self, "action_auto_create_index")

    @property
    @pulumi.getter(name="actionDestructiveRequiresName")
    def action_destructive_requires_name(self) -> pulumi.Output[Optional[bool]]:
        """
        When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
        """
        return pulumi.get(self, "action_destructive_requires_name")

    @property
    @pulumi.getter(name="clusterBlocksReadOnly")
    def cluster_blocks_read_only(self) -> pulumi.Output[Optional[bool]]:
        """
        Make the whole cluster read only and metadata is not allowed to be modified
        """
        return pulumi.get(self, "cluster_blocks_read_only")

    @property
    @pulumi.getter(name="clusterBlocksReadOnlyAllowDelete")
    def cluster_blocks_read_only_allow_delete(self) -> pulumi.Output[Optional[bool]]:
        """
        Make the whole cluster read only, but allows to delete indices to free up resources
        """
        return pulumi.get(self, "cluster_blocks_read_only_allow_delete")

    @property
    @pulumi.getter(name="clusterIndicesCloseEnable")
    def cluster_indices_close_enable(self) -> pulumi.Output[Optional[bool]]:
        """
        If false, you cannot close open indices
        """
        return pulumi.get(self, "cluster_indices_close_enable")

    @property
    @pulumi.getter(name="clusterInfoUpdateInterval")
    def cluster_info_update_interval(self) -> pulumi.Output[Optional[str]]:
        """
        A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
        """
        return pulumi.get(self, "cluster_info_update_interval")

    @property
    @pulumi.getter(name="clusterMaxShardsPerNode")
    def cluster_max_shards_per_node(self) -> pulumi.Output[Optional[int]]:
        """
        The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
        """
        return pulumi.get(self, "cluster_max_shards_per_node")

    @property
    @pulumi.getter(name="clusterMaxShardsPerNodeFrozen")
    def cluster_max_shards_per_node_frozen(self) -> pulumi.Output[Optional[int]]:
        """
        The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
        """
        return pulumi.get(self, "cluster_max_shards_per_node_frozen")

    @property
    @pulumi.getter(name="clusterNoMasterBlock")
    def cluster_no_master_block(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies which operations are rejected when there is no active master in a cluster (all, write)
        """
        return pulumi.get(self, "cluster_no_master_block")

    @property
    @pulumi.getter(name="clusterPersistentTasksAllocationEnable")
    def cluster_persistent_tasks_allocation_enable(self) -> pulumi.Output[Optional[str]]:
        """
        Whether allocation for persistent tasks is active (all, none)
        """
        return pulumi.get(self, "cluster_persistent_tasks_allocation_enable")

    @property
    @pulumi.getter(name="clusterPersistentTasksAllocationRecheckInterval")
    def cluster_persistent_tasks_allocation_recheck_interval(self) -> pulumi.Output[Optional[str]]:
        """
        A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
        """
        return pulumi.get(self, "cluster_persistent_tasks_allocation_recheck_interval")

    @property
    @pulumi.getter(name="clusterRoutingAllocationAllowRebalance")
    def cluster_routing_allocation_allow_rebalance(self) -> pulumi.Output[Optional[str]]:
        """
        Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)
        """
        return pulumi.get(self, "cluster_routing_allocation_allow_rebalance")

    @property
    @pulumi.getter(name="clusterRoutingAllocationAwarenessAttributes")
    def cluster_routing_allocation_awareness_attributes(self) -> pulumi.Output[Optional[str]]:
        """
        Use custom node attributes to take hardware configuration into account when allocating shards
        """
        return pulumi.get(self, "cluster_routing_allocation_awareness_attributes")

    @property
    @pulumi.getter(name="clusterRoutingAllocationBalanceIndex")
    def cluster_routing_allocation_balance_index(self) -> pulumi.Output[Optional[float]]:
        """
        Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
        """
        return pulumi.get(self, "cluster_routing_allocation_balance_index")

    @property
    @pulumi.getter(name="clusterRoutingAllocationBalanceShard")
    def cluster_routing_allocation_balance_shard(self) -> pulumi.Output[Optional[float]]:
        """
        Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
        """
        return pulumi.get(self, "cluster_routing_allocation_balance_shard")

    @property
    @pulumi.getter(name="clusterRoutingAllocationBalanceThreshold")
    def cluster_routing_allocation_balance_threshold(self) -> pulumi.Output[Optional[float]]:
        """
        Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
        """
        return pulumi.get(self, "cluster_routing_allocation_balance_threshold")

    @property
    @pulumi.getter(name="clusterRoutingAllocationClusterConcurrentRebalance")
    def cluster_routing_allocation_cluster_concurrent_rebalance(self) -> pulumi.Output[Optional[int]]:
        """
        How many concurrent shard rebalances are allowed cluster wide
        """
        return pulumi.get(self, "cluster_routing_allocation_cluster_concurrent_rebalance")

    @property
    @pulumi.getter(name="clusterRoutingAllocationDiskIncludeRelocations")
    def cluster_routing_allocation_disk_include_relocations(self) -> pulumi.Output[Optional[bool]]:
        """
        Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
        """
        return pulumi.get(self, "cluster_routing_allocation_disk_include_relocations")

    @property
    @pulumi.getter(name="clusterRoutingAllocationDiskThresholdEnabled")
    def cluster_routing_allocation_disk_threshold_enabled(self) -> pulumi.Output[Optional[bool]]:
        """
        Whether the disk allocation decider is active
        """
        return pulumi.get(self, "cluster_routing_allocation_disk_threshold_enabled")

    @property
    @pulumi.getter(name="clusterRoutingAllocationDiskWatermarkHigh")
    def cluster_routing_allocation_disk_watermark_high(self) -> pulumi.Output[Optional[str]]:
        """
        Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
        """
        return pulumi.get(self, "cluster_routing_allocation_disk_watermark_high")

    @property
    @pulumi.getter(name="clusterRoutingAllocationDiskWatermarkLow")
    def cluster_routing_allocation_disk_watermark_low(self) -> pulumi.Output[Optional[str]]:
        """
        Allocator will not allocate shards to nodes that have more than this percentage disk used
        """
        return pulumi.get(self, "cluster_routing_allocation_disk_watermark_low")

    @property
    @pulumi.getter(name="clusterRoutingAllocationEnable")
    def cluster_routing_allocation_enable(self) -> pulumi.Output[Optional[str]]:
        """
        Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
        """
        return pulumi.get(self, "cluster_routing_allocation_enable")

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentIncomingRecoveries")
    def cluster_routing_allocation_node_concurrent_incoming_recoveries(self) -> pulumi.Output[Optional[int]]:
        """
        How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
        """
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_incoming_recoveries")

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentOutgoingRecoveries")
    def cluster_routing_allocation_node_concurrent_outgoing_recoveries(self) -> pulumi.Output[Optional[int]]:
        """
        How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
        """
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_outgoing_recoveries")

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeConcurrentRecoveries")
    def cluster_routing_allocation_node_concurrent_recoveries(self) -> pulumi.Output[Optional[int]]:
        """
        A shortcut to set both incoming and outgoing recoveries
        """
        return pulumi.get(self, "cluster_routing_allocation_node_concurrent_recoveries")

    @property
    @pulumi.getter(name="clusterRoutingAllocationNodeInitialPrimariesRecoveries")
    def cluster_routing_allocation_node_initial_primaries_recoveries(self) -> pulumi.Output[Optional[int]]:
        """
        Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
        """
        return pulumi.get(self, "cluster_routing_allocation_node_initial_primaries_recoveries")

    @property
    @pulumi.getter(name="clusterRoutingAllocationSameShardHost")
    def cluster_routing_allocation_same_shard_host(self) -> pulumi.Output[Optional[bool]]:
        """
        Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
        """
        return pulumi.get(self, "cluster_routing_allocation_same_shard_host")

    @property
    @pulumi.getter(name="clusterRoutingAllocationTotalShardsPerNode")
    def cluster_routing_allocation_total_shards_per_node(self) -> pulumi.Output[Optional[int]]:
        """
        Maximum number of primary and replica shards allocated to each node
        """
        return pulumi.get(self, "cluster_routing_allocation_total_shards_per_node")

    @property
    @pulumi.getter(name="clusterRoutingRebalanceEnable")
    def cluster_routing_rebalance_enable(self) -> pulumi.Output[Optional[str]]:
        """
        Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
        """
        return pulumi.get(self, "cluster_routing_rebalance_enable")

    @property
    @pulumi.getter(name="indicesBreakerFielddataLimit")
    def indices_breaker_fielddata_limit(self) -> pulumi.Output[Optional[str]]:
        """
        The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
        """
        return pulumi.get(self, "indices_breaker_fielddata_limit")

    @property
    @pulumi.getter(name="indicesBreakerFielddataOverhead")
    def indices_breaker_fielddata_overhead(self) -> pulumi.Output[Optional[float]]:
        """
        A constant that all field data estimations are multiplied by
        """
        return pulumi.get(self, "indices_breaker_fielddata_overhead")

    @property
    @pulumi.getter(name="indicesBreakerRequestLimit")
    def indices_breaker_request_limit(self) -> pulumi.Output[Optional[str]]:
        """
        The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
        """
        return pulumi.get(self, "indices_breaker_request_limit")

    @property
    @pulumi.getter(name="indicesBreakerRequestOverhead")
    def indices_breaker_request_overhead(self) -> pulumi.Output[Optional[float]]:
        """
        A constant that all request estimations are multiplied by
        """
        return pulumi.get(self, "indices_breaker_request_overhead")

    @property
    @pulumi.getter(name="indicesBreakerTotalLimit")
    def indices_breaker_total_limit(self) -> pulumi.Output[Optional[str]]:
        """
        The percentage of total amount of memory that can be used across all breakers
        """
        return pulumi.get(self, "indices_breaker_total_limit")

    @property
    @pulumi.getter(name="indicesRecoveryMaxBytesPerSec")
    def indices_recovery_max_bytes_per_sec(self) -> pulumi.Output[Optional[str]]:
        """
        Maximum total inbound and outbound recovery traffic for each node, in mb
        """
        return pulumi.get(self, "indices_recovery_max_bytes_per_sec")

    @property
    @pulumi.getter(name="networkBreakerInflightRequestsLimit")
    def network_breaker_inflight_requests_limit(self) -> pulumi.Output[Optional[str]]:
        """
        The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
        """
        return pulumi.get(self, "network_breaker_inflight_requests_limit")

    @property
    @pulumi.getter(name="networkBreakerInflightRequestsOverhead")
    def network_breaker_inflight_requests_overhead(self) -> pulumi.Output[Optional[float]]:
        """
        A constant that all in flight requests estimations are multiplied by
        """
        return pulumi.get(self, "network_breaker_inflight_requests_overhead")

    @property
    @pulumi.getter(name="scriptMaxCompilationsRate")
    def script_max_compilations_rate(self) -> pulumi.Output[Optional[str]]:
        """
        Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
        """
        return pulumi.get(self, "script_max_compilations_rate")

    @property
    @pulumi.getter(name="searchDefaultSearchTimeout")
    def search_default_search_timeout(self) -> pulumi.Output[Optional[str]]:
        """
        A time string setting a cluster-wide default timeout for all search requests
        """
        return pulumi.get(self, "search_default_search_timeout")

