// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Piclemx.Opensearch
{
    /// <summary>
    /// Provides an OpenSearch index resource.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Opensearch = Piclemx.Opensearch;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     // Create a simple index
    ///     var test_simple_index = new Opensearch.Index("test-simple-index", new()
    ///     {
    ///         Mappings = @"{
    ///   ""properties"": {
    ///     ""name"": {
    ///       ""type"": ""text""
    ///     }
    ///   }
    /// }
    /// 
    /// ",
    ///         NumberOfReplicas = "1",
    ///         NumberOfShards = "1",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// Import by name
    /// 
    /// ```sh
    ///  $ pulumi import opensearch:index/index:Index test terraform-test
    /// ```
    /// </summary>
    [OpensearchResourceType("opensearch:index/index:Index")]
    public partial class Index : global::Pulumi.CustomResource
    {
        /// <summary>
        /// A JSON string describing a set of aliases. The index aliases API allows aliasing an index with a name, with all APIs automatically converting the alias name to the actual index name. An alias can also be mapped to more than one index, and when specifying it, the alias will automatically expand to the aliased indices.
        /// </summary>
        [Output("aliases")]
        public Output<string?> Aliases { get; private set; } = null!;

        /// <summary>
        /// A JSON string describing the analyzers applied to the index.
        /// </summary>
        [Output("analysisAnalyzer")]
        public Output<string?> AnalysisAnalyzer { get; private set; } = null!;

        /// <summary>
        /// A JSON string describing the char_filters applied to the index.
        /// </summary>
        [Output("analysisCharFilter")]
        public Output<string?> AnalysisCharFilter { get; private set; } = null!;

        /// <summary>
        /// A JSON string describing the filters applied to the index.
        /// </summary>
        [Output("analysisFilter")]
        public Output<string?> AnalysisFilter { get; private set; } = null!;

        /// <summary>
        /// A JSON string describing the normalizers applied to the index.
        /// </summary>
        [Output("analysisNormalizer")]
        public Output<string?> AnalysisNormalizer { get; private set; } = null!;

        /// <summary>
        /// A JSON string describing the tokenizers applied to the index.
        /// </summary>
        [Output("analysisTokenizer")]
        public Output<string?> AnalysisTokenizer { get; private set; } = null!;

        /// <summary>
        /// The maximum number of tokens that can be produced using _analyze API. A stringified number.
        /// </summary>
        [Output("analyzeMaxTokenCount")]
        public Output<string?> AnalyzeMaxTokenCount { get; private set; } = null!;

        /// <summary>
        /// Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all)
        /// </summary>
        [Output("autoExpandReplicas")]
        public Output<string?> AutoExpandReplicas { get; private set; } = null!;

        /// <summary>
        /// Set to `true` to disable index metadata reads and writes.
        /// </summary>
        [Output("blocksMetadata")]
        public Output<bool?> BlocksMetadata { get; private set; } = null!;

        /// <summary>
        /// Set to `true` to disable read operations against the index.
        /// </summary>
        [Output("blocksRead")]
        public Output<bool?> BlocksRead { get; private set; } = null!;

        /// <summary>
        /// Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.
        /// </summary>
        [Output("blocksReadOnly")]
        public Output<bool?> BlocksReadOnly { get; private set; } = null!;

        /// <summary>
        /// Identical to `index.blocks.read_only` but allows deleting the index to free up resources.
        /// </summary>
        [Output("blocksReadOnlyAllowDelete")]
        public Output<bool?> BlocksReadOnlyAllowDelete { get; private set; } = null!;

        /// <summary>
        /// Set to `true` to disable data write operations against the index. This setting does not affect metadata.
        /// </summary>
        [Output("blocksWrite")]
        public Output<bool?> BlocksWrite { get; private set; } = null!;

        /// <summary>
        /// The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses DEFLATE for a higher compression ratio. This can be set only on creation.
        /// </summary>
        [Output("codec")]
        public Output<string?> Codec { get; private set; } = null!;

        /// <summary>
        /// The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the pipeline does not exist.
        /// </summary>
        [Output("defaultPipeline")]
        public Output<string?> DefaultPipeline { get; private set; } = null!;

        /// <summary>
        /// A boolean that indicates that the index should be deleted even if it contains documents.
        /// </summary>
        [Output("forceDestroy")]
        public Output<bool?> ForceDestroy { get; private set; } = null!;

        /// <summary>
        /// The length of time that a deleted document's version number remains available for further versioned operations.
        /// </summary>
        [Output("gcDeletes")]
        public Output<string?> GcDeletes { get; private set; } = null!;

        /// <summary>
        /// The maximum number of characters that will be analyzed for a highlight request. A stringified number.
        /// </summary>
        [Output("highlightMaxAnalyzedOffset")]
        public Output<string?> HighlightMaxAnalyzedOffset { get; private set; } = null!;

        /// <summary>
        /// A string that indicates if and what we should pass to include*type*name parameter. Set to `"false"` when trying to create an index on a v6 cluster without a doc type or set to `"true"` when trying to create an index on a v7 cluster with a doc type. Since mapping updates are not currently supported, this applies only on index create.
        /// </summary>
        [Output("includeTypeName")]
        public Output<string?> IncludeTypeName { get; private set; } = null!;

        /// <summary>
        /// Indicates whether the index should build native library indices for the knn*vector fields. If set to false, the knn*vector fields will be stored in doc values, but Approximate k-NN search functionality will be disabled.
        /// </summary>
        [Output("indexKnn")]
        public Output<bool?> IndexKnn { get; private set; } = null!;

        /// <summary>
        /// The size of the dynamic list used during k-NN searches. Higher values lead to more accurate but slower searches. Only available for nmslib.
        /// </summary>
        [Output("indexKnnAlgoParamEfSearch")]
        public Output<string?> IndexKnnAlgoParamEfSearch { get; private set; } = null!;

        /// <summary>
        /// A JSON string describing the default index similarity config.
        /// </summary>
        [Output("indexSimilarityDefault")]
        public Output<string?> IndexSimilarityDefault { get; private set; } = null!;

        /// <summary>
        /// Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`
        /// </summary>
        [Output("indexingSlowlogLevel")]
        public Output<string?> IndexingSlowlogLevel { get; private set; } = null!;

        /// <summary>
        /// Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the source entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is reformatted by default to make sure that it fits on a single log line.
        /// </summary>
        [Output("indexingSlowlogSource")]
        public Output<string?> IndexingSlowlogSource { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`
        /// </summary>
        [Output("indexingSlowlogThresholdIndexDebug")]
        public Output<string?> IndexingSlowlogThresholdIndexDebug { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`
        /// </summary>
        [Output("indexingSlowlogThresholdIndexInfo")]
        public Output<string?> IndexingSlowlogThresholdIndexInfo { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`
        /// </summary>
        [Output("indexingSlowlogThresholdIndexTrace")]
        public Output<string?> IndexingSlowlogThresholdIndexTrace { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`
        /// </summary>
        [Output("indexingSlowlogThresholdIndexWarn")]
        public Output<string?> IndexingSlowlogThresholdIndexWarn { get; private set; } = null!;

        /// <summary>
        /// Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.
        /// </summary>
        [Output("loadFixedBitsetFiltersEagerly")]
        public Output<bool?> LoadFixedBitsetFiltersEagerly { get; private set; } = null!;

        /// <summary>
        /// A JSON string defining how documents in the index, and the fields they contain, are stored and indexed. To avoid the complexities of field mapping updates, updates of this field are not allowed via this provider.
        /// </summary>
        [Output("mappings")]
        public Output<string?> Mappings { get; private set; } = null!;

        /// <summary>
        /// The maximum number of `docvalue_fields` that are allowed in a query. A stringified number.
        /// </summary>
        [Output("maxDocvalueFieldsSearch")]
        public Output<string?> MaxDocvalueFieldsSearch { get; private set; } = null!;

        /// <summary>
        /// The maximum value of `from + size` for inner hits definition and top hits aggregations to this index. A stringified number.
        /// </summary>
        [Output("maxInnerResultWindow")]
        public Output<string?> MaxInnerResultWindow { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed difference between min*gram and max*gram for NGramTokenizer and NGramTokenFilter. A stringified number.
        /// </summary>
        [Output("maxNgramDiff")]
        public Output<string?> MaxNgramDiff { get; private set; } = null!;

        /// <summary>
        /// Maximum number of refresh listeners available on each shard of the index. A stringified number.
        /// </summary>
        [Output("maxRefreshListeners")]
        public Output<string?> MaxRefreshListeners { get; private set; } = null!;

        /// <summary>
        /// The maximum length of regex that can be used in Regexp Query. A stringified number.
        /// </summary>
        [Output("maxRegexLength")]
        public Output<string?> MaxRegexLength { get; private set; } = null!;

        /// <summary>
        /// The maximum value of `window_size` for `rescore` requests in searches of this index. A stringified number.
        /// </summary>
        [Output("maxRescoreWindow")]
        public Output<string?> MaxRescoreWindow { get; private set; } = null!;

        /// <summary>
        /// The maximum value of `from + size` for searches to this index. A stringified number.
        /// </summary>
        [Output("maxResultWindow")]
        public Output<string?> MaxResultWindow { get; private set; } = null!;

        /// <summary>
        /// The maximum number of `script_fields` that are allowed in a query. A stringified number.
        /// </summary>
        [Output("maxScriptFields")]
        public Output<string?> MaxScriptFields { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed difference between max*shingle*size and min*shingle*size for ShingleTokenFilter. A stringified number.
        /// </summary>
        [Output("maxShingleDiff")]
        public Output<string?> MaxShingleDiff { get; private set; } = null!;

        /// <summary>
        /// The maximum number of terms that can be used in Terms Query. A stringified number.
        /// </summary>
        [Output("maxTermsCount")]
        public Output<string?> MaxTermsCount { get; private set; } = null!;

        /// <summary>
        /// Name of the index to create
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Number of shard replicas. A stringified number.
        /// </summary>
        [Output("numberOfReplicas")]
        public Output<string> NumberOfReplicas { get; private set; } = null!;

        /// <summary>
        /// Value used with number*of*shards to route documents to a primary shard. A stringified number. This can be set only on creation.
        /// </summary>
        [Output("numberOfRoutingShards")]
        public Output<string?> NumberOfRoutingShards { get; private set; } = null!;

        /// <summary>
        /// Number of shards for the index. This can be set only on creation.
        /// </summary>
        [Output("numberOfShards")]
        public Output<string> NumberOfShards { get; private set; } = null!;

        /// <summary>
        /// How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1` to disable refresh.
        /// </summary>
        [Output("refreshInterval")]
        public Output<string?> RefreshInterval { get; private set; } = null!;

        [Output("rolloverAlias")]
        public Output<string> RolloverAlias { get; private set; } = null!;

        /// <summary>
        /// Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.
        /// </summary>
        [Output("routingAllocationEnable")]
        public Output<string?> RoutingAllocationEnable { get; private set; } = null!;

        /// <summary>
        /// The number of shards a custom routing value can go to. A stringified number. This can be set only on creation.
        /// </summary>
        [Output("routingPartitionSize")]
        public Output<string?> RoutingPartitionSize { get; private set; } = null!;

        /// <summary>
        /// Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.
        /// </summary>
        [Output("routingRebalanceEnable")]
        public Output<string?> RoutingRebalanceEnable { get; private set; } = null!;

        /// <summary>
        /// How long a shard can not receive a search or get request until it’s considered search idle.
        /// </summary>
        [Output("searchIdleAfter")]
        public Output<string?> SearchIdleAfter { get; private set; } = null!;

        /// <summary>
        /// Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`
        /// </summary>
        [Output("searchSlowlogLevel")]
        public Output<string?> SearchSlowlogLevel { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`
        /// </summary>
        [Output("searchSlowlogThresholdFetchDebug")]
        public Output<string?> SearchSlowlogThresholdFetchDebug { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`
        /// </summary>
        [Output("searchSlowlogThresholdFetchInfo")]
        public Output<string?> SearchSlowlogThresholdFetchInfo { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`
        /// </summary>
        [Output("searchSlowlogThresholdFetchTrace")]
        public Output<string?> SearchSlowlogThresholdFetchTrace { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`
        /// </summary>
        [Output("searchSlowlogThresholdFetchWarn")]
        public Output<string?> SearchSlowlogThresholdFetchWarn { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`
        /// </summary>
        [Output("searchSlowlogThresholdQueryDebug")]
        public Output<string?> SearchSlowlogThresholdQueryDebug { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`
        /// </summary>
        [Output("searchSlowlogThresholdQueryInfo")]
        public Output<string?> SearchSlowlogThresholdQueryInfo { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`
        /// </summary>
        [Output("searchSlowlogThresholdQueryTrace")]
        public Output<string?> SearchSlowlogThresholdQueryTrace { get; private set; } = null!;

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`
        /// </summary>
        [Output("searchSlowlogThresholdQueryWarn")]
        public Output<string?> SearchSlowlogThresholdQueryWarn { get; private set; } = null!;

        /// <summary>
        /// Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the shard from being opened. Accepts `false`, `true`, `checksum`.
        /// </summary>
        [Output("shardCheckOnStartup")]
        public Output<string?> ShardCheckOnStartup { get; private set; } = null!;

        /// <summary>
        /// The field to sort shards in this index by.
        /// </summary>
        [Output("sortField")]
        public Output<string?> SortField { get; private set; } = null!;

        /// <summary>
        /// The direction to sort shards in. Accepts `asc`, `desc`.
        /// </summary>
        [Output("sortOrder")]
        public Output<string?> SortOrder { get; private set; } = null!;


        /// <summary>
        /// Create a Index resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Index(string name, IndexArgs? args = null, CustomResourceOptions? options = null)
            : base("opensearch:index/index:Index", name, args ?? new IndexArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Index(string name, Input<string> id, IndexState? state = null, CustomResourceOptions? options = null)
            : base("opensearch:index/index:Index", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/piclemx/pulumi-opensearch",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Index resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Index Get(string name, Input<string> id, IndexState? state = null, CustomResourceOptions? options = null)
        {
            return new Index(name, id, state, options);
        }
    }

    public sealed class IndexArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// A JSON string describing a set of aliases. The index aliases API allows aliasing an index with a name, with all APIs automatically converting the alias name to the actual index name. An alias can also be mapped to more than one index, and when specifying it, the alias will automatically expand to the aliased indices.
        /// </summary>
        [Input("aliases")]
        public Input<string>? Aliases { get; set; }

        /// <summary>
        /// A JSON string describing the analyzers applied to the index.
        /// </summary>
        [Input("analysisAnalyzer")]
        public Input<string>? AnalysisAnalyzer { get; set; }

        /// <summary>
        /// A JSON string describing the char_filters applied to the index.
        /// </summary>
        [Input("analysisCharFilter")]
        public Input<string>? AnalysisCharFilter { get; set; }

        /// <summary>
        /// A JSON string describing the filters applied to the index.
        /// </summary>
        [Input("analysisFilter")]
        public Input<string>? AnalysisFilter { get; set; }

        /// <summary>
        /// A JSON string describing the normalizers applied to the index.
        /// </summary>
        [Input("analysisNormalizer")]
        public Input<string>? AnalysisNormalizer { get; set; }

        /// <summary>
        /// A JSON string describing the tokenizers applied to the index.
        /// </summary>
        [Input("analysisTokenizer")]
        public Input<string>? AnalysisTokenizer { get; set; }

        /// <summary>
        /// The maximum number of tokens that can be produced using _analyze API. A stringified number.
        /// </summary>
        [Input("analyzeMaxTokenCount")]
        public Input<string>? AnalyzeMaxTokenCount { get; set; }

        /// <summary>
        /// Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all)
        /// </summary>
        [Input("autoExpandReplicas")]
        public Input<string>? AutoExpandReplicas { get; set; }

        /// <summary>
        /// Set to `true` to disable index metadata reads and writes.
        /// </summary>
        [Input("blocksMetadata")]
        public Input<bool>? BlocksMetadata { get; set; }

        /// <summary>
        /// Set to `true` to disable read operations against the index.
        /// </summary>
        [Input("blocksRead")]
        public Input<bool>? BlocksRead { get; set; }

        /// <summary>
        /// Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.
        /// </summary>
        [Input("blocksReadOnly")]
        public Input<bool>? BlocksReadOnly { get; set; }

        /// <summary>
        /// Identical to `index.blocks.read_only` but allows deleting the index to free up resources.
        /// </summary>
        [Input("blocksReadOnlyAllowDelete")]
        public Input<bool>? BlocksReadOnlyAllowDelete { get; set; }

        /// <summary>
        /// Set to `true` to disable data write operations against the index. This setting does not affect metadata.
        /// </summary>
        [Input("blocksWrite")]
        public Input<bool>? BlocksWrite { get; set; }

        /// <summary>
        /// The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses DEFLATE for a higher compression ratio. This can be set only on creation.
        /// </summary>
        [Input("codec")]
        public Input<string>? Codec { get; set; }

        /// <summary>
        /// The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the pipeline does not exist.
        /// </summary>
        [Input("defaultPipeline")]
        public Input<string>? DefaultPipeline { get; set; }

        /// <summary>
        /// A boolean that indicates that the index should be deleted even if it contains documents.
        /// </summary>
        [Input("forceDestroy")]
        public Input<bool>? ForceDestroy { get; set; }

        /// <summary>
        /// The length of time that a deleted document's version number remains available for further versioned operations.
        /// </summary>
        [Input("gcDeletes")]
        public Input<string>? GcDeletes { get; set; }

        /// <summary>
        /// The maximum number of characters that will be analyzed for a highlight request. A stringified number.
        /// </summary>
        [Input("highlightMaxAnalyzedOffset")]
        public Input<string>? HighlightMaxAnalyzedOffset { get; set; }

        /// <summary>
        /// A string that indicates if and what we should pass to include*type*name parameter. Set to `"false"` when trying to create an index on a v6 cluster without a doc type or set to `"true"` when trying to create an index on a v7 cluster with a doc type. Since mapping updates are not currently supported, this applies only on index create.
        /// </summary>
        [Input("includeTypeName")]
        public Input<string>? IncludeTypeName { get; set; }

        /// <summary>
        /// Indicates whether the index should build native library indices for the knn*vector fields. If set to false, the knn*vector fields will be stored in doc values, but Approximate k-NN search functionality will be disabled.
        /// </summary>
        [Input("indexKnn")]
        public Input<bool>? IndexKnn { get; set; }

        /// <summary>
        /// The size of the dynamic list used during k-NN searches. Higher values lead to more accurate but slower searches. Only available for nmslib.
        /// </summary>
        [Input("indexKnnAlgoParamEfSearch")]
        public Input<string>? IndexKnnAlgoParamEfSearch { get; set; }

        /// <summary>
        /// A JSON string describing the default index similarity config.
        /// </summary>
        [Input("indexSimilarityDefault")]
        public Input<string>? IndexSimilarityDefault { get; set; }

        /// <summary>
        /// Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`
        /// </summary>
        [Input("indexingSlowlogLevel")]
        public Input<string>? IndexingSlowlogLevel { get; set; }

        /// <summary>
        /// Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the source entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is reformatted by default to make sure that it fits on a single log line.
        /// </summary>
        [Input("indexingSlowlogSource")]
        public Input<string>? IndexingSlowlogSource { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexDebug")]
        public Input<string>? IndexingSlowlogThresholdIndexDebug { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexInfo")]
        public Input<string>? IndexingSlowlogThresholdIndexInfo { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexTrace")]
        public Input<string>? IndexingSlowlogThresholdIndexTrace { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexWarn")]
        public Input<string>? IndexingSlowlogThresholdIndexWarn { get; set; }

        /// <summary>
        /// Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.
        /// </summary>
        [Input("loadFixedBitsetFiltersEagerly")]
        public Input<bool>? LoadFixedBitsetFiltersEagerly { get; set; }

        /// <summary>
        /// A JSON string defining how documents in the index, and the fields they contain, are stored and indexed. To avoid the complexities of field mapping updates, updates of this field are not allowed via this provider.
        /// </summary>
        [Input("mappings")]
        public Input<string>? Mappings { get; set; }

        /// <summary>
        /// The maximum number of `docvalue_fields` that are allowed in a query. A stringified number.
        /// </summary>
        [Input("maxDocvalueFieldsSearch")]
        public Input<string>? MaxDocvalueFieldsSearch { get; set; }

        /// <summary>
        /// The maximum value of `from + size` for inner hits definition and top hits aggregations to this index. A stringified number.
        /// </summary>
        [Input("maxInnerResultWindow")]
        public Input<string>? MaxInnerResultWindow { get; set; }

        /// <summary>
        /// The maximum allowed difference between min*gram and max*gram for NGramTokenizer and NGramTokenFilter. A stringified number.
        /// </summary>
        [Input("maxNgramDiff")]
        public Input<string>? MaxNgramDiff { get; set; }

        /// <summary>
        /// Maximum number of refresh listeners available on each shard of the index. A stringified number.
        /// </summary>
        [Input("maxRefreshListeners")]
        public Input<string>? MaxRefreshListeners { get; set; }

        /// <summary>
        /// The maximum length of regex that can be used in Regexp Query. A stringified number.
        /// </summary>
        [Input("maxRegexLength")]
        public Input<string>? MaxRegexLength { get; set; }

        /// <summary>
        /// The maximum value of `window_size` for `rescore` requests in searches of this index. A stringified number.
        /// </summary>
        [Input("maxRescoreWindow")]
        public Input<string>? MaxRescoreWindow { get; set; }

        /// <summary>
        /// The maximum value of `from + size` for searches to this index. A stringified number.
        /// </summary>
        [Input("maxResultWindow")]
        public Input<string>? MaxResultWindow { get; set; }

        /// <summary>
        /// The maximum number of `script_fields` that are allowed in a query. A stringified number.
        /// </summary>
        [Input("maxScriptFields")]
        public Input<string>? MaxScriptFields { get; set; }

        /// <summary>
        /// The maximum allowed difference between max*shingle*size and min*shingle*size for ShingleTokenFilter. A stringified number.
        /// </summary>
        [Input("maxShingleDiff")]
        public Input<string>? MaxShingleDiff { get; set; }

        /// <summary>
        /// The maximum number of terms that can be used in Terms Query. A stringified number.
        /// </summary>
        [Input("maxTermsCount")]
        public Input<string>? MaxTermsCount { get; set; }

        /// <summary>
        /// Name of the index to create
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Number of shard replicas. A stringified number.
        /// </summary>
        [Input("numberOfReplicas")]
        public Input<string>? NumberOfReplicas { get; set; }

        /// <summary>
        /// Value used with number*of*shards to route documents to a primary shard. A stringified number. This can be set only on creation.
        /// </summary>
        [Input("numberOfRoutingShards")]
        public Input<string>? NumberOfRoutingShards { get; set; }

        /// <summary>
        /// Number of shards for the index. This can be set only on creation.
        /// </summary>
        [Input("numberOfShards")]
        public Input<string>? NumberOfShards { get; set; }

        /// <summary>
        /// How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1` to disable refresh.
        /// </summary>
        [Input("refreshInterval")]
        public Input<string>? RefreshInterval { get; set; }

        [Input("rolloverAlias")]
        public Input<string>? RolloverAlias { get; set; }

        /// <summary>
        /// Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.
        /// </summary>
        [Input("routingAllocationEnable")]
        public Input<string>? RoutingAllocationEnable { get; set; }

        /// <summary>
        /// The number of shards a custom routing value can go to. A stringified number. This can be set only on creation.
        /// </summary>
        [Input("routingPartitionSize")]
        public Input<string>? RoutingPartitionSize { get; set; }

        /// <summary>
        /// Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.
        /// </summary>
        [Input("routingRebalanceEnable")]
        public Input<string>? RoutingRebalanceEnable { get; set; }

        /// <summary>
        /// How long a shard can not receive a search or get request until it’s considered search idle.
        /// </summary>
        [Input("searchIdleAfter")]
        public Input<string>? SearchIdleAfter { get; set; }

        /// <summary>
        /// Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`
        /// </summary>
        [Input("searchSlowlogLevel")]
        public Input<string>? SearchSlowlogLevel { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`
        /// </summary>
        [Input("searchSlowlogThresholdFetchDebug")]
        public Input<string>? SearchSlowlogThresholdFetchDebug { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`
        /// </summary>
        [Input("searchSlowlogThresholdFetchInfo")]
        public Input<string>? SearchSlowlogThresholdFetchInfo { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`
        /// </summary>
        [Input("searchSlowlogThresholdFetchTrace")]
        public Input<string>? SearchSlowlogThresholdFetchTrace { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`
        /// </summary>
        [Input("searchSlowlogThresholdFetchWarn")]
        public Input<string>? SearchSlowlogThresholdFetchWarn { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`
        /// </summary>
        [Input("searchSlowlogThresholdQueryDebug")]
        public Input<string>? SearchSlowlogThresholdQueryDebug { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`
        /// </summary>
        [Input("searchSlowlogThresholdQueryInfo")]
        public Input<string>? SearchSlowlogThresholdQueryInfo { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`
        /// </summary>
        [Input("searchSlowlogThresholdQueryTrace")]
        public Input<string>? SearchSlowlogThresholdQueryTrace { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`
        /// </summary>
        [Input("searchSlowlogThresholdQueryWarn")]
        public Input<string>? SearchSlowlogThresholdQueryWarn { get; set; }

        /// <summary>
        /// Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the shard from being opened. Accepts `false`, `true`, `checksum`.
        /// </summary>
        [Input("shardCheckOnStartup")]
        public Input<string>? ShardCheckOnStartup { get; set; }

        /// <summary>
        /// The field to sort shards in this index by.
        /// </summary>
        [Input("sortField")]
        public Input<string>? SortField { get; set; }

        /// <summary>
        /// The direction to sort shards in. Accepts `asc`, `desc`.
        /// </summary>
        [Input("sortOrder")]
        public Input<string>? SortOrder { get; set; }

        public IndexArgs()
        {
        }
        public static new IndexArgs Empty => new IndexArgs();
    }

    public sealed class IndexState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// A JSON string describing a set of aliases. The index aliases API allows aliasing an index with a name, with all APIs automatically converting the alias name to the actual index name. An alias can also be mapped to more than one index, and when specifying it, the alias will automatically expand to the aliased indices.
        /// </summary>
        [Input("aliases")]
        public Input<string>? Aliases { get; set; }

        /// <summary>
        /// A JSON string describing the analyzers applied to the index.
        /// </summary>
        [Input("analysisAnalyzer")]
        public Input<string>? AnalysisAnalyzer { get; set; }

        /// <summary>
        /// A JSON string describing the char_filters applied to the index.
        /// </summary>
        [Input("analysisCharFilter")]
        public Input<string>? AnalysisCharFilter { get; set; }

        /// <summary>
        /// A JSON string describing the filters applied to the index.
        /// </summary>
        [Input("analysisFilter")]
        public Input<string>? AnalysisFilter { get; set; }

        /// <summary>
        /// A JSON string describing the normalizers applied to the index.
        /// </summary>
        [Input("analysisNormalizer")]
        public Input<string>? AnalysisNormalizer { get; set; }

        /// <summary>
        /// A JSON string describing the tokenizers applied to the index.
        /// </summary>
        [Input("analysisTokenizer")]
        public Input<string>? AnalysisTokenizer { get; set; }

        /// <summary>
        /// The maximum number of tokens that can be produced using _analyze API. A stringified number.
        /// </summary>
        [Input("analyzeMaxTokenCount")]
        public Input<string>? AnalyzeMaxTokenCount { get; set; }

        /// <summary>
        /// Set the number of replicas to the node count in the cluster. Set to a dash delimited lower and upper bound (e.g. 0-5) or use all for the upper bound (e.g. 0-all)
        /// </summary>
        [Input("autoExpandReplicas")]
        public Input<string>? AutoExpandReplicas { get; set; }

        /// <summary>
        /// Set to `true` to disable index metadata reads and writes.
        /// </summary>
        [Input("blocksMetadata")]
        public Input<bool>? BlocksMetadata { get; set; }

        /// <summary>
        /// Set to `true` to disable read operations against the index.
        /// </summary>
        [Input("blocksRead")]
        public Input<bool>? BlocksRead { get; set; }

        /// <summary>
        /// Set to `true` to make the index and index metadata read only, `false` to allow writes and metadata changes.
        /// </summary>
        [Input("blocksReadOnly")]
        public Input<bool>? BlocksReadOnly { get; set; }

        /// <summary>
        /// Identical to `index.blocks.read_only` but allows deleting the index to free up resources.
        /// </summary>
        [Input("blocksReadOnlyAllowDelete")]
        public Input<bool>? BlocksReadOnlyAllowDelete { get; set; }

        /// <summary>
        /// Set to `true` to disable data write operations against the index. This setting does not affect metadata.
        /// </summary>
        [Input("blocksWrite")]
        public Input<bool>? BlocksWrite { get; set; }

        /// <summary>
        /// The `default` value compresses stored data with LZ4 compression, but this can be set to `best_compression` which uses DEFLATE for a higher compression ratio. This can be set only on creation.
        /// </summary>
        [Input("codec")]
        public Input<string>? Codec { get; set; }

        /// <summary>
        /// The default ingest node pipeline for this index. Index requests will fail if the default pipeline is set and the pipeline does not exist.
        /// </summary>
        [Input("defaultPipeline")]
        public Input<string>? DefaultPipeline { get; set; }

        /// <summary>
        /// A boolean that indicates that the index should be deleted even if it contains documents.
        /// </summary>
        [Input("forceDestroy")]
        public Input<bool>? ForceDestroy { get; set; }

        /// <summary>
        /// The length of time that a deleted document's version number remains available for further versioned operations.
        /// </summary>
        [Input("gcDeletes")]
        public Input<string>? GcDeletes { get; set; }

        /// <summary>
        /// The maximum number of characters that will be analyzed for a highlight request. A stringified number.
        /// </summary>
        [Input("highlightMaxAnalyzedOffset")]
        public Input<string>? HighlightMaxAnalyzedOffset { get; set; }

        /// <summary>
        /// A string that indicates if and what we should pass to include*type*name parameter. Set to `"false"` when trying to create an index on a v6 cluster without a doc type or set to `"true"` when trying to create an index on a v7 cluster with a doc type. Since mapping updates are not currently supported, this applies only on index create.
        /// </summary>
        [Input("includeTypeName")]
        public Input<string>? IncludeTypeName { get; set; }

        /// <summary>
        /// Indicates whether the index should build native library indices for the knn*vector fields. If set to false, the knn*vector fields will be stored in doc values, but Approximate k-NN search functionality will be disabled.
        /// </summary>
        [Input("indexKnn")]
        public Input<bool>? IndexKnn { get; set; }

        /// <summary>
        /// The size of the dynamic list used during k-NN searches. Higher values lead to more accurate but slower searches. Only available for nmslib.
        /// </summary>
        [Input("indexKnnAlgoParamEfSearch")]
        public Input<string>? IndexKnnAlgoParamEfSearch { get; set; }

        /// <summary>
        /// A JSON string describing the default index similarity config.
        /// </summary>
        [Input("indexSimilarityDefault")]
        public Input<string>? IndexSimilarityDefault { get; set; }

        /// <summary>
        /// Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`
        /// </summary>
        [Input("indexingSlowlogLevel")]
        public Input<string>? IndexingSlowlogLevel { get; set; }

        /// <summary>
        /// Set the number of characters of the `_source` to include in the slowlog lines, `false` or `0` will skip logging the source entirely and setting it to `true` will log the entire source regardless of size. The original `_source` is reformatted by default to make sure that it fits on a single log line.
        /// </summary>
        [Input("indexingSlowlogSource")]
        public Input<string>? IndexingSlowlogSource { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `2s`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexDebug")]
        public Input<string>? IndexingSlowlogThresholdIndexDebug { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `5s`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexInfo")]
        public Input<string>? IndexingSlowlogThresholdIndexInfo { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `500ms`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexTrace")]
        public Input<string>? IndexingSlowlogThresholdIndexTrace { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches for indexing queries, in time units, e.g. `10s`
        /// </summary>
        [Input("indexingSlowlogThresholdIndexWarn")]
        public Input<string>? IndexingSlowlogThresholdIndexWarn { get; set; }

        /// <summary>
        /// Indicates whether cached filters are pre-loaded for nested queries. This can be set only on creation.
        /// </summary>
        [Input("loadFixedBitsetFiltersEagerly")]
        public Input<bool>? LoadFixedBitsetFiltersEagerly { get; set; }

        /// <summary>
        /// A JSON string defining how documents in the index, and the fields they contain, are stored and indexed. To avoid the complexities of field mapping updates, updates of this field are not allowed via this provider.
        /// </summary>
        [Input("mappings")]
        public Input<string>? Mappings { get; set; }

        /// <summary>
        /// The maximum number of `docvalue_fields` that are allowed in a query. A stringified number.
        /// </summary>
        [Input("maxDocvalueFieldsSearch")]
        public Input<string>? MaxDocvalueFieldsSearch { get; set; }

        /// <summary>
        /// The maximum value of `from + size` for inner hits definition and top hits aggregations to this index. A stringified number.
        /// </summary>
        [Input("maxInnerResultWindow")]
        public Input<string>? MaxInnerResultWindow { get; set; }

        /// <summary>
        /// The maximum allowed difference between min*gram and max*gram for NGramTokenizer and NGramTokenFilter. A stringified number.
        /// </summary>
        [Input("maxNgramDiff")]
        public Input<string>? MaxNgramDiff { get; set; }

        /// <summary>
        /// Maximum number of refresh listeners available on each shard of the index. A stringified number.
        /// </summary>
        [Input("maxRefreshListeners")]
        public Input<string>? MaxRefreshListeners { get; set; }

        /// <summary>
        /// The maximum length of regex that can be used in Regexp Query. A stringified number.
        /// </summary>
        [Input("maxRegexLength")]
        public Input<string>? MaxRegexLength { get; set; }

        /// <summary>
        /// The maximum value of `window_size` for `rescore` requests in searches of this index. A stringified number.
        /// </summary>
        [Input("maxRescoreWindow")]
        public Input<string>? MaxRescoreWindow { get; set; }

        /// <summary>
        /// The maximum value of `from + size` for searches to this index. A stringified number.
        /// </summary>
        [Input("maxResultWindow")]
        public Input<string>? MaxResultWindow { get; set; }

        /// <summary>
        /// The maximum number of `script_fields` that are allowed in a query. A stringified number.
        /// </summary>
        [Input("maxScriptFields")]
        public Input<string>? MaxScriptFields { get; set; }

        /// <summary>
        /// The maximum allowed difference between max*shingle*size and min*shingle*size for ShingleTokenFilter. A stringified number.
        /// </summary>
        [Input("maxShingleDiff")]
        public Input<string>? MaxShingleDiff { get; set; }

        /// <summary>
        /// The maximum number of terms that can be used in Terms Query. A stringified number.
        /// </summary>
        [Input("maxTermsCount")]
        public Input<string>? MaxTermsCount { get; set; }

        /// <summary>
        /// Name of the index to create
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Number of shard replicas. A stringified number.
        /// </summary>
        [Input("numberOfReplicas")]
        public Input<string>? NumberOfReplicas { get; set; }

        /// <summary>
        /// Value used with number*of*shards to route documents to a primary shard. A stringified number. This can be set only on creation.
        /// </summary>
        [Input("numberOfRoutingShards")]
        public Input<string>? NumberOfRoutingShards { get; set; }

        /// <summary>
        /// Number of shards for the index. This can be set only on creation.
        /// </summary>
        [Input("numberOfShards")]
        public Input<string>? NumberOfShards { get; set; }

        /// <summary>
        /// How often to perform a refresh operation, which makes recent changes to the index visible to search. Can be set to `-1` to disable refresh.
        /// </summary>
        [Input("refreshInterval")]
        public Input<string>? RefreshInterval { get; set; }

        [Input("rolloverAlias")]
        public Input<string>? RolloverAlias { get; set; }

        /// <summary>
        /// Controls shard allocation for this index. It can be set to: `all` , `primaries` , `new_primaries` , `none`.
        /// </summary>
        [Input("routingAllocationEnable")]
        public Input<string>? RoutingAllocationEnable { get; set; }

        /// <summary>
        /// The number of shards a custom routing value can go to. A stringified number. This can be set only on creation.
        /// </summary>
        [Input("routingPartitionSize")]
        public Input<string>? RoutingPartitionSize { get; set; }

        /// <summary>
        /// Enables shard rebalancing for this index. It can be set to: `all`, `primaries` , `replicas` , `none`.
        /// </summary>
        [Input("routingRebalanceEnable")]
        public Input<string>? RoutingRebalanceEnable { get; set; }

        /// <summary>
        /// How long a shard can not receive a search or get request until it’s considered search idle.
        /// </summary>
        [Input("searchIdleAfter")]
        public Input<string>? SearchIdleAfter { get; set; }

        /// <summary>
        /// Set which logging level to use for the search slow log, can be: `warn`, `info`, `debug`, `trace`
        /// </summary>
        [Input("searchSlowlogLevel")]
        public Input<string>? SearchSlowlogLevel { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `2s`
        /// </summary>
        [Input("searchSlowlogThresholdFetchDebug")]
        public Input<string>? SearchSlowlogThresholdFetchDebug { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `5s`
        /// </summary>
        [Input("searchSlowlogThresholdFetchInfo")]
        public Input<string>? SearchSlowlogThresholdFetchInfo { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `500ms`
        /// </summary>
        [Input("searchSlowlogThresholdFetchTrace")]
        public Input<string>? SearchSlowlogThresholdFetchTrace { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the fetch phase, in time units, e.g. `10s`
        /// </summary>
        [Input("searchSlowlogThresholdFetchWarn")]
        public Input<string>? SearchSlowlogThresholdFetchWarn { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `2s`
        /// </summary>
        [Input("searchSlowlogThresholdQueryDebug")]
        public Input<string>? SearchSlowlogThresholdQueryDebug { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `5s`
        /// </summary>
        [Input("searchSlowlogThresholdQueryInfo")]
        public Input<string>? SearchSlowlogThresholdQueryInfo { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `500ms`
        /// </summary>
        [Input("searchSlowlogThresholdQueryTrace")]
        public Input<string>? SearchSlowlogThresholdQueryTrace { get; set; }

        /// <summary>
        /// Set the cutoff for shard level slow search logging of slow searches in the query phase, in time units, e.g. `10s`
        /// </summary>
        [Input("searchSlowlogThresholdQueryWarn")]
        public Input<string>? SearchSlowlogThresholdQueryWarn { get; set; }

        /// <summary>
        /// Whether or not shards should be checked for corruption before opening. When corruption is detected, it will prevent the shard from being opened. Accepts `false`, `true`, `checksum`.
        /// </summary>
        [Input("shardCheckOnStartup")]
        public Input<string>? ShardCheckOnStartup { get; set; }

        /// <summary>
        /// The field to sort shards in this index by.
        /// </summary>
        [Input("sortField")]
        public Input<string>? SortField { get; set; }

        /// <summary>
        /// The direction to sort shards in. Accepts `asc`, `desc`.
        /// </summary>
        [Input("sortOrder")]
        public Input<string>? SortOrder { get; set; }

        public IndexState()
        {
        }
        public static new IndexState Empty => new IndexState();
    }
}
