// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package opensearch

import (
	"context"
	"reflect"

	"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a cluster's (persistent) settings.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/piclemx/pulumi-opensearch/sdk/go/opensearch"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := opensearch.NewClusterSettings(ctx, "global", &opensearch.ClusterSettingsArgs{
//				ActionAutoCreateIndex:   pulumi.String("my-index-000001,index10,-index1*,+ind*"),
//				ClusterMaxShardsPerNode: pulumi.Int(10),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type ClusterSettings struct {
	pulumi.CustomResourceState

	// Whether to automatically create an index if it doesn’t already exist and apply any configured index template
	ActionAutoCreateIndex pulumi.StringPtrOutput `pulumi:"actionAutoCreateIndex"`
	// When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
	ActionDestructiveRequiresName pulumi.BoolPtrOutput `pulumi:"actionDestructiveRequiresName"`
	// Make the whole cluster read only and metadata is not allowed to be modified
	ClusterBlocksReadOnly pulumi.BoolPtrOutput `pulumi:"clusterBlocksReadOnly"`
	// Make the whole cluster read only, but allows to delete indices to free up resources
	ClusterBlocksReadOnlyAllowDelete pulumi.BoolPtrOutput `pulumi:"clusterBlocksReadOnlyAllowDelete"`
	// If false, you cannot close open indices
	ClusterIndicesCloseEnable pulumi.BoolPtrOutput `pulumi:"clusterIndicesCloseEnable"`
	// A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
	ClusterInfoUpdateInterval pulumi.StringPtrOutput `pulumi:"clusterInfoUpdateInterval"`
	// The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
	ClusterMaxShardsPerNode pulumi.IntPtrOutput `pulumi:"clusterMaxShardsPerNode"`
	// The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
	ClusterMaxShardsPerNodeFrozen pulumi.IntPtrOutput `pulumi:"clusterMaxShardsPerNodeFrozen"`
	// Specifies which operations are rejected when there is no active master in a cluster (all, write)
	ClusterNoMasterBlock pulumi.StringPtrOutput `pulumi:"clusterNoMasterBlock"`
	// Whether allocation for persistent tasks is active (all, none)
	ClusterPersistentTasksAllocationEnable pulumi.StringPtrOutput `pulumi:"clusterPersistentTasksAllocationEnable"`
	// A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
	ClusterPersistentTasksAllocationRecheckInterval pulumi.StringPtrOutput `pulumi:"clusterPersistentTasksAllocationRecheckInterval"`
	// Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)
	ClusterRoutingAllocationAllowRebalance pulumi.StringPtrOutput `pulumi:"clusterRoutingAllocationAllowRebalance"`
	// Use custom node attributes to take hardware configuration into account when allocating shards
	ClusterRoutingAllocationAwarenessAttributes pulumi.StringPtrOutput `pulumi:"clusterRoutingAllocationAwarenessAttributes"`
	// Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
	ClusterRoutingAllocationBalanceIndex pulumi.Float64PtrOutput `pulumi:"clusterRoutingAllocationBalanceIndex"`
	// Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
	ClusterRoutingAllocationBalanceShard pulumi.Float64PtrOutput `pulumi:"clusterRoutingAllocationBalanceShard"`
	// Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
	ClusterRoutingAllocationBalanceThreshold pulumi.Float64PtrOutput `pulumi:"clusterRoutingAllocationBalanceThreshold"`
	// How many concurrent shard rebalances are allowed cluster wide
	ClusterRoutingAllocationClusterConcurrentRebalance pulumi.IntPtrOutput `pulumi:"clusterRoutingAllocationClusterConcurrentRebalance"`
	// Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
	ClusterRoutingAllocationDiskIncludeRelocations pulumi.BoolPtrOutput `pulumi:"clusterRoutingAllocationDiskIncludeRelocations"`
	// Whether the disk allocation decider is active
	ClusterRoutingAllocationDiskThresholdEnabled pulumi.BoolPtrOutput `pulumi:"clusterRoutingAllocationDiskThresholdEnabled"`
	// Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
	ClusterRoutingAllocationDiskWatermarkHigh pulumi.StringPtrOutput `pulumi:"clusterRoutingAllocationDiskWatermarkHigh"`
	// Allocator will not allocate shards to nodes that have more than this percentage disk used
	ClusterRoutingAllocationDiskWatermarkLow pulumi.StringPtrOutput `pulumi:"clusterRoutingAllocationDiskWatermarkLow"`
	// Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
	ClusterRoutingAllocationEnable pulumi.StringPtrOutput `pulumi:"clusterRoutingAllocationEnable"`
	// How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentIncomingRecoveries pulumi.IntPtrOutput `pulumi:"clusterRoutingAllocationNodeConcurrentIncomingRecoveries"`
	// How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries pulumi.IntPtrOutput `pulumi:"clusterRoutingAllocationNodeConcurrentOutgoingRecoveries"`
	// A shortcut to set both incoming and outgoing recoveries
	ClusterRoutingAllocationNodeConcurrentRecoveries pulumi.IntPtrOutput `pulumi:"clusterRoutingAllocationNodeConcurrentRecoveries"`
	// Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
	ClusterRoutingAllocationNodeInitialPrimariesRecoveries pulumi.IntPtrOutput `pulumi:"clusterRoutingAllocationNodeInitialPrimariesRecoveries"`
	// Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
	ClusterRoutingAllocationSameShardHost pulumi.BoolPtrOutput `pulumi:"clusterRoutingAllocationSameShardHost"`
	// Maximum number of primary and replica shards allocated to each node
	ClusterRoutingAllocationTotalShardsPerNode pulumi.IntPtrOutput `pulumi:"clusterRoutingAllocationTotalShardsPerNode"`
	// Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
	ClusterRoutingRebalanceEnable pulumi.StringPtrOutput `pulumi:"clusterRoutingRebalanceEnable"`
	// The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
	IndicesBreakerFielddataLimit pulumi.StringPtrOutput `pulumi:"indicesBreakerFielddataLimit"`
	// A constant that all field data estimations are multiplied by
	IndicesBreakerFielddataOverhead pulumi.Float64PtrOutput `pulumi:"indicesBreakerFielddataOverhead"`
	// The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
	IndicesBreakerRequestLimit pulumi.StringPtrOutput `pulumi:"indicesBreakerRequestLimit"`
	// A constant that all request estimations are multiplied by
	IndicesBreakerRequestOverhead pulumi.Float64PtrOutput `pulumi:"indicesBreakerRequestOverhead"`
	// The percentage of total amount of memory that can be used across all breakers
	IndicesBreakerTotalLimit pulumi.StringPtrOutput `pulumi:"indicesBreakerTotalLimit"`
	// Maximum total inbound and outbound recovery traffic for each node, in mb
	IndicesRecoveryMaxBytesPerSec pulumi.StringPtrOutput `pulumi:"indicesRecoveryMaxBytesPerSec"`
	// The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
	NetworkBreakerInflightRequestsLimit pulumi.StringPtrOutput `pulumi:"networkBreakerInflightRequestsLimit"`
	// A constant that all in flight requests estimations are multiplied by
	NetworkBreakerInflightRequestsOverhead pulumi.Float64PtrOutput `pulumi:"networkBreakerInflightRequestsOverhead"`
	// Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
	ScriptMaxCompilationsRate pulumi.StringPtrOutput `pulumi:"scriptMaxCompilationsRate"`
	// A time string setting a cluster-wide default timeout for all search requests
	SearchDefaultSearchTimeout pulumi.StringPtrOutput `pulumi:"searchDefaultSearchTimeout"`
}

// NewClusterSettings registers a new resource with the given unique name, arguments, and options.
func NewClusterSettings(ctx *pulumi.Context,
	name string, args *ClusterSettingsArgs, opts ...pulumi.ResourceOption) (*ClusterSettings, error) {
	if args == nil {
		args = &ClusterSettingsArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ClusterSettings
	err := ctx.RegisterResource("opensearch:index/clusterSettings:ClusterSettings", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetClusterSettings gets an existing ClusterSettings resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetClusterSettings(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ClusterSettingsState, opts ...pulumi.ResourceOption) (*ClusterSettings, error) {
	var resource ClusterSettings
	err := ctx.ReadResource("opensearch:index/clusterSettings:ClusterSettings", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ClusterSettings resources.
type clusterSettingsState struct {
	// Whether to automatically create an index if it doesn’t already exist and apply any configured index template
	ActionAutoCreateIndex *string `pulumi:"actionAutoCreateIndex"`
	// When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
	ActionDestructiveRequiresName *bool `pulumi:"actionDestructiveRequiresName"`
	// Make the whole cluster read only and metadata is not allowed to be modified
	ClusterBlocksReadOnly *bool `pulumi:"clusterBlocksReadOnly"`
	// Make the whole cluster read only, but allows to delete indices to free up resources
	ClusterBlocksReadOnlyAllowDelete *bool `pulumi:"clusterBlocksReadOnlyAllowDelete"`
	// If false, you cannot close open indices
	ClusterIndicesCloseEnable *bool `pulumi:"clusterIndicesCloseEnable"`
	// A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
	ClusterInfoUpdateInterval *string `pulumi:"clusterInfoUpdateInterval"`
	// The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
	ClusterMaxShardsPerNode *int `pulumi:"clusterMaxShardsPerNode"`
	// The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
	ClusterMaxShardsPerNodeFrozen *int `pulumi:"clusterMaxShardsPerNodeFrozen"`
	// Specifies which operations are rejected when there is no active master in a cluster (all, write)
	ClusterNoMasterBlock *string `pulumi:"clusterNoMasterBlock"`
	// Whether allocation for persistent tasks is active (all, none)
	ClusterPersistentTasksAllocationEnable *string `pulumi:"clusterPersistentTasksAllocationEnable"`
	// A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
	ClusterPersistentTasksAllocationRecheckInterval *string `pulumi:"clusterPersistentTasksAllocationRecheckInterval"`
	// Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)
	ClusterRoutingAllocationAllowRebalance *string `pulumi:"clusterRoutingAllocationAllowRebalance"`
	// Use custom node attributes to take hardware configuration into account when allocating shards
	ClusterRoutingAllocationAwarenessAttributes *string `pulumi:"clusterRoutingAllocationAwarenessAttributes"`
	// Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
	ClusterRoutingAllocationBalanceIndex *float64 `pulumi:"clusterRoutingAllocationBalanceIndex"`
	// Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
	ClusterRoutingAllocationBalanceShard *float64 `pulumi:"clusterRoutingAllocationBalanceShard"`
	// Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
	ClusterRoutingAllocationBalanceThreshold *float64 `pulumi:"clusterRoutingAllocationBalanceThreshold"`
	// How many concurrent shard rebalances are allowed cluster wide
	ClusterRoutingAllocationClusterConcurrentRebalance *int `pulumi:"clusterRoutingAllocationClusterConcurrentRebalance"`
	// Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
	ClusterRoutingAllocationDiskIncludeRelocations *bool `pulumi:"clusterRoutingAllocationDiskIncludeRelocations"`
	// Whether the disk allocation decider is active
	ClusterRoutingAllocationDiskThresholdEnabled *bool `pulumi:"clusterRoutingAllocationDiskThresholdEnabled"`
	// Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
	ClusterRoutingAllocationDiskWatermarkHigh *string `pulumi:"clusterRoutingAllocationDiskWatermarkHigh"`
	// Allocator will not allocate shards to nodes that have more than this percentage disk used
	ClusterRoutingAllocationDiskWatermarkLow *string `pulumi:"clusterRoutingAllocationDiskWatermarkLow"`
	// Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
	ClusterRoutingAllocationEnable *string `pulumi:"clusterRoutingAllocationEnable"`
	// How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentIncomingRecoveries *int `pulumi:"clusterRoutingAllocationNodeConcurrentIncomingRecoveries"`
	// How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries *int `pulumi:"clusterRoutingAllocationNodeConcurrentOutgoingRecoveries"`
	// A shortcut to set both incoming and outgoing recoveries
	ClusterRoutingAllocationNodeConcurrentRecoveries *int `pulumi:"clusterRoutingAllocationNodeConcurrentRecoveries"`
	// Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
	ClusterRoutingAllocationNodeInitialPrimariesRecoveries *int `pulumi:"clusterRoutingAllocationNodeInitialPrimariesRecoveries"`
	// Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
	ClusterRoutingAllocationSameShardHost *bool `pulumi:"clusterRoutingAllocationSameShardHost"`
	// Maximum number of primary and replica shards allocated to each node
	ClusterRoutingAllocationTotalShardsPerNode *int `pulumi:"clusterRoutingAllocationTotalShardsPerNode"`
	// Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
	ClusterRoutingRebalanceEnable *string `pulumi:"clusterRoutingRebalanceEnable"`
	// The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
	IndicesBreakerFielddataLimit *string `pulumi:"indicesBreakerFielddataLimit"`
	// A constant that all field data estimations are multiplied by
	IndicesBreakerFielddataOverhead *float64 `pulumi:"indicesBreakerFielddataOverhead"`
	// The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
	IndicesBreakerRequestLimit *string `pulumi:"indicesBreakerRequestLimit"`
	// A constant that all request estimations are multiplied by
	IndicesBreakerRequestOverhead *float64 `pulumi:"indicesBreakerRequestOverhead"`
	// The percentage of total amount of memory that can be used across all breakers
	IndicesBreakerTotalLimit *string `pulumi:"indicesBreakerTotalLimit"`
	// Maximum total inbound and outbound recovery traffic for each node, in mb
	IndicesRecoveryMaxBytesPerSec *string `pulumi:"indicesRecoveryMaxBytesPerSec"`
	// The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
	NetworkBreakerInflightRequestsLimit *string `pulumi:"networkBreakerInflightRequestsLimit"`
	// A constant that all in flight requests estimations are multiplied by
	NetworkBreakerInflightRequestsOverhead *float64 `pulumi:"networkBreakerInflightRequestsOverhead"`
	// Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
	ScriptMaxCompilationsRate *string `pulumi:"scriptMaxCompilationsRate"`
	// A time string setting a cluster-wide default timeout for all search requests
	SearchDefaultSearchTimeout *string `pulumi:"searchDefaultSearchTimeout"`
}

type ClusterSettingsState struct {
	// Whether to automatically create an index if it doesn’t already exist and apply any configured index template
	ActionAutoCreateIndex pulumi.StringPtrInput
	// When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
	ActionDestructiveRequiresName pulumi.BoolPtrInput
	// Make the whole cluster read only and metadata is not allowed to be modified
	ClusterBlocksReadOnly pulumi.BoolPtrInput
	// Make the whole cluster read only, but allows to delete indices to free up resources
	ClusterBlocksReadOnlyAllowDelete pulumi.BoolPtrInput
	// If false, you cannot close open indices
	ClusterIndicesCloseEnable pulumi.BoolPtrInput
	// A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
	ClusterInfoUpdateInterval pulumi.StringPtrInput
	// The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
	ClusterMaxShardsPerNode pulumi.IntPtrInput
	// The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
	ClusterMaxShardsPerNodeFrozen pulumi.IntPtrInput
	// Specifies which operations are rejected when there is no active master in a cluster (all, write)
	ClusterNoMasterBlock pulumi.StringPtrInput
	// Whether allocation for persistent tasks is active (all, none)
	ClusterPersistentTasksAllocationEnable pulumi.StringPtrInput
	// A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
	ClusterPersistentTasksAllocationRecheckInterval pulumi.StringPtrInput
	// Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)
	ClusterRoutingAllocationAllowRebalance pulumi.StringPtrInput
	// Use custom node attributes to take hardware configuration into account when allocating shards
	ClusterRoutingAllocationAwarenessAttributes pulumi.StringPtrInput
	// Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
	ClusterRoutingAllocationBalanceIndex pulumi.Float64PtrInput
	// Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
	ClusterRoutingAllocationBalanceShard pulumi.Float64PtrInput
	// Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
	ClusterRoutingAllocationBalanceThreshold pulumi.Float64PtrInput
	// How many concurrent shard rebalances are allowed cluster wide
	ClusterRoutingAllocationClusterConcurrentRebalance pulumi.IntPtrInput
	// Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
	ClusterRoutingAllocationDiskIncludeRelocations pulumi.BoolPtrInput
	// Whether the disk allocation decider is active
	ClusterRoutingAllocationDiskThresholdEnabled pulumi.BoolPtrInput
	// Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
	ClusterRoutingAllocationDiskWatermarkHigh pulumi.StringPtrInput
	// Allocator will not allocate shards to nodes that have more than this percentage disk used
	ClusterRoutingAllocationDiskWatermarkLow pulumi.StringPtrInput
	// Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
	ClusterRoutingAllocationEnable pulumi.StringPtrInput
	// How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentIncomingRecoveries pulumi.IntPtrInput
	// How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries pulumi.IntPtrInput
	// A shortcut to set both incoming and outgoing recoveries
	ClusterRoutingAllocationNodeConcurrentRecoveries pulumi.IntPtrInput
	// Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
	ClusterRoutingAllocationNodeInitialPrimariesRecoveries pulumi.IntPtrInput
	// Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
	ClusterRoutingAllocationSameShardHost pulumi.BoolPtrInput
	// Maximum number of primary and replica shards allocated to each node
	ClusterRoutingAllocationTotalShardsPerNode pulumi.IntPtrInput
	// Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
	ClusterRoutingRebalanceEnable pulumi.StringPtrInput
	// The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
	IndicesBreakerFielddataLimit pulumi.StringPtrInput
	// A constant that all field data estimations are multiplied by
	IndicesBreakerFielddataOverhead pulumi.Float64PtrInput
	// The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
	IndicesBreakerRequestLimit pulumi.StringPtrInput
	// A constant that all request estimations are multiplied by
	IndicesBreakerRequestOverhead pulumi.Float64PtrInput
	// The percentage of total amount of memory that can be used across all breakers
	IndicesBreakerTotalLimit pulumi.StringPtrInput
	// Maximum total inbound and outbound recovery traffic for each node, in mb
	IndicesRecoveryMaxBytesPerSec pulumi.StringPtrInput
	// The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
	NetworkBreakerInflightRequestsLimit pulumi.StringPtrInput
	// A constant that all in flight requests estimations are multiplied by
	NetworkBreakerInflightRequestsOverhead pulumi.Float64PtrInput
	// Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
	ScriptMaxCompilationsRate pulumi.StringPtrInput
	// A time string setting a cluster-wide default timeout for all search requests
	SearchDefaultSearchTimeout pulumi.StringPtrInput
}

func (ClusterSettingsState) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterSettingsState)(nil)).Elem()
}

type clusterSettingsArgs struct {
	// Whether to automatically create an index if it doesn’t already exist and apply any configured index template
	ActionAutoCreateIndex *string `pulumi:"actionAutoCreateIndex"`
	// When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
	ActionDestructiveRequiresName *bool `pulumi:"actionDestructiveRequiresName"`
	// Make the whole cluster read only and metadata is not allowed to be modified
	ClusterBlocksReadOnly *bool `pulumi:"clusterBlocksReadOnly"`
	// Make the whole cluster read only, but allows to delete indices to free up resources
	ClusterBlocksReadOnlyAllowDelete *bool `pulumi:"clusterBlocksReadOnlyAllowDelete"`
	// If false, you cannot close open indices
	ClusterIndicesCloseEnable *bool `pulumi:"clusterIndicesCloseEnable"`
	// A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
	ClusterInfoUpdateInterval *string `pulumi:"clusterInfoUpdateInterval"`
	// The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
	ClusterMaxShardsPerNode *int `pulumi:"clusterMaxShardsPerNode"`
	// The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
	ClusterMaxShardsPerNodeFrozen *int `pulumi:"clusterMaxShardsPerNodeFrozen"`
	// Specifies which operations are rejected when there is no active master in a cluster (all, write)
	ClusterNoMasterBlock *string `pulumi:"clusterNoMasterBlock"`
	// Whether allocation for persistent tasks is active (all, none)
	ClusterPersistentTasksAllocationEnable *string `pulumi:"clusterPersistentTasksAllocationEnable"`
	// A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
	ClusterPersistentTasksAllocationRecheckInterval *string `pulumi:"clusterPersistentTasksAllocationRecheckInterval"`
	// Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)
	ClusterRoutingAllocationAllowRebalance *string `pulumi:"clusterRoutingAllocationAllowRebalance"`
	// Use custom node attributes to take hardware configuration into account when allocating shards
	ClusterRoutingAllocationAwarenessAttributes *string `pulumi:"clusterRoutingAllocationAwarenessAttributes"`
	// Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
	ClusterRoutingAllocationBalanceIndex *float64 `pulumi:"clusterRoutingAllocationBalanceIndex"`
	// Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
	ClusterRoutingAllocationBalanceShard *float64 `pulumi:"clusterRoutingAllocationBalanceShard"`
	// Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
	ClusterRoutingAllocationBalanceThreshold *float64 `pulumi:"clusterRoutingAllocationBalanceThreshold"`
	// How many concurrent shard rebalances are allowed cluster wide
	ClusterRoutingAllocationClusterConcurrentRebalance *int `pulumi:"clusterRoutingAllocationClusterConcurrentRebalance"`
	// Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
	ClusterRoutingAllocationDiskIncludeRelocations *bool `pulumi:"clusterRoutingAllocationDiskIncludeRelocations"`
	// Whether the disk allocation decider is active
	ClusterRoutingAllocationDiskThresholdEnabled *bool `pulumi:"clusterRoutingAllocationDiskThresholdEnabled"`
	// Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
	ClusterRoutingAllocationDiskWatermarkHigh *string `pulumi:"clusterRoutingAllocationDiskWatermarkHigh"`
	// Allocator will not allocate shards to nodes that have more than this percentage disk used
	ClusterRoutingAllocationDiskWatermarkLow *string `pulumi:"clusterRoutingAllocationDiskWatermarkLow"`
	// Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
	ClusterRoutingAllocationEnable *string `pulumi:"clusterRoutingAllocationEnable"`
	// How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentIncomingRecoveries *int `pulumi:"clusterRoutingAllocationNodeConcurrentIncomingRecoveries"`
	// How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries *int `pulumi:"clusterRoutingAllocationNodeConcurrentOutgoingRecoveries"`
	// A shortcut to set both incoming and outgoing recoveries
	ClusterRoutingAllocationNodeConcurrentRecoveries *int `pulumi:"clusterRoutingAllocationNodeConcurrentRecoveries"`
	// Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
	ClusterRoutingAllocationNodeInitialPrimariesRecoveries *int `pulumi:"clusterRoutingAllocationNodeInitialPrimariesRecoveries"`
	// Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
	ClusterRoutingAllocationSameShardHost *bool `pulumi:"clusterRoutingAllocationSameShardHost"`
	// Maximum number of primary and replica shards allocated to each node
	ClusterRoutingAllocationTotalShardsPerNode *int `pulumi:"clusterRoutingAllocationTotalShardsPerNode"`
	// Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
	ClusterRoutingRebalanceEnable *string `pulumi:"clusterRoutingRebalanceEnable"`
	// The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
	IndicesBreakerFielddataLimit *string `pulumi:"indicesBreakerFielddataLimit"`
	// A constant that all field data estimations are multiplied by
	IndicesBreakerFielddataOverhead *float64 `pulumi:"indicesBreakerFielddataOverhead"`
	// The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
	IndicesBreakerRequestLimit *string `pulumi:"indicesBreakerRequestLimit"`
	// A constant that all request estimations are multiplied by
	IndicesBreakerRequestOverhead *float64 `pulumi:"indicesBreakerRequestOverhead"`
	// The percentage of total amount of memory that can be used across all breakers
	IndicesBreakerTotalLimit *string `pulumi:"indicesBreakerTotalLimit"`
	// Maximum total inbound and outbound recovery traffic for each node, in mb
	IndicesRecoveryMaxBytesPerSec *string `pulumi:"indicesRecoveryMaxBytesPerSec"`
	// The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
	NetworkBreakerInflightRequestsLimit *string `pulumi:"networkBreakerInflightRequestsLimit"`
	// A constant that all in flight requests estimations are multiplied by
	NetworkBreakerInflightRequestsOverhead *float64 `pulumi:"networkBreakerInflightRequestsOverhead"`
	// Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
	ScriptMaxCompilationsRate *string `pulumi:"scriptMaxCompilationsRate"`
	// A time string setting a cluster-wide default timeout for all search requests
	SearchDefaultSearchTimeout *string `pulumi:"searchDefaultSearchTimeout"`
}

// The set of arguments for constructing a ClusterSettings resource.
type ClusterSettingsArgs struct {
	// Whether to automatically create an index if it doesn’t already exist and apply any configured index template
	ActionAutoCreateIndex pulumi.StringPtrInput
	// When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
	ActionDestructiveRequiresName pulumi.BoolPtrInput
	// Make the whole cluster read only and metadata is not allowed to be modified
	ClusterBlocksReadOnly pulumi.BoolPtrInput
	// Make the whole cluster read only, but allows to delete indices to free up resources
	ClusterBlocksReadOnlyAllowDelete pulumi.BoolPtrInput
	// If false, you cannot close open indices
	ClusterIndicesCloseEnable pulumi.BoolPtrInput
	// A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
	ClusterInfoUpdateInterval pulumi.StringPtrInput
	// The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
	ClusterMaxShardsPerNode pulumi.IntPtrInput
	// The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
	ClusterMaxShardsPerNodeFrozen pulumi.IntPtrInput
	// Specifies which operations are rejected when there is no active master in a cluster (all, write)
	ClusterNoMasterBlock pulumi.StringPtrInput
	// Whether allocation for persistent tasks is active (all, none)
	ClusterPersistentTasksAllocationEnable pulumi.StringPtrInput
	// A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
	ClusterPersistentTasksAllocationRecheckInterval pulumi.StringPtrInput
	// Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)
	ClusterRoutingAllocationAllowRebalance pulumi.StringPtrInput
	// Use custom node attributes to take hardware configuration into account when allocating shards
	ClusterRoutingAllocationAwarenessAttributes pulumi.StringPtrInput
	// Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
	ClusterRoutingAllocationBalanceIndex pulumi.Float64PtrInput
	// Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
	ClusterRoutingAllocationBalanceShard pulumi.Float64PtrInput
	// Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
	ClusterRoutingAllocationBalanceThreshold pulumi.Float64PtrInput
	// How many concurrent shard rebalances are allowed cluster wide
	ClusterRoutingAllocationClusterConcurrentRebalance pulumi.IntPtrInput
	// Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
	ClusterRoutingAllocationDiskIncludeRelocations pulumi.BoolPtrInput
	// Whether the disk allocation decider is active
	ClusterRoutingAllocationDiskThresholdEnabled pulumi.BoolPtrInput
	// Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
	ClusterRoutingAllocationDiskWatermarkHigh pulumi.StringPtrInput
	// Allocator will not allocate shards to nodes that have more than this percentage disk used
	ClusterRoutingAllocationDiskWatermarkLow pulumi.StringPtrInput
	// Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
	ClusterRoutingAllocationEnable pulumi.StringPtrInput
	// How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentIncomingRecoveries pulumi.IntPtrInput
	// How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
	ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries pulumi.IntPtrInput
	// A shortcut to set both incoming and outgoing recoveries
	ClusterRoutingAllocationNodeConcurrentRecoveries pulumi.IntPtrInput
	// Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
	ClusterRoutingAllocationNodeInitialPrimariesRecoveries pulumi.IntPtrInput
	// Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
	ClusterRoutingAllocationSameShardHost pulumi.BoolPtrInput
	// Maximum number of primary and replica shards allocated to each node
	ClusterRoutingAllocationTotalShardsPerNode pulumi.IntPtrInput
	// Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
	ClusterRoutingRebalanceEnable pulumi.StringPtrInput
	// The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
	IndicesBreakerFielddataLimit pulumi.StringPtrInput
	// A constant that all field data estimations are multiplied by
	IndicesBreakerFielddataOverhead pulumi.Float64PtrInput
	// The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
	IndicesBreakerRequestLimit pulumi.StringPtrInput
	// A constant that all request estimations are multiplied by
	IndicesBreakerRequestOverhead pulumi.Float64PtrInput
	// The percentage of total amount of memory that can be used across all breakers
	IndicesBreakerTotalLimit pulumi.StringPtrInput
	// Maximum total inbound and outbound recovery traffic for each node, in mb
	IndicesRecoveryMaxBytesPerSec pulumi.StringPtrInput
	// The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
	NetworkBreakerInflightRequestsLimit pulumi.StringPtrInput
	// A constant that all in flight requests estimations are multiplied by
	NetworkBreakerInflightRequestsOverhead pulumi.Float64PtrInput
	// Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
	ScriptMaxCompilationsRate pulumi.StringPtrInput
	// A time string setting a cluster-wide default timeout for all search requests
	SearchDefaultSearchTimeout pulumi.StringPtrInput
}

func (ClusterSettingsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterSettingsArgs)(nil)).Elem()
}

type ClusterSettingsInput interface {
	pulumi.Input

	ToClusterSettingsOutput() ClusterSettingsOutput
	ToClusterSettingsOutputWithContext(ctx context.Context) ClusterSettingsOutput
}

func (*ClusterSettings) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterSettings)(nil)).Elem()
}

func (i *ClusterSettings) ToClusterSettingsOutput() ClusterSettingsOutput {
	return i.ToClusterSettingsOutputWithContext(context.Background())
}

func (i *ClusterSettings) ToClusterSettingsOutputWithContext(ctx context.Context) ClusterSettingsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterSettingsOutput)
}

// ClusterSettingsArrayInput is an input type that accepts ClusterSettingsArray and ClusterSettingsArrayOutput values.
// You can construct a concrete instance of `ClusterSettingsArrayInput` via:
//
//	ClusterSettingsArray{ ClusterSettingsArgs{...} }
type ClusterSettingsArrayInput interface {
	pulumi.Input

	ToClusterSettingsArrayOutput() ClusterSettingsArrayOutput
	ToClusterSettingsArrayOutputWithContext(context.Context) ClusterSettingsArrayOutput
}

type ClusterSettingsArray []ClusterSettingsInput

func (ClusterSettingsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ClusterSettings)(nil)).Elem()
}

func (i ClusterSettingsArray) ToClusterSettingsArrayOutput() ClusterSettingsArrayOutput {
	return i.ToClusterSettingsArrayOutputWithContext(context.Background())
}

func (i ClusterSettingsArray) ToClusterSettingsArrayOutputWithContext(ctx context.Context) ClusterSettingsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterSettingsArrayOutput)
}

// ClusterSettingsMapInput is an input type that accepts ClusterSettingsMap and ClusterSettingsMapOutput values.
// You can construct a concrete instance of `ClusterSettingsMapInput` via:
//
//	ClusterSettingsMap{ "key": ClusterSettingsArgs{...} }
type ClusterSettingsMapInput interface {
	pulumi.Input

	ToClusterSettingsMapOutput() ClusterSettingsMapOutput
	ToClusterSettingsMapOutputWithContext(context.Context) ClusterSettingsMapOutput
}

type ClusterSettingsMap map[string]ClusterSettingsInput

func (ClusterSettingsMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ClusterSettings)(nil)).Elem()
}

func (i ClusterSettingsMap) ToClusterSettingsMapOutput() ClusterSettingsMapOutput {
	return i.ToClusterSettingsMapOutputWithContext(context.Background())
}

func (i ClusterSettingsMap) ToClusterSettingsMapOutputWithContext(ctx context.Context) ClusterSettingsMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterSettingsMapOutput)
}

type ClusterSettingsOutput struct{ *pulumi.OutputState }

func (ClusterSettingsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterSettings)(nil)).Elem()
}

func (o ClusterSettingsOutput) ToClusterSettingsOutput() ClusterSettingsOutput {
	return o
}

func (o ClusterSettingsOutput) ToClusterSettingsOutputWithContext(ctx context.Context) ClusterSettingsOutput {
	return o
}

// Whether to automatically create an index if it doesn’t already exist and apply any configured index template
func (o ClusterSettingsOutput) ActionAutoCreateIndex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.ActionAutoCreateIndex }).(pulumi.StringPtrOutput)
}

// When set to true, you must specify the index name to delete an index and it is not possible to delete all indices with _all or use wildcards
func (o ClusterSettingsOutput) ActionDestructiveRequiresName() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.BoolPtrOutput { return v.ActionDestructiveRequiresName }).(pulumi.BoolPtrOutput)
}

// Make the whole cluster read only and metadata is not allowed to be modified
func (o ClusterSettingsOutput) ClusterBlocksReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.BoolPtrOutput { return v.ClusterBlocksReadOnly }).(pulumi.BoolPtrOutput)
}

// Make the whole cluster read only, but allows to delete indices to free up resources
func (o ClusterSettingsOutput) ClusterBlocksReadOnlyAllowDelete() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.BoolPtrOutput { return v.ClusterBlocksReadOnlyAllowDelete }).(pulumi.BoolPtrOutput)
}

// If false, you cannot close open indices
func (o ClusterSettingsOutput) ClusterIndicesCloseEnable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.BoolPtrOutput { return v.ClusterIndicesCloseEnable }).(pulumi.BoolPtrOutput)
}

// A time string controlling how often OpenSearch should check on disk usage for each node in the cluster
func (o ClusterSettingsOutput) ClusterInfoUpdateInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.ClusterInfoUpdateInterval }).(pulumi.StringPtrOutput)
}

// The total number of primary and replica shards for the cluster, this number is multiplied by the number of non-frozen data nodes; shards for closed indices do not count toward this limit
func (o ClusterSettingsOutput) ClusterMaxShardsPerNode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.IntPtrOutput { return v.ClusterMaxShardsPerNode }).(pulumi.IntPtrOutput)
}

// The total number of primary and replica frozen shards, for the cluster; Ssards for closed indices do not count toward this limit, a cluster with no frozen data nodes is unlimited.
func (o ClusterSettingsOutput) ClusterMaxShardsPerNodeFrozen() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.IntPtrOutput { return v.ClusterMaxShardsPerNodeFrozen }).(pulumi.IntPtrOutput)
}

// Specifies which operations are rejected when there is no active master in a cluster (all, write)
func (o ClusterSettingsOutput) ClusterNoMasterBlock() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.ClusterNoMasterBlock }).(pulumi.StringPtrOutput)
}

// Whether allocation for persistent tasks is active (all, none)
func (o ClusterSettingsOutput) ClusterPersistentTasksAllocationEnable() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.ClusterPersistentTasksAllocationEnable }).(pulumi.StringPtrOutput)
}

// A time string controling how often assignment checks are performed to react to whether persistent tasks can be assigned to nodes
func (o ClusterSettingsOutput) ClusterPersistentTasksAllocationRecheckInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput {
		return v.ClusterPersistentTasksAllocationRecheckInterval
	}).(pulumi.StringPtrOutput)
}

// Specify when shard rebalancing is allowed (always, indices*primaries*active, indices*all*active)
func (o ClusterSettingsOutput) ClusterRoutingAllocationAllowRebalance() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.ClusterRoutingAllocationAllowRebalance }).(pulumi.StringPtrOutput)
}

// Use custom node attributes to take hardware configuration into account when allocating shards
func (o ClusterSettingsOutput) ClusterRoutingAllocationAwarenessAttributes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.ClusterRoutingAllocationAwarenessAttributes }).(pulumi.StringPtrOutput)
}

// Weight factor for the number of shards per index allocated on a node, increasing this raises the tendency to equalize the number of shards per index across all nodes
func (o ClusterSettingsOutput) ClusterRoutingAllocationBalanceIndex() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.Float64PtrOutput { return v.ClusterRoutingAllocationBalanceIndex }).(pulumi.Float64PtrOutput)
}

// Weight factor for the total number of shards allocated on a node, increasing this raises the tendency to equalize the number of shards across all nodes
func (o ClusterSettingsOutput) ClusterRoutingAllocationBalanceShard() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.Float64PtrOutput { return v.ClusterRoutingAllocationBalanceShard }).(pulumi.Float64PtrOutput)
}

// Minimal optimization value of operations that should be performed, raising this will cause the cluster to be less aggressive about optimizing the shard balance
func (o ClusterSettingsOutput) ClusterRoutingAllocationBalanceThreshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.Float64PtrOutput { return v.ClusterRoutingAllocationBalanceThreshold }).(pulumi.Float64PtrOutput)
}

// How many concurrent shard rebalances are allowed cluster wide
func (o ClusterSettingsOutput) ClusterRoutingAllocationClusterConcurrentRebalance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.IntPtrOutput {
		return v.ClusterRoutingAllocationClusterConcurrentRebalance
	}).(pulumi.IntPtrOutput)
}

// Whether the allocator will take into account shards that are currently being relocated to the target node when computing a node’s disk usage
func (o ClusterSettingsOutput) ClusterRoutingAllocationDiskIncludeRelocations() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.BoolPtrOutput { return v.ClusterRoutingAllocationDiskIncludeRelocations }).(pulumi.BoolPtrOutput)
}

// Whether the disk allocation decider is active
func (o ClusterSettingsOutput) ClusterRoutingAllocationDiskThresholdEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.BoolPtrOutput { return v.ClusterRoutingAllocationDiskThresholdEnabled }).(pulumi.BoolPtrOutput)
}

// Allocator will attempt to relocate shards away from a node whose disk usage is above this percentage disk used
func (o ClusterSettingsOutput) ClusterRoutingAllocationDiskWatermarkHigh() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.ClusterRoutingAllocationDiskWatermarkHigh }).(pulumi.StringPtrOutput)
}

// Allocator will not allocate shards to nodes that have more than this percentage disk used
func (o ClusterSettingsOutput) ClusterRoutingAllocationDiskWatermarkLow() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.ClusterRoutingAllocationDiskWatermarkLow }).(pulumi.StringPtrOutput)
}

// Enable or disable allocation for specific kinds of shards (all, primaries, new_primaries, none)
func (o ClusterSettingsOutput) ClusterRoutingAllocationEnable() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.ClusterRoutingAllocationEnable }).(pulumi.StringPtrOutput)
}

// How many incoming recoveries where the target shard (likely the replica unless a shard is relocating) are allocated on the node
func (o ClusterSettingsOutput) ClusterRoutingAllocationNodeConcurrentIncomingRecoveries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.IntPtrOutput {
		return v.ClusterRoutingAllocationNodeConcurrentIncomingRecoveries
	}).(pulumi.IntPtrOutput)
}

// How many outgoing recoveries where the source shard (likely the primary unless a shard is relocating) are allocated on the node
func (o ClusterSettingsOutput) ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.IntPtrOutput {
		return v.ClusterRoutingAllocationNodeConcurrentOutgoingRecoveries
	}).(pulumi.IntPtrOutput)
}

// A shortcut to set both incoming and outgoing recoveries
func (o ClusterSettingsOutput) ClusterRoutingAllocationNodeConcurrentRecoveries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.IntPtrOutput {
		return v.ClusterRoutingAllocationNodeConcurrentRecoveries
	}).(pulumi.IntPtrOutput)
}

// Set a (usually) higher rate for primary recovery on node restart (usually from disk, so fast)
func (o ClusterSettingsOutput) ClusterRoutingAllocationNodeInitialPrimariesRecoveries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.IntPtrOutput {
		return v.ClusterRoutingAllocationNodeInitialPrimariesRecoveries
	}).(pulumi.IntPtrOutput)
}

// Perform a check to prevent allocation of multiple instances of the same shard on a single host, if multiple nodes are started on the host
func (o ClusterSettingsOutput) ClusterRoutingAllocationSameShardHost() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.BoolPtrOutput { return v.ClusterRoutingAllocationSameShardHost }).(pulumi.BoolPtrOutput)
}

// Maximum number of primary and replica shards allocated to each node
func (o ClusterSettingsOutput) ClusterRoutingAllocationTotalShardsPerNode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.IntPtrOutput { return v.ClusterRoutingAllocationTotalShardsPerNode }).(pulumi.IntPtrOutput)
}

// Allow rebalancing for specific kinds of shards (all, primaries, replicas, none)
func (o ClusterSettingsOutput) ClusterRoutingRebalanceEnable() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.ClusterRoutingRebalanceEnable }).(pulumi.StringPtrOutput)
}

// The percentage of memory above which if loading a field into the field data cache would cause the cache to exceed this limit, an error is returned
func (o ClusterSettingsOutput) IndicesBreakerFielddataLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.IndicesBreakerFielddataLimit }).(pulumi.StringPtrOutput)
}

// A constant that all field data estimations are multiplied by
func (o ClusterSettingsOutput) IndicesBreakerFielddataOverhead() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.Float64PtrOutput { return v.IndicesBreakerFielddataOverhead }).(pulumi.Float64PtrOutput)
}

// The percentabge of memory above which per-request data structures (e.g. calculating aggregations) are prevented from exceeding
func (o ClusterSettingsOutput) IndicesBreakerRequestLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.IndicesBreakerRequestLimit }).(pulumi.StringPtrOutput)
}

// A constant that all request estimations are multiplied by
func (o ClusterSettingsOutput) IndicesBreakerRequestOverhead() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.Float64PtrOutput { return v.IndicesBreakerRequestOverhead }).(pulumi.Float64PtrOutput)
}

// The percentage of total amount of memory that can be used across all breakers
func (o ClusterSettingsOutput) IndicesBreakerTotalLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.IndicesBreakerTotalLimit }).(pulumi.StringPtrOutput)
}

// Maximum total inbound and outbound recovery traffic for each node, in mb
func (o ClusterSettingsOutput) IndicesRecoveryMaxBytesPerSec() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.IndicesRecoveryMaxBytesPerSec }).(pulumi.StringPtrOutput)
}

// The percentage limit of memory usage on a node of all currently active incoming requests on transport or HTTP level
func (o ClusterSettingsOutput) NetworkBreakerInflightRequestsLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.NetworkBreakerInflightRequestsLimit }).(pulumi.StringPtrOutput)
}

// A constant that all in flight requests estimations are multiplied by
func (o ClusterSettingsOutput) NetworkBreakerInflightRequestsOverhead() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.Float64PtrOutput { return v.NetworkBreakerInflightRequestsOverhead }).(pulumi.Float64PtrOutput)
}

// Limit for the number of unique dynamic scripts within a certain interval that are allowed to be compiled, expressed as compilations divided by a time string
func (o ClusterSettingsOutput) ScriptMaxCompilationsRate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.ScriptMaxCompilationsRate }).(pulumi.StringPtrOutput)
}

// A time string setting a cluster-wide default timeout for all search requests
func (o ClusterSettingsOutput) SearchDefaultSearchTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterSettings) pulumi.StringPtrOutput { return v.SearchDefaultSearchTimeout }).(pulumi.StringPtrOutput)
}

type ClusterSettingsArrayOutput struct{ *pulumi.OutputState }

func (ClusterSettingsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ClusterSettings)(nil)).Elem()
}

func (o ClusterSettingsArrayOutput) ToClusterSettingsArrayOutput() ClusterSettingsArrayOutput {
	return o
}

func (o ClusterSettingsArrayOutput) ToClusterSettingsArrayOutputWithContext(ctx context.Context) ClusterSettingsArrayOutput {
	return o
}

func (o ClusterSettingsArrayOutput) Index(i pulumi.IntInput) ClusterSettingsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ClusterSettings {
		return vs[0].([]*ClusterSettings)[vs[1].(int)]
	}).(ClusterSettingsOutput)
}

type ClusterSettingsMapOutput struct{ *pulumi.OutputState }

func (ClusterSettingsMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ClusterSettings)(nil)).Elem()
}

func (o ClusterSettingsMapOutput) ToClusterSettingsMapOutput() ClusterSettingsMapOutput {
	return o
}

func (o ClusterSettingsMapOutput) ToClusterSettingsMapOutputWithContext(ctx context.Context) ClusterSettingsMapOutput {
	return o
}

func (o ClusterSettingsMapOutput) MapIndex(k pulumi.StringInput) ClusterSettingsOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ClusterSettings {
		return vs[0].(map[string]*ClusterSettings)[vs[1].(string)]
	}).(ClusterSettingsOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterSettingsInput)(nil)).Elem(), &ClusterSettings{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterSettingsArrayInput)(nil)).Elem(), ClusterSettingsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterSettingsMapInput)(nil)).Elem(), ClusterSettingsMap{})
	pulumi.RegisterOutputType(ClusterSettingsOutput{})
	pulumi.RegisterOutputType(ClusterSettingsArrayOutput{})
	pulumi.RegisterOutputType(ClusterSettingsMapOutput{})
}
